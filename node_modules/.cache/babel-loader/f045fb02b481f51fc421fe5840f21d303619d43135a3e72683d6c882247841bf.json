{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { absoluteSheetReference, invalidSimpleCellAddress, simpleCellAddress, simpleColumnAddress, simpleRowAddress } from \"../Cell.mjs\";\nimport { columnIndexToLabel } from \"./addressRepresentationConverters.mjs\";\nimport { ColumnAddress, ReferenceType } from \"./ColumnAddress.mjs\";\nimport { RowAddress } from \"./RowAddress.mjs\";\n/** Possible kinds of cell references */\nexport var CellReferenceType;\n(function (CellReferenceType) {\n  /** Cell reference with both row and column relative. */\n  CellReferenceType[\"CELL_REFERENCE_RELATIVE\"] = \"CELL_REFERENCE\";\n  /** Cell reference with both row and column absolute. */\n  CellReferenceType[\"CELL_REFERENCE_ABSOLUTE\"] = \"CELL_REFERENCE_ABSOLUTE\";\n  /** Cell reference with absolute column and relative row. */\n  CellReferenceType[\"CELL_REFERENCE_ABSOLUTE_COL\"] = \"CELL_REFERENCE_ABSOLUTE_COL\";\n  /** Cell reference with relative column and absolute row. */\n  CellReferenceType[\"CELL_REFERENCE_ABSOLUTE_ROW\"] = \"CELL_REFERENCE_ABSOLUTE_ROW\";\n})(CellReferenceType || (CellReferenceType = {}));\nexport class CellAddress {\n  constructor(col, row, type, sheet) {\n    this.col = col;\n    this.row = row;\n    this.type = type;\n    this.sheet = sheet;\n  }\n  static fromColAndRow(col, row, sheet) {\n    const factoryMethod = col.isColumnAbsolute() && row.isRowAbsolute() ? CellAddress.absolute.bind(this) : col.isColumnAbsolute() ? CellAddress.absoluteCol.bind(this) : row.isRowAbsolute() ? CellAddress.absoluteRow.bind(this) : CellAddress.relative.bind(this);\n    return factoryMethod(col.col, row.row, sheet);\n  }\n  static relative(col, row, sheet) {\n    return new CellAddress(col, row, CellReferenceType.CELL_REFERENCE_RELATIVE, sheet);\n  }\n  static absolute(col, row, sheet) {\n    return new CellAddress(col, row, CellReferenceType.CELL_REFERENCE_ABSOLUTE, sheet);\n  }\n  static absoluteCol(col, row, sheet) {\n    return new CellAddress(col, row, CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL, sheet);\n  }\n  static absoluteRow(col, row, sheet) {\n    return new CellAddress(col, row, CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW, sheet);\n  }\n  /**\r\n   * Converts R0C0 representation of cell address to simple object representation.\r\n   *\r\n   * @param baseAddress - base address for R0C0 shifts\r\n   */\n  toSimpleCellAddress(baseAddress) {\n    const sheet = absoluteSheetReference(this, baseAddress);\n    if (this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE) {\n      return simpleCellAddress(sheet, this.col, this.row);\n    } else if (this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW) {\n      return simpleCellAddress(sheet, baseAddress.col + this.col, this.row);\n    } else if (this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL) {\n      return simpleCellAddress(sheet, this.col, baseAddress.row + this.row);\n    } else {\n      return simpleCellAddress(sheet, baseAddress.col + this.col, baseAddress.row + this.row);\n    }\n  }\n  toColumnAddress() {\n    const refType = this.isColumnRelative() ? ReferenceType.RELATIVE : ReferenceType.ABSOLUTE;\n    return new ColumnAddress(refType, this.col, this.sheet);\n  }\n  toRowAddress() {\n    const refType = this.isRowRelative() ? ReferenceType.RELATIVE : ReferenceType.ABSOLUTE;\n    return new RowAddress(refType, this.row, this.sheet);\n  }\n  toSimpleColumnAddress(baseAddress) {\n    const sheet = absoluteSheetReference(this, baseAddress);\n    let column = this.col;\n    if (this.isColumnRelative()) {\n      column += baseAddress.col;\n    }\n    return simpleColumnAddress(sheet, column);\n  }\n  toSimpleRowAddress(baseAddress) {\n    const sheet = absoluteSheetReference(this, baseAddress);\n    let row = this.row;\n    if (this.isRowRelative()) {\n      row += baseAddress.row;\n    }\n    return simpleRowAddress(sheet, row);\n  }\n  isRowAbsolute() {\n    return this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW;\n  }\n  isColumnAbsolute() {\n    return this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL;\n  }\n  isColumnRelative() {\n    return this.type === CellReferenceType.CELL_REFERENCE_RELATIVE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW;\n  }\n  isRowRelative() {\n    return this.type === CellReferenceType.CELL_REFERENCE_RELATIVE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL;\n  }\n  isAbsolute() {\n    return this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE && this.sheet !== undefined;\n  }\n  shiftedByRows(numberOfRows) {\n    return new CellAddress(this.col, this.row + numberOfRows, this.type, this.sheet);\n  }\n  shiftedByColumns(numberOfColumns) {\n    return new CellAddress(this.col + numberOfColumns, this.row, this.type, this.sheet);\n  }\n  moved(toSheet, toRight, toBottom) {\n    const newSheet = this.sheet === undefined ? undefined : toSheet;\n    return new CellAddress(this.col + toRight, this.row + toBottom, this.type, newSheet);\n  }\n  withSheet(sheet) {\n    return new CellAddress(this.col, this.row, this.type, sheet);\n  }\n  isInvalid(baseAddress) {\n    return invalidSimpleCellAddress(this.toSimpleCellAddress(baseAddress));\n  }\n  shiftRelativeDimensions(toRight, toBottom) {\n    const col = this.isColumnAbsolute() ? this.col : this.col + toRight;\n    const row = this.isRowAbsolute() ? this.row : this.row + toBottom;\n    return new CellAddress(col, row, this.type, this.sheet);\n  }\n  shiftAbsoluteDimensions(toRight, toBottom) {\n    const col = this.isColumnRelative() ? this.col : this.col + toRight;\n    const row = this.isRowRelative() ? this.row : this.row + toBottom;\n    return new CellAddress(col, row, this.type, this.sheet);\n  }\n  hash(withSheet) {\n    const sheetPart = withSheet && this.sheet !== undefined ? `#${this.sheet}` : '';\n    switch (this.type) {\n      case CellReferenceType.CELL_REFERENCE_RELATIVE:\n        {\n          return `${sheetPart}#${this.row}R${this.col}`;\n        }\n      case CellReferenceType.CELL_REFERENCE_ABSOLUTE:\n        {\n          return `${sheetPart}#${this.row}A${this.col}`;\n        }\n      case CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL:\n        {\n          return `${sheetPart}#${this.row}AC${this.col}`;\n        }\n      case CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW:\n        {\n          return `${sheetPart}#${this.row}AR${this.col}`;\n        }\n    }\n  }\n  unparse(baseAddress) {\n    const simpleAddress = this.toSimpleCellAddress(baseAddress);\n    if (invalidSimpleCellAddress(simpleAddress)) {\n      return undefined;\n    }\n    const column = columnIndexToLabel(simpleAddress.col);\n    const rowDollar = this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW ? '$' : '';\n    const colDollar = this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL ? '$' : '';\n    return `${colDollar}${column}${rowDollar}${simpleAddress.row + 1}`;\n  }\n  exceedsSheetSizeLimits(maxColumns, maxRows) {\n    return this.row >= maxRows || this.col >= maxColumns;\n  }\n}","map":{"version":3,"names":["absoluteSheetReference","invalidSimpleCellAddress","simpleCellAddress","simpleColumnAddress","simpleRowAddress","columnIndexToLabel","ColumnAddress","ReferenceType","RowAddress","CellReferenceType","CellAddress","constructor","col","row","type","sheet","fromColAndRow","factoryMethod","isColumnAbsolute","isRowAbsolute","absolute","bind","absoluteCol","absoluteRow","relative","CELL_REFERENCE_RELATIVE","CELL_REFERENCE_ABSOLUTE","CELL_REFERENCE_ABSOLUTE_COL","CELL_REFERENCE_ABSOLUTE_ROW","toSimpleCellAddress","baseAddress","toColumnAddress","refType","isColumnRelative","RELATIVE","ABSOLUTE","toRowAddress","isRowRelative","toSimpleColumnAddress","column","toSimpleRowAddress","isAbsolute","undefined","shiftedByRows","numberOfRows","shiftedByColumns","numberOfColumns","moved","toSheet","toRight","toBottom","newSheet","withSheet","isInvalid","shiftRelativeDimensions","shiftAbsoluteDimensions","hash","sheetPart","unparse","simpleAddress","rowDollar","colDollar","exceedsSheetSizeLimits","maxColumns","maxRows"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/parser/CellAddress.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { absoluteSheetReference, invalidSimpleCellAddress, simpleCellAddress, simpleColumnAddress, simpleRowAddress } from \"../Cell.mjs\";\nimport { columnIndexToLabel } from \"./addressRepresentationConverters.mjs\";\nimport { ColumnAddress, ReferenceType } from \"./ColumnAddress.mjs\";\nimport { RowAddress } from \"./RowAddress.mjs\";\n/** Possible kinds of cell references */\nexport var CellReferenceType;\n(function (CellReferenceType) {\n  /** Cell reference with both row and column relative. */\n  CellReferenceType[\"CELL_REFERENCE_RELATIVE\"] = \"CELL_REFERENCE\";\n  /** Cell reference with both row and column absolute. */\n  CellReferenceType[\"CELL_REFERENCE_ABSOLUTE\"] = \"CELL_REFERENCE_ABSOLUTE\";\n  /** Cell reference with absolute column and relative row. */\n  CellReferenceType[\"CELL_REFERENCE_ABSOLUTE_COL\"] = \"CELL_REFERENCE_ABSOLUTE_COL\";\n  /** Cell reference with relative column and absolute row. */\n  CellReferenceType[\"CELL_REFERENCE_ABSOLUTE_ROW\"] = \"CELL_REFERENCE_ABSOLUTE_ROW\";\n})(CellReferenceType || (CellReferenceType = {}));\nexport class CellAddress {\n  constructor(col, row, type, sheet) {\n    this.col = col;\n    this.row = row;\n    this.type = type;\n    this.sheet = sheet;\n  }\n  static fromColAndRow(col, row, sheet) {\n    const factoryMethod = col.isColumnAbsolute() && row.isRowAbsolute() ? CellAddress.absolute.bind(this) : col.isColumnAbsolute() ? CellAddress.absoluteCol.bind(this) : row.isRowAbsolute() ? CellAddress.absoluteRow.bind(this) : CellAddress.relative.bind(this);\n    return factoryMethod(col.col, row.row, sheet);\n  }\n  static relative(col, row, sheet) {\n    return new CellAddress(col, row, CellReferenceType.CELL_REFERENCE_RELATIVE, sheet);\n  }\n  static absolute(col, row, sheet) {\n    return new CellAddress(col, row, CellReferenceType.CELL_REFERENCE_ABSOLUTE, sheet);\n  }\n  static absoluteCol(col, row, sheet) {\n    return new CellAddress(col, row, CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL, sheet);\n  }\n  static absoluteRow(col, row, sheet) {\n    return new CellAddress(col, row, CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW, sheet);\n  }\n  /**\r\n   * Converts R0C0 representation of cell address to simple object representation.\r\n   *\r\n   * @param baseAddress - base address for R0C0 shifts\r\n   */\n  toSimpleCellAddress(baseAddress) {\n    const sheet = absoluteSheetReference(this, baseAddress);\n    if (this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE) {\n      return simpleCellAddress(sheet, this.col, this.row);\n    } else if (this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW) {\n      return simpleCellAddress(sheet, baseAddress.col + this.col, this.row);\n    } else if (this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL) {\n      return simpleCellAddress(sheet, this.col, baseAddress.row + this.row);\n    } else {\n      return simpleCellAddress(sheet, baseAddress.col + this.col, baseAddress.row + this.row);\n    }\n  }\n  toColumnAddress() {\n    const refType = this.isColumnRelative() ? ReferenceType.RELATIVE : ReferenceType.ABSOLUTE;\n    return new ColumnAddress(refType, this.col, this.sheet);\n  }\n  toRowAddress() {\n    const refType = this.isRowRelative() ? ReferenceType.RELATIVE : ReferenceType.ABSOLUTE;\n    return new RowAddress(refType, this.row, this.sheet);\n  }\n  toSimpleColumnAddress(baseAddress) {\n    const sheet = absoluteSheetReference(this, baseAddress);\n    let column = this.col;\n    if (this.isColumnRelative()) {\n      column += baseAddress.col;\n    }\n    return simpleColumnAddress(sheet, column);\n  }\n  toSimpleRowAddress(baseAddress) {\n    const sheet = absoluteSheetReference(this, baseAddress);\n    let row = this.row;\n    if (this.isRowRelative()) {\n      row += baseAddress.row;\n    }\n    return simpleRowAddress(sheet, row);\n  }\n  isRowAbsolute() {\n    return this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW;\n  }\n  isColumnAbsolute() {\n    return this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL;\n  }\n  isColumnRelative() {\n    return this.type === CellReferenceType.CELL_REFERENCE_RELATIVE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW;\n  }\n  isRowRelative() {\n    return this.type === CellReferenceType.CELL_REFERENCE_RELATIVE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL;\n  }\n  isAbsolute() {\n    return this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE && this.sheet !== undefined;\n  }\n  shiftedByRows(numberOfRows) {\n    return new CellAddress(this.col, this.row + numberOfRows, this.type, this.sheet);\n  }\n  shiftedByColumns(numberOfColumns) {\n    return new CellAddress(this.col + numberOfColumns, this.row, this.type, this.sheet);\n  }\n  moved(toSheet, toRight, toBottom) {\n    const newSheet = this.sheet === undefined ? undefined : toSheet;\n    return new CellAddress(this.col + toRight, this.row + toBottom, this.type, newSheet);\n  }\n  withSheet(sheet) {\n    return new CellAddress(this.col, this.row, this.type, sheet);\n  }\n  isInvalid(baseAddress) {\n    return invalidSimpleCellAddress(this.toSimpleCellAddress(baseAddress));\n  }\n  shiftRelativeDimensions(toRight, toBottom) {\n    const col = this.isColumnAbsolute() ? this.col : this.col + toRight;\n    const row = this.isRowAbsolute() ? this.row : this.row + toBottom;\n    return new CellAddress(col, row, this.type, this.sheet);\n  }\n  shiftAbsoluteDimensions(toRight, toBottom) {\n    const col = this.isColumnRelative() ? this.col : this.col + toRight;\n    const row = this.isRowRelative() ? this.row : this.row + toBottom;\n    return new CellAddress(col, row, this.type, this.sheet);\n  }\n  hash(withSheet) {\n    const sheetPart = withSheet && this.sheet !== undefined ? `#${this.sheet}` : '';\n    switch (this.type) {\n      case CellReferenceType.CELL_REFERENCE_RELATIVE:\n        {\n          return `${sheetPart}#${this.row}R${this.col}`;\n        }\n      case CellReferenceType.CELL_REFERENCE_ABSOLUTE:\n        {\n          return `${sheetPart}#${this.row}A${this.col}`;\n        }\n      case CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL:\n        {\n          return `${sheetPart}#${this.row}AC${this.col}`;\n        }\n      case CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW:\n        {\n          return `${sheetPart}#${this.row}AR${this.col}`;\n        }\n    }\n  }\n  unparse(baseAddress) {\n    const simpleAddress = this.toSimpleCellAddress(baseAddress);\n    if (invalidSimpleCellAddress(simpleAddress)) {\n      return undefined;\n    }\n    const column = columnIndexToLabel(simpleAddress.col);\n    const rowDollar = this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW ? '$' : '';\n    const colDollar = this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL ? '$' : '';\n    return `${colDollar}${column}${rowDollar}${simpleAddress.row + 1}`;\n  }\n  exceedsSheetSizeLimits(maxColumns, maxRows) {\n    return this.row >= maxRows || this.col >= maxColumns;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}