{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { TopSort } from \"./TopSort.mjs\";\nimport { ProcessableValue } from \"./ProcessableValue.mjs\";\n/**\r\n * Provides directed graph structure.\r\n *\r\n * Idea for performance improvement:\r\n * - use Set<Node>[] instead of NodeId[][] for edgesSparseArray\r\n */\nexport class Graph {\n  constructor(dependencyQuery) {\n    this.dependencyQuery = dependencyQuery;\n    /**\r\n     * A sparse array. The value nodesSparseArray[n] exists if and only if node n is in the graph.\r\n     * @private\r\n     */\n    this.nodesSparseArray = [];\n    /**\r\n     * A sparse array. The value edgesSparseArray[n] exists if and only if node n is in the graph.\r\n     * The edgesSparseArray[n] is also a sparse array. It may contain removed nodes. To make sure check nodesSparseArray.\r\n     * @private\r\n     */\n    this.edgesSparseArray = [];\n    /**\r\n     * A mapping from node to its id. The value nodesIds.get(node) exists if and only if node is in the graph.\r\n     * @private\r\n     */\n    this.nodesIds = new Map();\n    /**\r\n     * A ProcessableValue object.\r\n     * @private\r\n     */\n    this.dirtyAndVolatileNodeIds = new ProcessableValue({\n      dirty: [],\n      volatile: []\n    }, r => this.processDirtyAndVolatileNodeIds(r));\n    /**\r\n     * A set of node ids. The value infiniteRangeIds.get(nodeId) exists if and only if node is in the graph.\r\n     * @private\r\n     */\n    this.infiniteRangeIds = new Set();\n    /**\r\n     * A dense array. It may contain duplicates and removed nodes.\r\n     * @private\r\n     */\n    this.changingWithStructureNodeIds = [];\n    this.nextId = 0;\n  }\n  /**\r\n   * Iterate over all nodes the in graph\r\n   */\n  getNodes() {\n    return this.nodesSparseArray.filter(node => node !== undefined);\n  }\n  /**\r\n   * Checks whether a node is present in graph\r\n   *\r\n   * @param node - node to check\r\n   */\n  hasNode(node) {\n    return this.nodesIds.has(node);\n  }\n  /**\r\n   * Checks whether exists edge between nodes. If one or both of nodes are not present in graph, returns false.\r\n   *\r\n   * @param fromNode - node from which edge is outcoming\r\n   * @param toNode - node to which edge is incoming\r\n   */\n  existsEdge(fromNode, toNode) {\n    const fromId = this.getNodeId(fromNode);\n    const toId = this.getNodeId(toNode);\n    if (fromId === undefined || toId === undefined) {\n      return false;\n    }\n    return this.edgesSparseArray[fromId].includes(toId);\n  }\n  /**\r\n   * Returns nodes adjacent to given node. May contain removed nodes.\r\n   *\r\n   * @param node - node to which adjacent nodes we want to retrieve\r\n   *\r\n   * Idea for performance improvement:\r\n   * - return an array instead of set\r\n   */\n  adjacentNodes(node) {\n    const id = this.getNodeId(node);\n    if (id === undefined) {\n      throw this.missingNodeError(node);\n    }\n    return new Set(this.edgesSparseArray[id].filter(id => id !== undefined).map(id => this.nodesSparseArray[id]));\n  }\n  /**\r\n   * Returns number of nodes adjacent to given node. Contrary to adjacentNodes(), this method returns only nodes that are present in graph.\r\n   *\r\n   * @param node - node to which adjacent nodes we want to retrieve\r\n   */\n  adjacentNodesCount(node) {\n    const id = this.getNodeId(node);\n    if (id === undefined) {\n      throw this.missingNodeError(node);\n    }\n    return this.fixEdgesArrayForNode(id).length;\n  }\n  /**\r\n   * Adds node to a graph\r\n   *\r\n   * @param node - a node to be added\r\n   */\n  addNodeAndReturnId(node) {\n    const idOfExistingNode = this.nodesIds.get(node);\n    if (idOfExistingNode !== undefined) {\n      return idOfExistingNode;\n    }\n    const newId = this.nextId;\n    this.nextId++;\n    this.nodesSparseArray[newId] = node;\n    this.edgesSparseArray[newId] = [];\n    this.nodesIds.set(node, newId);\n    return newId;\n  }\n  /**\r\n   * Adds edge between nodes.\r\n   *\r\n   * The nodes had to be added to the graph before, or the error will be raised\r\n   *\r\n   * @param fromNode - node from which edge is outcoming\r\n   * @param toNode - node to which edge is incoming\r\n   */\n  addEdge(fromNode, toNode) {\n    const fromId = this.getNodeIdIfNotNumber(fromNode);\n    const toId = this.getNodeIdIfNotNumber(toNode);\n    if (fromId === undefined) {\n      throw this.missingNodeError(fromNode);\n    }\n    if (toId === undefined) {\n      throw this.missingNodeError(toNode);\n    }\n    if (this.edgesSparseArray[fromId].includes(toId)) {\n      return;\n    }\n    this.edgesSparseArray[fromId].push(toId);\n  }\n  /**\r\n   * Removes node from graph\r\n   */\n  removeNode(node) {\n    const id = this.getNodeId(node);\n    if (id === undefined) {\n      throw this.missingNodeError(node);\n    }\n    if (this.edgesSparseArray[id].length > 0) {\n      this.edgesSparseArray[id].forEach(adjacentId => this.dirtyAndVolatileNodeIds.rawValue.dirty.push(adjacentId));\n      this.dirtyAndVolatileNodeIds.markAsModified();\n    }\n    const dependencies = this.removeDependencies(node);\n    delete this.nodesSparseArray[id];\n    delete this.edgesSparseArray[id];\n    this.infiniteRangeIds.delete(id);\n    this.nodesIds.delete(node);\n    return dependencies;\n  }\n  /**\r\n   * Removes edge between nodes.\r\n   */\n  removeEdge(fromNode, toNode) {\n    const fromId = this.getNodeIdIfNotNumber(fromNode);\n    const toId = this.getNodeIdIfNotNumber(toNode);\n    if (fromId === undefined) {\n      throw this.missingNodeError(fromNode);\n    }\n    if (toId === undefined) {\n      throw this.missingNodeError(toNode);\n    }\n    const indexOfToId = this.edgesSparseArray[fromId].indexOf(toId);\n    if (indexOfToId === -1) {\n      throw new Error('Edge does not exist');\n    }\n    delete this.edgesSparseArray[fromId][indexOfToId];\n  }\n  /**\r\n   * Removes edge between nodes if it exists.\r\n   */\n  removeEdgeIfExists(fromNode, toNode) {\n    const fromId = this.getNodeId(fromNode);\n    const toId = this.getNodeId(toNode);\n    if (fromId === undefined) {\n      return;\n    }\n    if (toId === undefined) {\n      return;\n    }\n    const indexOfToId = this.edgesSparseArray[fromId].indexOf(toId);\n    if (indexOfToId === -1) {\n      return;\n    }\n    delete this.edgesSparseArray[fromId][indexOfToId];\n  }\n  /**\r\n   * Sorts the whole graph topologically. Nodes that are on cycles are kept separate.\r\n   */\n  topSortWithScc() {\n    return this.getTopSortedWithSccSubgraphFrom(this.getNodes(), () => true, () => {});\n  }\n  /**\r\n   * Sorts the graph topologically. Nodes that are on cycles are kept separate.\r\n   *\r\n   * @param modifiedNodes - seed for computation. The algorithm assumes that only these nodes have changed since the last run.\r\n   * @param operatingFunction - recomputes value of a node, and returns whether a change occurred\r\n   * @param onCycle - action to be performed when node is on cycle\r\n   */\n  getTopSortedWithSccSubgraphFrom(modifiedNodes, operatingFunction, onCycle) {\n    const topSortAlgorithm = new TopSort(this.nodesSparseArray, this.edgesSparseArray);\n    const modifiedNodesIds = modifiedNodes.map(node => this.getNodeId(node)).filter(id => id !== undefined);\n    return topSortAlgorithm.getTopSortedWithSccSubgraphFrom(modifiedNodesIds, operatingFunction, onCycle);\n  }\n  /**\r\n   * Marks node as volatile.\r\n   */\n  markNodeAsVolatile(node) {\n    const id = this.getNodeId(node);\n    if (id === undefined) {\n      return;\n    }\n    this.dirtyAndVolatileNodeIds.rawValue.volatile.push(id);\n    this.dirtyAndVolatileNodeIds.markAsModified();\n  }\n  /**\r\n   * Marks node as dirty.\r\n   */\n  markNodeAsDirty(node) {\n    const id = this.getNodeId(node);\n    if (id === undefined) {\n      return;\n    }\n    this.dirtyAndVolatileNodeIds.rawValue.dirty.push(id);\n    this.dirtyAndVolatileNodeIds.markAsModified();\n  }\n  /**\r\n   * Returns an array of nodes that are marked as dirty and/or volatile.\r\n   */\n  getDirtyAndVolatileNodes() {\n    return this.dirtyAndVolatileNodeIds.getProcessedValue();\n  }\n  /**\r\n   * Clears dirty nodes.\r\n   */\n  clearDirtyNodes() {\n    this.dirtyAndVolatileNodeIds.rawValue.dirty = [];\n    this.dirtyAndVolatileNodeIds.markAsModified();\n  }\n  /**\r\n   * Marks node as changingWithStructure.\r\n   */\n  markNodeAsChangingWithStructure(node) {\n    const id = this.getNodeId(node);\n    if (id === undefined) {\n      return;\n    }\n    this.changingWithStructureNodeIds.push(id);\n  }\n  /**\r\n   * Marks all nodes marked as changingWithStructure as dirty.\r\n   */\n  markChangingWithStructureNodesAsDirty() {\n    if (this.changingWithStructureNodeIds.length <= 0) {\n      return;\n    }\n    this.dirtyAndVolatileNodeIds.rawValue.dirty = [...this.dirtyAndVolatileNodeIds.rawValue.dirty, ...this.changingWithStructureNodeIds];\n    this.dirtyAndVolatileNodeIds.markAsModified();\n  }\n  /**\r\n   * Marks node as infinite range.\r\n   */\n  markNodeAsInfiniteRange(node) {\n    const id = this.getNodeIdIfNotNumber(node);\n    if (id === undefined) {\n      return;\n    }\n    this.infiniteRangeIds.add(id);\n  }\n  /**\r\n   * Returns an array of nodes marked as infinite ranges\r\n   */\n  getInfiniteRanges() {\n    return [...this.infiniteRangeIds].map(id => ({\n      node: this.nodesSparseArray[id],\n      id\n    }));\n  }\n  /**\r\n   * Returns the internal id of a node.\r\n   */\n  getNodeId(node) {\n    return this.nodesIds.get(node);\n  }\n  /**\r\n   *\r\n   */\n  getNodeIdIfNotNumber(node) {\n    return typeof node === 'number' ? node : this.nodesIds.get(node);\n  }\n  /**\r\n   * Removes invalid neighbors of a given node from the edges array and returns adjacent nodes for the input node.\r\n   */\n  fixEdgesArrayForNode(id) {\n    const adjacentNodeIds = this.edgesSparseArray[id];\n    this.edgesSparseArray[id] = adjacentNodeIds.filter(adjacentId => adjacentId !== undefined && this.nodesSparseArray[adjacentId]);\n    return this.edgesSparseArray[id];\n  }\n  /**\r\n   * Removes edges from the given node to its dependencies based on the dependencyQuery function.\r\n   */\n  removeDependencies(node) {\n    const dependencies = this.dependencyQuery(node);\n    dependencies.forEach(([_, dependency]) => {\n      this.removeEdgeIfExists(dependency, node);\n    });\n    return dependencies;\n  }\n  /**\r\n   * processFn for dirtyAndVolatileNodeIds ProcessableValue instance\r\n   * @private\r\n   */\n  processDirtyAndVolatileNodeIds({\n    dirty,\n    volatile\n  }) {\n    return [...new Set([...dirty, ...volatile])].map(id => this.nodesSparseArray[id]).filter(node => node !== undefined);\n  }\n  /**\r\n   * Returns error for missing node.\r\n   */\n  missingNodeError(node) {\n    return new Error(`Unknown node ${node}`);\n  }\n}","map":{"version":3,"names":["TopSort","ProcessableValue","Graph","constructor","dependencyQuery","nodesSparseArray","edgesSparseArray","nodesIds","Map","dirtyAndVolatileNodeIds","dirty","volatile","r","processDirtyAndVolatileNodeIds","infiniteRangeIds","Set","changingWithStructureNodeIds","nextId","getNodes","filter","node","undefined","hasNode","has","existsEdge","fromNode","toNode","fromId","getNodeId","toId","includes","adjacentNodes","id","missingNodeError","map","adjacentNodesCount","fixEdgesArrayForNode","length","addNodeAndReturnId","idOfExistingNode","get","newId","set","addEdge","getNodeIdIfNotNumber","push","removeNode","forEach","adjacentId","rawValue","markAsModified","dependencies","removeDependencies","delete","removeEdge","indexOfToId","indexOf","Error","removeEdgeIfExists","topSortWithScc","getTopSortedWithSccSubgraphFrom","modifiedNodes","operatingFunction","onCycle","topSortAlgorithm","modifiedNodesIds","markNodeAsVolatile","markNodeAsDirty","getDirtyAndVolatileNodes","getProcessedValue","clearDirtyNodes","markNodeAsChangingWithStructure","markChangingWithStructureNodesAsDirty","markNodeAsInfiniteRange","add","getInfiniteRanges","adjacentNodeIds","_","dependency"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/DependencyGraph/Graph.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { TopSort } from \"./TopSort.mjs\";\nimport { ProcessableValue } from \"./ProcessableValue.mjs\";\n/**\r\n * Provides directed graph structure.\r\n *\r\n * Idea for performance improvement:\r\n * - use Set<Node>[] instead of NodeId[][] for edgesSparseArray\r\n */\nexport class Graph {\n  constructor(dependencyQuery) {\n    this.dependencyQuery = dependencyQuery;\n    /**\r\n     * A sparse array. The value nodesSparseArray[n] exists if and only if node n is in the graph.\r\n     * @private\r\n     */\n    this.nodesSparseArray = [];\n    /**\r\n     * A sparse array. The value edgesSparseArray[n] exists if and only if node n is in the graph.\r\n     * The edgesSparseArray[n] is also a sparse array. It may contain removed nodes. To make sure check nodesSparseArray.\r\n     * @private\r\n     */\n    this.edgesSparseArray = [];\n    /**\r\n     * A mapping from node to its id. The value nodesIds.get(node) exists if and only if node is in the graph.\r\n     * @private\r\n     */\n    this.nodesIds = new Map();\n    /**\r\n     * A ProcessableValue object.\r\n     * @private\r\n     */\n    this.dirtyAndVolatileNodeIds = new ProcessableValue({\n      dirty: [],\n      volatile: []\n    }, r => this.processDirtyAndVolatileNodeIds(r));\n    /**\r\n     * A set of node ids. The value infiniteRangeIds.get(nodeId) exists if and only if node is in the graph.\r\n     * @private\r\n     */\n    this.infiniteRangeIds = new Set();\n    /**\r\n     * A dense array. It may contain duplicates and removed nodes.\r\n     * @private\r\n     */\n    this.changingWithStructureNodeIds = [];\n    this.nextId = 0;\n  }\n  /**\r\n   * Iterate over all nodes the in graph\r\n   */\n  getNodes() {\n    return this.nodesSparseArray.filter(node => node !== undefined);\n  }\n  /**\r\n   * Checks whether a node is present in graph\r\n   *\r\n   * @param node - node to check\r\n   */\n  hasNode(node) {\n    return this.nodesIds.has(node);\n  }\n  /**\r\n   * Checks whether exists edge between nodes. If one or both of nodes are not present in graph, returns false.\r\n   *\r\n   * @param fromNode - node from which edge is outcoming\r\n   * @param toNode - node to which edge is incoming\r\n   */\n  existsEdge(fromNode, toNode) {\n    const fromId = this.getNodeId(fromNode);\n    const toId = this.getNodeId(toNode);\n    if (fromId === undefined || toId === undefined) {\n      return false;\n    }\n    return this.edgesSparseArray[fromId].includes(toId);\n  }\n  /**\r\n   * Returns nodes adjacent to given node. May contain removed nodes.\r\n   *\r\n   * @param node - node to which adjacent nodes we want to retrieve\r\n   *\r\n   * Idea for performance improvement:\r\n   * - return an array instead of set\r\n   */\n  adjacentNodes(node) {\n    const id = this.getNodeId(node);\n    if (id === undefined) {\n      throw this.missingNodeError(node);\n    }\n    return new Set(this.edgesSparseArray[id].filter(id => id !== undefined).map(id => this.nodesSparseArray[id]));\n  }\n  /**\r\n   * Returns number of nodes adjacent to given node. Contrary to adjacentNodes(), this method returns only nodes that are present in graph.\r\n   *\r\n   * @param node - node to which adjacent nodes we want to retrieve\r\n   */\n  adjacentNodesCount(node) {\n    const id = this.getNodeId(node);\n    if (id === undefined) {\n      throw this.missingNodeError(node);\n    }\n    return this.fixEdgesArrayForNode(id).length;\n  }\n  /**\r\n   * Adds node to a graph\r\n   *\r\n   * @param node - a node to be added\r\n   */\n  addNodeAndReturnId(node) {\n    const idOfExistingNode = this.nodesIds.get(node);\n    if (idOfExistingNode !== undefined) {\n      return idOfExistingNode;\n    }\n    const newId = this.nextId;\n    this.nextId++;\n    this.nodesSparseArray[newId] = node;\n    this.edgesSparseArray[newId] = [];\n    this.nodesIds.set(node, newId);\n    return newId;\n  }\n  /**\r\n   * Adds edge between nodes.\r\n   *\r\n   * The nodes had to be added to the graph before, or the error will be raised\r\n   *\r\n   * @param fromNode - node from which edge is outcoming\r\n   * @param toNode - node to which edge is incoming\r\n   */\n  addEdge(fromNode, toNode) {\n    const fromId = this.getNodeIdIfNotNumber(fromNode);\n    const toId = this.getNodeIdIfNotNumber(toNode);\n    if (fromId === undefined) {\n      throw this.missingNodeError(fromNode);\n    }\n    if (toId === undefined) {\n      throw this.missingNodeError(toNode);\n    }\n    if (this.edgesSparseArray[fromId].includes(toId)) {\n      return;\n    }\n    this.edgesSparseArray[fromId].push(toId);\n  }\n  /**\r\n   * Removes node from graph\r\n   */\n  removeNode(node) {\n    const id = this.getNodeId(node);\n    if (id === undefined) {\n      throw this.missingNodeError(node);\n    }\n    if (this.edgesSparseArray[id].length > 0) {\n      this.edgesSparseArray[id].forEach(adjacentId => this.dirtyAndVolatileNodeIds.rawValue.dirty.push(adjacentId));\n      this.dirtyAndVolatileNodeIds.markAsModified();\n    }\n    const dependencies = this.removeDependencies(node);\n    delete this.nodesSparseArray[id];\n    delete this.edgesSparseArray[id];\n    this.infiniteRangeIds.delete(id);\n    this.nodesIds.delete(node);\n    return dependencies;\n  }\n  /**\r\n   * Removes edge between nodes.\r\n   */\n  removeEdge(fromNode, toNode) {\n    const fromId = this.getNodeIdIfNotNumber(fromNode);\n    const toId = this.getNodeIdIfNotNumber(toNode);\n    if (fromId === undefined) {\n      throw this.missingNodeError(fromNode);\n    }\n    if (toId === undefined) {\n      throw this.missingNodeError(toNode);\n    }\n    const indexOfToId = this.edgesSparseArray[fromId].indexOf(toId);\n    if (indexOfToId === -1) {\n      throw new Error('Edge does not exist');\n    }\n    delete this.edgesSparseArray[fromId][indexOfToId];\n  }\n  /**\r\n   * Removes edge between nodes if it exists.\r\n   */\n  removeEdgeIfExists(fromNode, toNode) {\n    const fromId = this.getNodeId(fromNode);\n    const toId = this.getNodeId(toNode);\n    if (fromId === undefined) {\n      return;\n    }\n    if (toId === undefined) {\n      return;\n    }\n    const indexOfToId = this.edgesSparseArray[fromId].indexOf(toId);\n    if (indexOfToId === -1) {\n      return;\n    }\n    delete this.edgesSparseArray[fromId][indexOfToId];\n  }\n  /**\r\n   * Sorts the whole graph topologically. Nodes that are on cycles are kept separate.\r\n   */\n  topSortWithScc() {\n    return this.getTopSortedWithSccSubgraphFrom(this.getNodes(), () => true, () => {});\n  }\n  /**\r\n   * Sorts the graph topologically. Nodes that are on cycles are kept separate.\r\n   *\r\n   * @param modifiedNodes - seed for computation. The algorithm assumes that only these nodes have changed since the last run.\r\n   * @param operatingFunction - recomputes value of a node, and returns whether a change occurred\r\n   * @param onCycle - action to be performed when node is on cycle\r\n   */\n  getTopSortedWithSccSubgraphFrom(modifiedNodes, operatingFunction, onCycle) {\n    const topSortAlgorithm = new TopSort(this.nodesSparseArray, this.edgesSparseArray);\n    const modifiedNodesIds = modifiedNodes.map(node => this.getNodeId(node)).filter(id => id !== undefined);\n    return topSortAlgorithm.getTopSortedWithSccSubgraphFrom(modifiedNodesIds, operatingFunction, onCycle);\n  }\n  /**\r\n   * Marks node as volatile.\r\n   */\n  markNodeAsVolatile(node) {\n    const id = this.getNodeId(node);\n    if (id === undefined) {\n      return;\n    }\n    this.dirtyAndVolatileNodeIds.rawValue.volatile.push(id);\n    this.dirtyAndVolatileNodeIds.markAsModified();\n  }\n  /**\r\n   * Marks node as dirty.\r\n   */\n  markNodeAsDirty(node) {\n    const id = this.getNodeId(node);\n    if (id === undefined) {\n      return;\n    }\n    this.dirtyAndVolatileNodeIds.rawValue.dirty.push(id);\n    this.dirtyAndVolatileNodeIds.markAsModified();\n  }\n  /**\r\n   * Returns an array of nodes that are marked as dirty and/or volatile.\r\n   */\n  getDirtyAndVolatileNodes() {\n    return this.dirtyAndVolatileNodeIds.getProcessedValue();\n  }\n  /**\r\n   * Clears dirty nodes.\r\n   */\n  clearDirtyNodes() {\n    this.dirtyAndVolatileNodeIds.rawValue.dirty = [];\n    this.dirtyAndVolatileNodeIds.markAsModified();\n  }\n  /**\r\n   * Marks node as changingWithStructure.\r\n   */\n  markNodeAsChangingWithStructure(node) {\n    const id = this.getNodeId(node);\n    if (id === undefined) {\n      return;\n    }\n    this.changingWithStructureNodeIds.push(id);\n  }\n  /**\r\n   * Marks all nodes marked as changingWithStructure as dirty.\r\n   */\n  markChangingWithStructureNodesAsDirty() {\n    if (this.changingWithStructureNodeIds.length <= 0) {\n      return;\n    }\n    this.dirtyAndVolatileNodeIds.rawValue.dirty = [...this.dirtyAndVolatileNodeIds.rawValue.dirty, ...this.changingWithStructureNodeIds];\n    this.dirtyAndVolatileNodeIds.markAsModified();\n  }\n  /**\r\n   * Marks node as infinite range.\r\n   */\n  markNodeAsInfiniteRange(node) {\n    const id = this.getNodeIdIfNotNumber(node);\n    if (id === undefined) {\n      return;\n    }\n    this.infiniteRangeIds.add(id);\n  }\n  /**\r\n   * Returns an array of nodes marked as infinite ranges\r\n   */\n  getInfiniteRanges() {\n    return [...this.infiniteRangeIds].map(id => ({\n      node: this.nodesSparseArray[id],\n      id\n    }));\n  }\n  /**\r\n   * Returns the internal id of a node.\r\n   */\n  getNodeId(node) {\n    return this.nodesIds.get(node);\n  }\n  /**\r\n   *\r\n   */\n  getNodeIdIfNotNumber(node) {\n    return typeof node === 'number' ? node : this.nodesIds.get(node);\n  }\n  /**\r\n   * Removes invalid neighbors of a given node from the edges array and returns adjacent nodes for the input node.\r\n   */\n  fixEdgesArrayForNode(id) {\n    const adjacentNodeIds = this.edgesSparseArray[id];\n    this.edgesSparseArray[id] = adjacentNodeIds.filter(adjacentId => adjacentId !== undefined && this.nodesSparseArray[adjacentId]);\n    return this.edgesSparseArray[id];\n  }\n  /**\r\n   * Removes edges from the given node to its dependencies based on the dependencyQuery function.\r\n   */\n  removeDependencies(node) {\n    const dependencies = this.dependencyQuery(node);\n    dependencies.forEach(([_, dependency]) => {\n      this.removeEdgeIfExists(dependency, node);\n    });\n    return dependencies;\n  }\n  /**\r\n   * processFn for dirtyAndVolatileNodeIds ProcessableValue instance\r\n   * @private\r\n   */\n  processDirtyAndVolatileNodeIds({\n    dirty,\n    volatile\n  }) {\n    return [...new Set([...dirty, ...volatile])].map(id => this.nodesSparseArray[id]).filter(node => node !== undefined);\n  }\n  /**\r\n   * Returns error for missing node.\r\n   */\n  missingNodeError(node) {\n    return new Error(`Unknown node ${node}`);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}