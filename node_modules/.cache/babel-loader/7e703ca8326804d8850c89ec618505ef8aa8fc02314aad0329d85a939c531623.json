{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\n/*\r\n * A class representing a set of rows in specific sheet\r\n */\nexport class RowsSpan {\n  constructor(sheet, rowStart, rowEnd) {\n    this.sheet = sheet;\n    this.rowStart = rowStart;\n    this.rowEnd = rowEnd;\n    if (rowStart < 0) {\n      throw Error('Starting row cant be less than 0');\n    }\n    if (rowEnd < rowStart) {\n      throw Error('Row span cant end before start');\n    }\n  }\n  get numberOfRows() {\n    return this.rowEnd - this.rowStart + 1;\n  }\n  get start() {\n    return this.rowStart;\n  }\n  get end() {\n    return this.rowEnd;\n  }\n  static fromNumberOfRows(sheet, rowStart, numberOfRows) {\n    return new RowsSpan(sheet, rowStart, rowStart + numberOfRows - 1);\n  }\n  static fromRowStartAndEnd(sheet, rowStart, rowEnd) {\n    return new RowsSpan(sheet, rowStart, rowEnd);\n  }\n  *rows() {\n    for (let col = this.rowStart; col <= this.rowEnd; ++col) {\n      yield col;\n    }\n  }\n  intersect(otherSpan) {\n    if (this.sheet !== otherSpan.sheet) {\n      throw Error('Can\\'t intersect spans from different sheets');\n    }\n    const start = Math.max(this.rowStart, otherSpan.rowStart);\n    const end = Math.min(this.rowEnd, otherSpan.rowEnd);\n    if (start > end) {\n      return null;\n    }\n    return new RowsSpan(this.sheet, start, end);\n  }\n  firstRow() {\n    return new RowsSpan(this.sheet, this.rowStart, this.rowStart);\n  }\n}\n/*\r\n * A class representing a set of columns in specific sheet\r\n */\nexport class ColumnsSpan {\n  constructor(sheet, columnStart, columnEnd) {\n    this.sheet = sheet;\n    this.columnStart = columnStart;\n    this.columnEnd = columnEnd;\n    if (columnStart < 0) {\n      throw Error('Starting column cant be less than 0');\n    }\n    if (columnEnd < columnStart) {\n      throw Error('Column span cant end before start');\n    }\n  }\n  get numberOfColumns() {\n    return this.columnEnd - this.columnStart + 1;\n  }\n  get start() {\n    return this.columnStart;\n  }\n  get end() {\n    return this.columnEnd;\n  }\n  static fromNumberOfColumns(sheet, columnStart, numberOfColumns) {\n    return new ColumnsSpan(sheet, columnStart, columnStart + numberOfColumns - 1);\n  }\n  static fromColumnStartAndEnd(sheet, columnStart, columnEnd) {\n    return new ColumnsSpan(sheet, columnStart, columnEnd);\n  }\n  *columns() {\n    for (let col = this.columnStart; col <= this.columnEnd; ++col) {\n      yield col;\n    }\n  }\n  intersect(otherSpan) {\n    if (this.sheet !== otherSpan.sheet) {\n      throw Error('Can\\'t intersect spans from different sheets');\n    }\n    const start = Math.max(this.columnStart, otherSpan.columnStart);\n    const end = Math.min(this.columnEnd, otherSpan.columnEnd);\n    if (start > end) {\n      return null;\n    }\n    return new ColumnsSpan(this.sheet, start, end);\n  }\n  firstColumn() {\n    return new ColumnsSpan(this.sheet, this.columnStart, this.columnStart);\n  }\n}","map":{"version":3,"names":["RowsSpan","constructor","sheet","rowStart","rowEnd","Error","numberOfRows","start","end","fromNumberOfRows","fromRowStartAndEnd","rows","col","intersect","otherSpan","Math","max","min","firstRow","ColumnsSpan","columnStart","columnEnd","numberOfColumns","fromNumberOfColumns","fromColumnStartAndEnd","columns","firstColumn"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/Span.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\n/*\r\n * A class representing a set of rows in specific sheet\r\n */\nexport class RowsSpan {\n  constructor(sheet, rowStart, rowEnd) {\n    this.sheet = sheet;\n    this.rowStart = rowStart;\n    this.rowEnd = rowEnd;\n    if (rowStart < 0) {\n      throw Error('Starting row cant be less than 0');\n    }\n    if (rowEnd < rowStart) {\n      throw Error('Row span cant end before start');\n    }\n  }\n  get numberOfRows() {\n    return this.rowEnd - this.rowStart + 1;\n  }\n  get start() {\n    return this.rowStart;\n  }\n  get end() {\n    return this.rowEnd;\n  }\n  static fromNumberOfRows(sheet, rowStart, numberOfRows) {\n    return new RowsSpan(sheet, rowStart, rowStart + numberOfRows - 1);\n  }\n  static fromRowStartAndEnd(sheet, rowStart, rowEnd) {\n    return new RowsSpan(sheet, rowStart, rowEnd);\n  }\n  *rows() {\n    for (let col = this.rowStart; col <= this.rowEnd; ++col) {\n      yield col;\n    }\n  }\n  intersect(otherSpan) {\n    if (this.sheet !== otherSpan.sheet) {\n      throw Error('Can\\'t intersect spans from different sheets');\n    }\n    const start = Math.max(this.rowStart, otherSpan.rowStart);\n    const end = Math.min(this.rowEnd, otherSpan.rowEnd);\n    if (start > end) {\n      return null;\n    }\n    return new RowsSpan(this.sheet, start, end);\n  }\n  firstRow() {\n    return new RowsSpan(this.sheet, this.rowStart, this.rowStart);\n  }\n}\n/*\r\n * A class representing a set of columns in specific sheet\r\n */\nexport class ColumnsSpan {\n  constructor(sheet, columnStart, columnEnd) {\n    this.sheet = sheet;\n    this.columnStart = columnStart;\n    this.columnEnd = columnEnd;\n    if (columnStart < 0) {\n      throw Error('Starting column cant be less than 0');\n    }\n    if (columnEnd < columnStart) {\n      throw Error('Column span cant end before start');\n    }\n  }\n  get numberOfColumns() {\n    return this.columnEnd - this.columnStart + 1;\n  }\n  get start() {\n    return this.columnStart;\n  }\n  get end() {\n    return this.columnEnd;\n  }\n  static fromNumberOfColumns(sheet, columnStart, numberOfColumns) {\n    return new ColumnsSpan(sheet, columnStart, columnStart + numberOfColumns - 1);\n  }\n  static fromColumnStartAndEnd(sheet, columnStart, columnEnd) {\n    return new ColumnsSpan(sheet, columnStart, columnEnd);\n  }\n  *columns() {\n    for (let col = this.columnStart; col <= this.columnEnd; ++col) {\n      yield col;\n    }\n  }\n  intersect(otherSpan) {\n    if (this.sheet !== otherSpan.sheet) {\n      throw Error('Can\\'t intersect spans from different sheets');\n    }\n    const start = Math.max(this.columnStart, otherSpan.columnStart);\n    const end = Math.min(this.columnEnd, otherSpan.columnEnd);\n    if (start > end) {\n      return null;\n    }\n    return new ColumnsSpan(this.sheet, start, end);\n  }\n  firstColumn() {\n    return new ColumnsSpan(this.sheet, this.columnStart, this.columnStart);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}