{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { absoluteSheetReference, invalidSimpleRowAddress, simpleRowAddress } from \"../Cell.mjs\";\nimport { ReferenceType } from \"./ColumnAddress.mjs\";\nexport class RowAddress {\n  constructor(type, row, sheet) {\n    this.type = type;\n    this.row = row;\n    this.sheet = sheet;\n  }\n  static absolute(row, sheet) {\n    return new RowAddress(ReferenceType.ABSOLUTE, row, sheet);\n  }\n  static relative(row, sheet) {\n    return new RowAddress(ReferenceType.RELATIVE, row, sheet);\n  }\n  static compareByAbsoluteAddress(baseAddress) {\n    return (rowA, rowB) => rowA.toSimpleRowAddress(baseAddress).row - rowB.toSimpleRowAddress(baseAddress).row;\n  }\n  isRowAbsolute() {\n    return this.type === ReferenceType.ABSOLUTE;\n  }\n  isRowRelative() {\n    return this.type === ReferenceType.RELATIVE;\n  }\n  isAbsolute() {\n    return this.type === ReferenceType.ABSOLUTE && this.sheet !== undefined;\n  }\n  moved(toSheet, toRight, toBottom) {\n    const newSheet = this.sheet === undefined ? undefined : toSheet;\n    return new RowAddress(this.type, this.row + toBottom, newSheet);\n  }\n  shiftedByRows(numberOfColumns) {\n    return new RowAddress(this.type, this.row + numberOfColumns, this.sheet);\n  }\n  toSimpleRowAddress(baseAddress) {\n    const sheet = absoluteSheetReference(this, baseAddress);\n    let row = this.row;\n    if (this.isRowRelative()) {\n      row = baseAddress.row + this.row;\n    }\n    return simpleRowAddress(sheet, row);\n  }\n  shiftRelativeDimensions(toRight, toBottom) {\n    const row = this.isRowRelative() ? this.row + toBottom : this.row;\n    return new RowAddress(this.type, row, this.sheet);\n  }\n  shiftAbsoluteDimensions(toRight, toBottom) {\n    const row = this.isRowAbsolute() ? this.row + toBottom : this.row;\n    return new RowAddress(this.type, row, this.sheet);\n  }\n  withSheet(sheet) {\n    return new RowAddress(this.type, this.row, sheet);\n  }\n  isInvalid(baseAddress) {\n    return this.toSimpleRowAddress(baseAddress).row < 0;\n  }\n  hash(withSheet) {\n    const sheetPart = withSheet && this.sheet !== undefined ? `#${this.sheet}` : '';\n    switch (this.type) {\n      case ReferenceType.RELATIVE:\n        {\n          return `${sheetPart}#ROWR${this.row}`;\n        }\n      case ReferenceType.ABSOLUTE:\n        {\n          return `${sheetPart}#ROWA${this.row}`;\n        }\n    }\n  }\n  unparse(baseAddress) {\n    const simpleAddress = this.toSimpleRowAddress(baseAddress);\n    if (invalidSimpleRowAddress(simpleAddress)) {\n      return undefined;\n    }\n    const dollar = this.type === ReferenceType.ABSOLUTE ? '$' : '';\n    return `${dollar}${simpleAddress.row + 1}`;\n  }\n  exceedsSheetSizeLimits(maxRows) {\n    return this.row >= maxRows;\n  }\n}","map":{"version":3,"names":["absoluteSheetReference","invalidSimpleRowAddress","simpleRowAddress","ReferenceType","RowAddress","constructor","type","row","sheet","absolute","ABSOLUTE","relative","RELATIVE","compareByAbsoluteAddress","baseAddress","rowA","rowB","toSimpleRowAddress","isRowAbsolute","isRowRelative","isAbsolute","undefined","moved","toSheet","toRight","toBottom","newSheet","shiftedByRows","numberOfColumns","shiftRelativeDimensions","shiftAbsoluteDimensions","withSheet","isInvalid","hash","sheetPart","unparse","simpleAddress","dollar","exceedsSheetSizeLimits","maxRows"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/parser/RowAddress.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { absoluteSheetReference, invalidSimpleRowAddress, simpleRowAddress } from \"../Cell.mjs\";\nimport { ReferenceType } from \"./ColumnAddress.mjs\";\nexport class RowAddress {\n  constructor(type, row, sheet) {\n    this.type = type;\n    this.row = row;\n    this.sheet = sheet;\n  }\n  static absolute(row, sheet) {\n    return new RowAddress(ReferenceType.ABSOLUTE, row, sheet);\n  }\n  static relative(row, sheet) {\n    return new RowAddress(ReferenceType.RELATIVE, row, sheet);\n  }\n  static compareByAbsoluteAddress(baseAddress) {\n    return (rowA, rowB) => rowA.toSimpleRowAddress(baseAddress).row - rowB.toSimpleRowAddress(baseAddress).row;\n  }\n  isRowAbsolute() {\n    return this.type === ReferenceType.ABSOLUTE;\n  }\n  isRowRelative() {\n    return this.type === ReferenceType.RELATIVE;\n  }\n  isAbsolute() {\n    return this.type === ReferenceType.ABSOLUTE && this.sheet !== undefined;\n  }\n  moved(toSheet, toRight, toBottom) {\n    const newSheet = this.sheet === undefined ? undefined : toSheet;\n    return new RowAddress(this.type, this.row + toBottom, newSheet);\n  }\n  shiftedByRows(numberOfColumns) {\n    return new RowAddress(this.type, this.row + numberOfColumns, this.sheet);\n  }\n  toSimpleRowAddress(baseAddress) {\n    const sheet = absoluteSheetReference(this, baseAddress);\n    let row = this.row;\n    if (this.isRowRelative()) {\n      row = baseAddress.row + this.row;\n    }\n    return simpleRowAddress(sheet, row);\n  }\n  shiftRelativeDimensions(toRight, toBottom) {\n    const row = this.isRowRelative() ? this.row + toBottom : this.row;\n    return new RowAddress(this.type, row, this.sheet);\n  }\n  shiftAbsoluteDimensions(toRight, toBottom) {\n    const row = this.isRowAbsolute() ? this.row + toBottom : this.row;\n    return new RowAddress(this.type, row, this.sheet);\n  }\n  withSheet(sheet) {\n    return new RowAddress(this.type, this.row, sheet);\n  }\n  isInvalid(baseAddress) {\n    return this.toSimpleRowAddress(baseAddress).row < 0;\n  }\n  hash(withSheet) {\n    const sheetPart = withSheet && this.sheet !== undefined ? `#${this.sheet}` : '';\n    switch (this.type) {\n      case ReferenceType.RELATIVE:\n        {\n          return `${sheetPart}#ROWR${this.row}`;\n        }\n      case ReferenceType.ABSOLUTE:\n        {\n          return `${sheetPart}#ROWA${this.row}`;\n        }\n    }\n  }\n  unparse(baseAddress) {\n    const simpleAddress = this.toSimpleRowAddress(baseAddress);\n    if (invalidSimpleRowAddress(simpleAddress)) {\n      return undefined;\n    }\n    const dollar = this.type === ReferenceType.ABSOLUTE ? '$' : '';\n    return `${dollar}${simpleAddress.row + 1}`;\n  }\n  exceedsSheetSizeLimits(maxRows) {\n    return this.row >= maxRows;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}