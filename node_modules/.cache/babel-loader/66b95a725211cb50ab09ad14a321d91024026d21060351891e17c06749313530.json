{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { createToken, Lexer } from 'chevrotain';\nimport { ALL_WHITESPACE_PATTERN, COLUMN_REFERENCE_PATTERN, NON_RESERVED_CHARACTER_PATTERN, ODFF_WHITESPACE_PATTERN, RANGE_OPERATOR, ROW_REFERENCE_PATTERN, UNICODE_LETTER_PATTERN } from \"./parser-consts.mjs\";\nimport { CellReferenceMatcher } from \"./CellReferenceMatcher.mjs\";\nimport { NamedExpressionMatcher } from \"./NamedExpressionMatcher.mjs\";\nexport const AdditionOp = createToken({\n  name: 'AdditionOp',\n  pattern: Lexer.NA\n});\nexport const PlusOp = createToken({\n  name: 'PlusOp',\n  pattern: /\\+/,\n  categories: AdditionOp\n});\nexport const MinusOp = createToken({\n  name: 'MinusOp',\n  pattern: /-/,\n  categories: AdditionOp\n});\nexport const MultiplicationOp = createToken({\n  name: 'MultiplicationOp',\n  pattern: Lexer.NA\n});\nexport const TimesOp = createToken({\n  name: 'TimesOp',\n  pattern: /\\*/,\n  categories: MultiplicationOp\n});\nexport const DivOp = createToken({\n  name: 'DivOp',\n  pattern: /\\//,\n  categories: MultiplicationOp\n});\nexport const PowerOp = createToken({\n  name: 'PowerOp',\n  pattern: /\\^/\n});\nexport const PercentOp = createToken({\n  name: 'PercentOp',\n  pattern: /%/\n});\nexport const BooleanOp = createToken({\n  name: 'BooleanOp',\n  pattern: Lexer.NA\n});\nexport const EqualsOp = createToken({\n  name: 'EqualsOp',\n  pattern: /=/,\n  categories: BooleanOp\n});\nexport const NotEqualOp = createToken({\n  name: 'NotEqualOp',\n  pattern: /<>/,\n  categories: BooleanOp\n});\nexport const GreaterThanOp = createToken({\n  name: 'GreaterThanOp',\n  pattern: />/,\n  categories: BooleanOp\n});\nexport const LessThanOp = createToken({\n  name: 'LessThanOp',\n  pattern: /</,\n  categories: BooleanOp\n});\nexport const GreaterThanOrEqualOp = createToken({\n  name: 'GreaterThanOrEqualOp',\n  pattern: />=/,\n  categories: BooleanOp\n});\nexport const LessThanOrEqualOp = createToken({\n  name: 'LessThanOrEqualOp',\n  pattern: /<=/,\n  categories: BooleanOp\n});\nexport const ConcatenateOp = createToken({\n  name: 'ConcatenateOp',\n  pattern: /&/\n});\nexport const LParen = createToken({\n  name: 'LParen',\n  pattern: /\\(/\n});\nexport const RParen = createToken({\n  name: 'RParen',\n  pattern: /\\)/\n});\nexport const ArrayLParen = createToken({\n  name: 'ArrayLParen',\n  pattern: /{/\n});\nexport const ArrayRParen = createToken({\n  name: 'ArrayRParen',\n  pattern: /}/\n});\nexport const StringLiteral = createToken({\n  name: 'StringLiteral',\n  pattern: /\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"/\n});\nexport const ErrorLiteral = createToken({\n  name: 'ErrorLiteral',\n  pattern: /#[A-Za-z0-9\\/]+[?!]?/\n});\nexport const RangeSeparator = createToken({\n  name: 'RangeSeparator',\n  pattern: new RegExp(RANGE_OPERATOR)\n});\nexport const ColumnRange = createToken({\n  name: 'ColumnRange',\n  pattern: new RegExp(`${COLUMN_REFERENCE_PATTERN}${RANGE_OPERATOR}${COLUMN_REFERENCE_PATTERN}`)\n});\nexport const RowRange = createToken({\n  name: 'RowRange',\n  pattern: new RegExp(`${ROW_REFERENCE_PATTERN}${RANGE_OPERATOR}${ROW_REFERENCE_PATTERN}`)\n});\nexport const ProcedureName = createToken({\n  name: 'ProcedureName',\n  pattern: new RegExp(`([${UNICODE_LETTER_PATTERN}][${NON_RESERVED_CHARACTER_PATTERN}]*)\\\\(`)\n});\nconst cellReferenceMatcher = new CellReferenceMatcher();\nexport const CellReference = createToken({\n  name: 'CellReference',\n  pattern: cellReferenceMatcher.match.bind(cellReferenceMatcher),\n  start_chars_hint: cellReferenceMatcher.POSSIBLE_START_CHARACTERS,\n  line_breaks: false\n});\nconst namedExpressionMatcher = new NamedExpressionMatcher();\nexport const NamedExpression = createToken({\n  name: 'NamedExpression',\n  pattern: namedExpressionMatcher.match.bind(namedExpressionMatcher),\n  start_chars_hint: namedExpressionMatcher.POSSIBLE_START_CHARACTERS,\n  line_breaks: false\n});\n/**\r\n * Builds the configuration object for the lexer\r\n */\nexport const buildLexerConfig = config => {\n  const offsetProcedureNameLiteral = config.translationPackage.getFunctionTranslation('OFFSET');\n  const errorMapping = config.errorMapping;\n  const functionMapping = config.translationPackage.buildFunctionMapping();\n  const whitespaceTokenRegexp = new RegExp(config.ignoreWhiteSpace === 'standard' ? ODFF_WHITESPACE_PATTERN : ALL_WHITESPACE_PATTERN);\n  const WhiteSpace = createToken({\n    name: 'WhiteSpace',\n    pattern: whitespaceTokenRegexp\n  });\n  const ArrayRowSeparator = createToken({\n    name: 'ArrayRowSep',\n    pattern: config.arrayRowSeparator\n  });\n  const ArrayColSeparator = createToken({\n    name: 'ArrayColSep',\n    pattern: config.arrayColumnSeparator\n  });\n  const NumberLiteral = createToken({\n    name: 'NumberLiteral',\n    pattern: new RegExp(`(([${config.decimalSeparator}]\\\\d+)|(\\\\d+([${config.decimalSeparator}]\\\\d*)?))(e[+-]?\\\\d+)?`)\n  });\n  const OffsetProcedureName = createToken({\n    name: 'OffsetProcedureName',\n    pattern: new RegExp(offsetProcedureNameLiteral, 'i')\n  });\n  let ArgSeparator;\n  let inject;\n  if (config.functionArgSeparator === config.arrayColumnSeparator) {\n    ArgSeparator = ArrayColSeparator;\n    inject = [];\n  } else if (config.functionArgSeparator === config.arrayRowSeparator) {\n    ArgSeparator = ArrayRowSeparator;\n    inject = [];\n  } else {\n    ArgSeparator = createToken({\n      name: 'ArgSeparator',\n      pattern: config.functionArgSeparator\n    });\n    inject = [ArgSeparator];\n  }\n  /* order is important, first pattern is used */\n  const allTokens = [WhiteSpace, PlusOp, MinusOp, TimesOp, DivOp, PowerOp, EqualsOp, NotEqualOp, PercentOp, GreaterThanOrEqualOp, LessThanOrEqualOp, GreaterThanOp, LessThanOp, LParen, RParen, ArrayLParen, ArrayRParen, OffsetProcedureName, ProcedureName, RangeSeparator, ...inject, ColumnRange, RowRange, NumberLiteral, StringLiteral, ErrorLiteral, ConcatenateOp, BooleanOp, AdditionOp, MultiplicationOp, CellReference, NamedExpression, ArrayRowSeparator, ArrayColSeparator];\n  return {\n    ArgSeparator,\n    NumberLiteral,\n    OffsetProcedureName,\n    ArrayRowSeparator,\n    ArrayColSeparator,\n    WhiteSpace,\n    allTokens,\n    errorMapping,\n    functionMapping,\n    decimalSeparator: config.decimalSeparator,\n    maxColumns: config.maxColumns,\n    maxRows: config.maxRows\n  };\n};","map":{"version":3,"names":["createToken","Lexer","ALL_WHITESPACE_PATTERN","COLUMN_REFERENCE_PATTERN","NON_RESERVED_CHARACTER_PATTERN","ODFF_WHITESPACE_PATTERN","RANGE_OPERATOR","ROW_REFERENCE_PATTERN","UNICODE_LETTER_PATTERN","CellReferenceMatcher","NamedExpressionMatcher","AdditionOp","name","pattern","NA","PlusOp","categories","MinusOp","MultiplicationOp","TimesOp","DivOp","PowerOp","PercentOp","BooleanOp","EqualsOp","NotEqualOp","GreaterThanOp","LessThanOp","GreaterThanOrEqualOp","LessThanOrEqualOp","ConcatenateOp","LParen","RParen","ArrayLParen","ArrayRParen","StringLiteral","ErrorLiteral","RangeSeparator","RegExp","ColumnRange","RowRange","ProcedureName","cellReferenceMatcher","CellReference","match","bind","start_chars_hint","POSSIBLE_START_CHARACTERS","line_breaks","namedExpressionMatcher","NamedExpression","buildLexerConfig","config","offsetProcedureNameLiteral","translationPackage","getFunctionTranslation","errorMapping","functionMapping","buildFunctionMapping","whitespaceTokenRegexp","ignoreWhiteSpace","WhiteSpace","ArrayRowSeparator","arrayRowSeparator","ArrayColSeparator","arrayColumnSeparator","NumberLiteral","decimalSeparator","OffsetProcedureName","ArgSeparator","inject","functionArgSeparator","allTokens","maxColumns","maxRows"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/parser/LexerConfig.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { createToken, Lexer } from 'chevrotain';\nimport { ALL_WHITESPACE_PATTERN, COLUMN_REFERENCE_PATTERN, NON_RESERVED_CHARACTER_PATTERN, ODFF_WHITESPACE_PATTERN, RANGE_OPERATOR, ROW_REFERENCE_PATTERN, UNICODE_LETTER_PATTERN } from \"./parser-consts.mjs\";\nimport { CellReferenceMatcher } from \"./CellReferenceMatcher.mjs\";\nimport { NamedExpressionMatcher } from \"./NamedExpressionMatcher.mjs\";\nexport const AdditionOp = createToken({\n  name: 'AdditionOp',\n  pattern: Lexer.NA\n});\nexport const PlusOp = createToken({\n  name: 'PlusOp',\n  pattern: /\\+/,\n  categories: AdditionOp\n});\nexport const MinusOp = createToken({\n  name: 'MinusOp',\n  pattern: /-/,\n  categories: AdditionOp\n});\nexport const MultiplicationOp = createToken({\n  name: 'MultiplicationOp',\n  pattern: Lexer.NA\n});\nexport const TimesOp = createToken({\n  name: 'TimesOp',\n  pattern: /\\*/,\n  categories: MultiplicationOp\n});\nexport const DivOp = createToken({\n  name: 'DivOp',\n  pattern: /\\//,\n  categories: MultiplicationOp\n});\nexport const PowerOp = createToken({\n  name: 'PowerOp',\n  pattern: /\\^/\n});\nexport const PercentOp = createToken({\n  name: 'PercentOp',\n  pattern: /%/\n});\nexport const BooleanOp = createToken({\n  name: 'BooleanOp',\n  pattern: Lexer.NA\n});\nexport const EqualsOp = createToken({\n  name: 'EqualsOp',\n  pattern: /=/,\n  categories: BooleanOp\n});\nexport const NotEqualOp = createToken({\n  name: 'NotEqualOp',\n  pattern: /<>/,\n  categories: BooleanOp\n});\nexport const GreaterThanOp = createToken({\n  name: 'GreaterThanOp',\n  pattern: />/,\n  categories: BooleanOp\n});\nexport const LessThanOp = createToken({\n  name: 'LessThanOp',\n  pattern: /</,\n  categories: BooleanOp\n});\nexport const GreaterThanOrEqualOp = createToken({\n  name: 'GreaterThanOrEqualOp',\n  pattern: />=/,\n  categories: BooleanOp\n});\nexport const LessThanOrEqualOp = createToken({\n  name: 'LessThanOrEqualOp',\n  pattern: /<=/,\n  categories: BooleanOp\n});\nexport const ConcatenateOp = createToken({\n  name: 'ConcatenateOp',\n  pattern: /&/\n});\nexport const LParen = createToken({\n  name: 'LParen',\n  pattern: /\\(/\n});\nexport const RParen = createToken({\n  name: 'RParen',\n  pattern: /\\)/\n});\nexport const ArrayLParen = createToken({\n  name: 'ArrayLParen',\n  pattern: /{/\n});\nexport const ArrayRParen = createToken({\n  name: 'ArrayRParen',\n  pattern: /}/\n});\nexport const StringLiteral = createToken({\n  name: 'StringLiteral',\n  pattern: /\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"/\n});\nexport const ErrorLiteral = createToken({\n  name: 'ErrorLiteral',\n  pattern: /#[A-Za-z0-9\\/]+[?!]?/\n});\nexport const RangeSeparator = createToken({\n  name: 'RangeSeparator',\n  pattern: new RegExp(RANGE_OPERATOR)\n});\nexport const ColumnRange = createToken({\n  name: 'ColumnRange',\n  pattern: new RegExp(`${COLUMN_REFERENCE_PATTERN}${RANGE_OPERATOR}${COLUMN_REFERENCE_PATTERN}`)\n});\nexport const RowRange = createToken({\n  name: 'RowRange',\n  pattern: new RegExp(`${ROW_REFERENCE_PATTERN}${RANGE_OPERATOR}${ROW_REFERENCE_PATTERN}`)\n});\nexport const ProcedureName = createToken({\n  name: 'ProcedureName',\n  pattern: new RegExp(`([${UNICODE_LETTER_PATTERN}][${NON_RESERVED_CHARACTER_PATTERN}]*)\\\\(`)\n});\nconst cellReferenceMatcher = new CellReferenceMatcher();\nexport const CellReference = createToken({\n  name: 'CellReference',\n  pattern: cellReferenceMatcher.match.bind(cellReferenceMatcher),\n  start_chars_hint: cellReferenceMatcher.POSSIBLE_START_CHARACTERS,\n  line_breaks: false\n});\nconst namedExpressionMatcher = new NamedExpressionMatcher();\nexport const NamedExpression = createToken({\n  name: 'NamedExpression',\n  pattern: namedExpressionMatcher.match.bind(namedExpressionMatcher),\n  start_chars_hint: namedExpressionMatcher.POSSIBLE_START_CHARACTERS,\n  line_breaks: false\n});\n/**\r\n * Builds the configuration object for the lexer\r\n */\nexport const buildLexerConfig = config => {\n  const offsetProcedureNameLiteral = config.translationPackage.getFunctionTranslation('OFFSET');\n  const errorMapping = config.errorMapping;\n  const functionMapping = config.translationPackage.buildFunctionMapping();\n  const whitespaceTokenRegexp = new RegExp(config.ignoreWhiteSpace === 'standard' ? ODFF_WHITESPACE_PATTERN : ALL_WHITESPACE_PATTERN);\n  const WhiteSpace = createToken({\n    name: 'WhiteSpace',\n    pattern: whitespaceTokenRegexp\n  });\n  const ArrayRowSeparator = createToken({\n    name: 'ArrayRowSep',\n    pattern: config.arrayRowSeparator\n  });\n  const ArrayColSeparator = createToken({\n    name: 'ArrayColSep',\n    pattern: config.arrayColumnSeparator\n  });\n  const NumberLiteral = createToken({\n    name: 'NumberLiteral',\n    pattern: new RegExp(`(([${config.decimalSeparator}]\\\\d+)|(\\\\d+([${config.decimalSeparator}]\\\\d*)?))(e[+-]?\\\\d+)?`)\n  });\n  const OffsetProcedureName = createToken({\n    name: 'OffsetProcedureName',\n    pattern: new RegExp(offsetProcedureNameLiteral, 'i')\n  });\n  let ArgSeparator;\n  let inject;\n  if (config.functionArgSeparator === config.arrayColumnSeparator) {\n    ArgSeparator = ArrayColSeparator;\n    inject = [];\n  } else if (config.functionArgSeparator === config.arrayRowSeparator) {\n    ArgSeparator = ArrayRowSeparator;\n    inject = [];\n  } else {\n    ArgSeparator = createToken({\n      name: 'ArgSeparator',\n      pattern: config.functionArgSeparator\n    });\n    inject = [ArgSeparator];\n  }\n  /* order is important, first pattern is used */\n  const allTokens = [WhiteSpace, PlusOp, MinusOp, TimesOp, DivOp, PowerOp, EqualsOp, NotEqualOp, PercentOp, GreaterThanOrEqualOp, LessThanOrEqualOp, GreaterThanOp, LessThanOp, LParen, RParen, ArrayLParen, ArrayRParen, OffsetProcedureName, ProcedureName, RangeSeparator, ...inject, ColumnRange, RowRange, NumberLiteral, StringLiteral, ErrorLiteral, ConcatenateOp, BooleanOp, AdditionOp, MultiplicationOp, CellReference, NamedExpression, ArrayRowSeparator, ArrayColSeparator];\n  return {\n    ArgSeparator,\n    NumberLiteral,\n    OffsetProcedureName,\n    ArrayRowSeparator,\n    ArrayColSeparator,\n    WhiteSpace,\n    allTokens,\n    errorMapping,\n    functionMapping,\n    decimalSeparator: config.decimalSeparator,\n    maxColumns: config.maxColumns,\n    maxRows: config.maxRows\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}