{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { simpleCellAddress } from \"./Cell.mjs\";\nimport { ArrayVertex, FormulaCellVertex, ParsingErrorVertex } from \"./DependencyGraph/index.mjs\";\nimport { buildLexerConfig, Unparser } from \"./parser/index.mjs\";\nexport class Serialization {\n  constructor(dependencyGraph, unparser, exporter) {\n    this.dependencyGraph = dependencyGraph;\n    this.unparser = unparser;\n    this.exporter = exporter;\n  }\n  getCellHyperlink(address) {\n    const formulaVertex = this.dependencyGraph.getCell(address);\n    if (formulaVertex instanceof FormulaCellVertex) {\n      const formula = formulaVertex.getFormula(this.dependencyGraph.lazilyTransformingAstService);\n      if ('HYPERLINK' === formula.procedureName) {\n        return formula.hyperlink;\n      }\n    }\n    return undefined;\n  }\n  getCellFormula(address, targetAddress) {\n    const formulaVertex = this.dependencyGraph.getCell(address);\n    if (formulaVertex instanceof FormulaCellVertex) {\n      const formula = formulaVertex.getFormula(this.dependencyGraph.lazilyTransformingAstService);\n      targetAddress = targetAddress !== null && targetAddress !== void 0 ? targetAddress : address;\n      return this.unparser.unparse(formula, targetAddress);\n    } else if (formulaVertex instanceof ArrayVertex) {\n      const arrayVertexAddress = formulaVertex.getAddress(this.dependencyGraph.lazilyTransformingAstService);\n      if (arrayVertexAddress.row !== address.row || arrayVertexAddress.col !== address.col || arrayVertexAddress.sheet !== address.sheet) {\n        return undefined;\n      }\n      targetAddress = targetAddress !== null && targetAddress !== void 0 ? targetAddress : address;\n      const formula = formulaVertex.getFormula(this.dependencyGraph.lazilyTransformingAstService);\n      if (formula !== undefined) {\n        return this.unparser.unparse(formula, targetAddress);\n      }\n    } else if (formulaVertex instanceof ParsingErrorVertex) {\n      return formulaVertex.getFormula();\n    }\n    return undefined;\n  }\n  getCellSerialized(address, targetAddress) {\n    var _a;\n    return (_a = this.getCellFormula(address, targetAddress)) !== null && _a !== void 0 ? _a : this.getRawValue(address);\n  }\n  getCellValue(address) {\n    return this.exporter.exportValue(this.dependencyGraph.getScalarValue(address));\n  }\n  getRawValue(address) {\n    return this.dependencyGraph.getRawValue(address);\n  }\n  getSheetValues(sheet) {\n    return this.genericSheetGetter(sheet, arg => this.getCellValue(arg));\n  }\n  getSheetFormulas(sheet) {\n    return this.genericSheetGetter(sheet, arg => this.getCellFormula(arg));\n  }\n  genericSheetGetter(sheet, getter) {\n    const sheetHeight = this.dependencyGraph.getSheetHeight(sheet);\n    const sheetWidth = this.dependencyGraph.getSheetWidth(sheet);\n    const arr = new Array(sheetHeight);\n    for (let i = 0; i < sheetHeight; i++) {\n      arr[i] = new Array(sheetWidth);\n      for (let j = 0; j < sheetWidth; j++) {\n        const address = simpleCellAddress(sheet, j, i);\n        arr[i][j] = getter(address);\n      }\n      for (let j = sheetWidth - 1; j >= 0; j--) {\n        if (arr[i][j] === null || arr[i][j] === undefined) {\n          arr[i].pop();\n        } else {\n          break;\n        }\n      }\n    }\n    for (let i = sheetHeight - 1; i >= 0; i--) {\n      if (arr[i].length === 0) {\n        arr.pop();\n      } else {\n        break;\n      }\n    }\n    return arr;\n  }\n  genericAllSheetsGetter(sheetGetter) {\n    const result = {};\n    for (const sheetName of this.dependencyGraph.sheetMapping.displayNames()) {\n      const sheetId = this.dependencyGraph.sheetMapping.fetch(sheetName);\n      result[sheetName] = sheetGetter(sheetId);\n    }\n    return result;\n  }\n  getSheetSerialized(sheet) {\n    return this.genericSheetGetter(sheet, arg => this.getCellSerialized(arg));\n  }\n  getAllSheetsValues() {\n    return this.genericAllSheetsGetter(arg => this.getSheetValues(arg));\n  }\n  getAllSheetsFormulas() {\n    return this.genericAllSheetsGetter(arg => this.getSheetFormulas(arg));\n  }\n  getAllSheetsSerialized() {\n    return this.genericAllSheetsGetter(arg => this.getSheetSerialized(arg));\n  }\n  getAllNamedExpressionsSerialized() {\n    const idMap = [];\n    let id = 0;\n    for (const sheetName of this.dependencyGraph.sheetMapping.displayNames()) {\n      const sheetId = this.dependencyGraph.sheetMapping.fetch(sheetName);\n      idMap[sheetId] = id;\n      id++;\n    }\n    return this.dependencyGraph.namedExpressions.getAllNamedExpressions().map(entry => {\n      return {\n        name: entry.expression.displayName,\n        expression: this.getCellSerialized(entry.expression.address),\n        scope: entry.scope !== undefined ? idMap[entry.scope] : undefined,\n        options: entry.expression.options\n      };\n    });\n  }\n  withNewConfig(newConfig, namedExpressions) {\n    const newUnparser = new Unparser(newConfig, buildLexerConfig(newConfig), this.dependencyGraph.sheetMapping.fetchDisplayName, namedExpressions);\n    return new Serialization(this.dependencyGraph, newUnparser, this.exporter);\n  }\n}","map":{"version":3,"names":["simpleCellAddress","ArrayVertex","FormulaCellVertex","ParsingErrorVertex","buildLexerConfig","Unparser","Serialization","constructor","dependencyGraph","unparser","exporter","getCellHyperlink","address","formulaVertex","getCell","formula","getFormula","lazilyTransformingAstService","procedureName","hyperlink","undefined","getCellFormula","targetAddress","unparse","arrayVertexAddress","getAddress","row","col","sheet","getCellSerialized","_a","getRawValue","getCellValue","exportValue","getScalarValue","getSheetValues","genericSheetGetter","arg","getSheetFormulas","getter","sheetHeight","getSheetHeight","sheetWidth","getSheetWidth","arr","Array","i","j","pop","length","genericAllSheetsGetter","sheetGetter","result","sheetName","sheetMapping","displayNames","sheetId","fetch","getSheetSerialized","getAllSheetsValues","getAllSheetsFormulas","getAllSheetsSerialized","getAllNamedExpressionsSerialized","idMap","id","namedExpressions","getAllNamedExpressions","map","entry","name","expression","displayName","scope","options","withNewConfig","newConfig","newUnparser","fetchDisplayName"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/Serialization.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { simpleCellAddress } from \"./Cell.mjs\";\nimport { ArrayVertex, FormulaCellVertex, ParsingErrorVertex } from \"./DependencyGraph/index.mjs\";\nimport { buildLexerConfig, Unparser } from \"./parser/index.mjs\";\nexport class Serialization {\n  constructor(dependencyGraph, unparser, exporter) {\n    this.dependencyGraph = dependencyGraph;\n    this.unparser = unparser;\n    this.exporter = exporter;\n  }\n  getCellHyperlink(address) {\n    const formulaVertex = this.dependencyGraph.getCell(address);\n    if (formulaVertex instanceof FormulaCellVertex) {\n      const formula = formulaVertex.getFormula(this.dependencyGraph.lazilyTransformingAstService);\n      if ('HYPERLINK' === formula.procedureName) {\n        return formula.hyperlink;\n      }\n    }\n    return undefined;\n  }\n  getCellFormula(address, targetAddress) {\n    const formulaVertex = this.dependencyGraph.getCell(address);\n    if (formulaVertex instanceof FormulaCellVertex) {\n      const formula = formulaVertex.getFormula(this.dependencyGraph.lazilyTransformingAstService);\n      targetAddress = targetAddress !== null && targetAddress !== void 0 ? targetAddress : address;\n      return this.unparser.unparse(formula, targetAddress);\n    } else if (formulaVertex instanceof ArrayVertex) {\n      const arrayVertexAddress = formulaVertex.getAddress(this.dependencyGraph.lazilyTransformingAstService);\n      if (arrayVertexAddress.row !== address.row || arrayVertexAddress.col !== address.col || arrayVertexAddress.sheet !== address.sheet) {\n        return undefined;\n      }\n      targetAddress = targetAddress !== null && targetAddress !== void 0 ? targetAddress : address;\n      const formula = formulaVertex.getFormula(this.dependencyGraph.lazilyTransformingAstService);\n      if (formula !== undefined) {\n        return this.unparser.unparse(formula, targetAddress);\n      }\n    } else if (formulaVertex instanceof ParsingErrorVertex) {\n      return formulaVertex.getFormula();\n    }\n    return undefined;\n  }\n  getCellSerialized(address, targetAddress) {\n    var _a;\n    return (_a = this.getCellFormula(address, targetAddress)) !== null && _a !== void 0 ? _a : this.getRawValue(address);\n  }\n  getCellValue(address) {\n    return this.exporter.exportValue(this.dependencyGraph.getScalarValue(address));\n  }\n  getRawValue(address) {\n    return this.dependencyGraph.getRawValue(address);\n  }\n  getSheetValues(sheet) {\n    return this.genericSheetGetter(sheet, arg => this.getCellValue(arg));\n  }\n  getSheetFormulas(sheet) {\n    return this.genericSheetGetter(sheet, arg => this.getCellFormula(arg));\n  }\n  genericSheetGetter(sheet, getter) {\n    const sheetHeight = this.dependencyGraph.getSheetHeight(sheet);\n    const sheetWidth = this.dependencyGraph.getSheetWidth(sheet);\n    const arr = new Array(sheetHeight);\n    for (let i = 0; i < sheetHeight; i++) {\n      arr[i] = new Array(sheetWidth);\n      for (let j = 0; j < sheetWidth; j++) {\n        const address = simpleCellAddress(sheet, j, i);\n        arr[i][j] = getter(address);\n      }\n      for (let j = sheetWidth - 1; j >= 0; j--) {\n        if (arr[i][j] === null || arr[i][j] === undefined) {\n          arr[i].pop();\n        } else {\n          break;\n        }\n      }\n    }\n    for (let i = sheetHeight - 1; i >= 0; i--) {\n      if (arr[i].length === 0) {\n        arr.pop();\n      } else {\n        break;\n      }\n    }\n    return arr;\n  }\n  genericAllSheetsGetter(sheetGetter) {\n    const result = {};\n    for (const sheetName of this.dependencyGraph.sheetMapping.displayNames()) {\n      const sheetId = this.dependencyGraph.sheetMapping.fetch(sheetName);\n      result[sheetName] = sheetGetter(sheetId);\n    }\n    return result;\n  }\n  getSheetSerialized(sheet) {\n    return this.genericSheetGetter(sheet, arg => this.getCellSerialized(arg));\n  }\n  getAllSheetsValues() {\n    return this.genericAllSheetsGetter(arg => this.getSheetValues(arg));\n  }\n  getAllSheetsFormulas() {\n    return this.genericAllSheetsGetter(arg => this.getSheetFormulas(arg));\n  }\n  getAllSheetsSerialized() {\n    return this.genericAllSheetsGetter(arg => this.getSheetSerialized(arg));\n  }\n  getAllNamedExpressionsSerialized() {\n    const idMap = [];\n    let id = 0;\n    for (const sheetName of this.dependencyGraph.sheetMapping.displayNames()) {\n      const sheetId = this.dependencyGraph.sheetMapping.fetch(sheetName);\n      idMap[sheetId] = id;\n      id++;\n    }\n    return this.dependencyGraph.namedExpressions.getAllNamedExpressions().map(entry => {\n      return {\n        name: entry.expression.displayName,\n        expression: this.getCellSerialized(entry.expression.address),\n        scope: entry.scope !== undefined ? idMap[entry.scope] : undefined,\n        options: entry.expression.options\n      };\n    });\n  }\n  withNewConfig(newConfig, namedExpressions) {\n    const newUnparser = new Unparser(newConfig, buildLexerConfig(newConfig), this.dependencyGraph.sheetMapping.fetchDisplayName, namedExpressions);\n    return new Serialization(this.dependencyGraph, newUnparser, this.exporter);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}