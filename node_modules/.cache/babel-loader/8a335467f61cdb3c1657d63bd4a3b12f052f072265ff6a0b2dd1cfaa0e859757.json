{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { CellError, movedSimpleCellAddress } from \"../Cell.mjs\";\nimport { AddRowsTransformer } from \"../dependencyTransformers/AddRowsTransformer.mjs\";\nimport { RemoveRowsTransformer } from \"../dependencyTransformers/RemoveRowsTransformer.mjs\";\nimport { forceNormalizeString } from \"../interpreter/ArithmeticHelper.mjs\";\nimport { EmptyValue, getRawValue } from \"../interpreter/InterpreterValue.mjs\";\nimport { SimpleRangeValue } from \"../SimpleRangeValue.mjs\";\nimport { StatType } from \"../statistics/index.mjs\";\nimport { ColumnBinarySearch } from \"./ColumnBinarySearch.mjs\";\nexport class ColumnIndex {\n  constructor(dependencyGraph, config, stats) {\n    this.dependencyGraph = dependencyGraph;\n    this.config = config;\n    this.stats = stats;\n    this.index = new Map();\n    this.transformingService = this.dependencyGraph.lazilyTransformingAstService;\n    this.binarySearchStrategy = new ColumnBinarySearch(dependencyGraph);\n  }\n  add(value, address) {\n    if (value === EmptyValue || value instanceof CellError) {\n      return;\n    } else if (value instanceof SimpleRangeValue) {\n      for (const [arrayValue, cellAddress] of value.entriesFromTopLeftCorner(address)) {\n        this.addSingleCellValue(getRawValue(arrayValue), cellAddress);\n      }\n    } else {\n      this.addSingleCellValue(value, address);\n    }\n  }\n  remove(value, address) {\n    if (value === undefined) {\n      return;\n    }\n    if (value instanceof SimpleRangeValue) {\n      for (const [arrayValue, cellAddress] of value.entriesFromTopLeftCorner(address)) {\n        this.removeSingleValue(getRawValue(arrayValue), cellAddress);\n      }\n    } else {\n      this.removeSingleValue(value, address);\n    }\n  }\n  change(oldValue, newValue, address) {\n    if (oldValue === newValue) {\n      return;\n    }\n    this.remove(oldValue, address);\n    this.add(newValue, address);\n  }\n  applyChanges(contentChanges) {\n    for (const change of contentChanges) {\n      if (change.oldValue !== undefined) {\n        this.change(getRawValue(change.oldValue), getRawValue(change.value), change.address);\n      }\n    }\n  }\n  moveValues(sourceRange, toRight, toBottom, toSheet) {\n    for (const [value, address] of sourceRange) {\n      const targetAddress = movedSimpleCellAddress(address, toSheet, toRight, toBottom);\n      this.remove(value, address);\n      this.add(value, targetAddress);\n    }\n  }\n  removeValues(range) {\n    for (const [value, address] of range) {\n      this.remove(value, address);\n    }\n  }\n  find(searchKey, rangeValue, {\n    ordering,\n    ifNoMatch,\n    returnOccurrence\n  }) {\n    if (returnOccurrence == null) {\n      returnOccurrence = ordering === 'none' ? 'first' : 'last';\n    }\n    const resultUsingColumnIndex = this.findUsingColumnIndex(searchKey, rangeValue, returnOccurrence);\n    return resultUsingColumnIndex !== undefined ? resultUsingColumnIndex : this.binarySearchStrategy.find(searchKey, rangeValue, {\n      ordering,\n      ifNoMatch,\n      returnOccurrence\n    });\n  }\n  findUsingColumnIndex(key, rangeValue, returnOccurrence) {\n    const range = rangeValue.range;\n    if (range === undefined) {\n      return undefined;\n    }\n    this.ensureRecentData(range.sheet, range.start.col, key);\n    const columnMap = this.getColumnMap(range.sheet, range.start.col);\n    if (!columnMap) {\n      return -1;\n    }\n    const normalizedKey = typeof key === 'string' ? forceNormalizeString(key) : key;\n    const valueIndexForTheKey = columnMap.get(normalizedKey);\n    if (!valueIndexForTheKey || !valueIndexForTheKey.index || valueIndexForTheKey.index.length === 0) {\n      return undefined;\n    }\n    const rowNumber = ColumnIndex.findRowBelongingToRange(valueIndexForTheKey, range, returnOccurrence);\n    return rowNumber !== undefined ? rowNumber - range.start.row : undefined;\n  }\n  static findRowBelongingToRange(valueIndex, range, returnOccurrence) {\n    const start = range.start.row;\n    const end = range.end.row;\n    const positionInIndex = returnOccurrence === 'first' ? findInOrderedArray(start, valueIndex.index, 'upperBound') : findInOrderedArray(end, valueIndex.index, 'lowerBound');\n    if (positionInIndex === -1) {\n      return undefined;\n    }\n    const rowNumber = valueIndex.index[positionInIndex];\n    const isRowNumberBelongingToRange = rowNumber >= start && rowNumber <= end;\n    return isRowNumberBelongingToRange ? rowNumber : undefined;\n  }\n  advancedFind(keyMatcher, range, options = {\n    returnOccurrence: 'first'\n  }) {\n    return this.binarySearchStrategy.advancedFind(keyMatcher, range, options);\n  }\n  addColumns(columnsSpan) {\n    const sheetIndex = this.index.get(columnsSpan.sheet);\n    if (!sheetIndex) {\n      return;\n    }\n    sheetIndex.splice(columnsSpan.columnStart, 0, ...Array(columnsSpan.numberOfColumns));\n  }\n  removeColumns(columnsSpan) {\n    const sheetIndex = this.index.get(columnsSpan.sheet);\n    if (!sheetIndex) {\n      return;\n    }\n    sheetIndex.splice(columnsSpan.columnStart, columnsSpan.numberOfColumns);\n  }\n  removeSheet(sheetId) {\n    this.index.delete(sheetId);\n  }\n  getColumnMap(sheet, col) {\n    if (!this.index.has(sheet)) {\n      this.index.set(sheet, []);\n    }\n    const sheetMap = this.index.get(sheet); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n    let columnMap = sheetMap[col];\n    if (!columnMap) {\n      columnMap = new Map();\n      sheetMap[col] = columnMap;\n    }\n    return columnMap;\n  }\n  getValueIndex(sheet, col, value) {\n    const columnMap = this.getColumnMap(sheet, col);\n    let index = this.getColumnMap(sheet, col).get(value);\n    if (!index) {\n      index = {\n        version: this.transformingService.version(),\n        index: []\n      };\n      columnMap.set(value, index);\n    }\n    return index;\n  }\n  ensureRecentData(sheet, col, value) {\n    const valueIndex = this.getValueIndex(sheet, col, value);\n    const actualVersion = this.transformingService.version();\n    if (valueIndex.version === actualVersion) {\n      return;\n    }\n    const relevantTransformations = this.transformingService.getTransformationsFrom(valueIndex.version, transformation => {\n      return transformation.sheet === sheet && (transformation instanceof AddRowsTransformer || transformation instanceof RemoveRowsTransformer);\n    });\n    for (const transformation of relevantTransformations) {\n      if (transformation instanceof AddRowsTransformer) {\n        this.addRows(col, transformation.rowsSpan, value);\n      } else if (transformation instanceof RemoveRowsTransformer) {\n        this.removeRows(col, transformation.rowsSpan, value);\n      }\n    }\n    valueIndex.version = actualVersion;\n  }\n  addSingleCellValue(value, address) {\n    this.stats.measure(StatType.BUILD_COLUMN_INDEX, () => {\n      this.ensureRecentData(address.sheet, address.col, value);\n      if (typeof value === 'string') {\n        value = forceNormalizeString(value);\n      }\n      const valueIndex = this.getValueIndex(address.sheet, address.col, value);\n      ColumnIndex.addValue(valueIndex, address.row);\n    });\n  }\n  removeSingleValue(value, address) {\n    this.stats.measure(StatType.BUILD_COLUMN_INDEX, () => {\n      this.ensureRecentData(address.sheet, address.col, value);\n      const columnMap = this.getColumnMap(address.sheet, address.col);\n      if (typeof value === 'string') {\n        value = forceNormalizeString(value);\n      }\n      const valueIndex = columnMap.get(value);\n      if (!valueIndex) {\n        return;\n      }\n      const positionInIndex = findInOrderedArray(address.row, valueIndex.index);\n      if (positionInIndex > -1) {\n        valueIndex.index.splice(positionInIndex, 1);\n      }\n      if (valueIndex.index.length === 0) {\n        columnMap.delete(value);\n      }\n      if (columnMap.size === 0) {\n        delete this.index.get(address.sheet)[address.col]; // eslint-disable-line @typescript-eslint/no-non-null-assertion\n      }\n    });\n  }\n  addRows(col, rowsSpan, value) {\n    const valueIndex = this.getValueIndex(rowsSpan.sheet, col, value);\n    ColumnIndex.shiftRows(valueIndex, rowsSpan.rowStart, rowsSpan.numberOfRows);\n  }\n  removeRows(col, rowsSpan, value) {\n    const valueIndex = this.getValueIndex(rowsSpan.sheet, col, value);\n    ColumnIndex.removeRowsFromValues(valueIndex, rowsSpan);\n    ColumnIndex.shiftRows(valueIndex, rowsSpan.rowEnd + 1, -rowsSpan.numberOfRows);\n  }\n  static addValue(valueIndex, rowNumber) {\n    const rowIndex = findInOrderedArray(rowNumber, valueIndex.index, 'lowerBound');\n    const isRowNumberAlreadyInIndex = valueIndex.index[rowIndex] === rowNumber;\n    if (!isRowNumberAlreadyInIndex) {\n      valueIndex.index.splice(rowIndex + 1, 0, rowNumber);\n    }\n  }\n  static removeRowsFromValues(valueIndex, rowsSpan) {\n    const start = findInOrderedArray(rowsSpan.rowStart, valueIndex.index, 'upperBound');\n    const end = findInOrderedArray(rowsSpan.rowEnd, valueIndex.index, 'lowerBound');\n    const isFoundSpanValid = start > -1 && end > -1 && start <= end && valueIndex.index[start] <= rowsSpan.rowEnd;\n    if (isFoundSpanValid) {\n      valueIndex.index.splice(start, end - start + 1);\n    }\n  }\n  static shiftRows(valueIndex, afterRow, numberOfRows) {\n    const positionInIndex = findInOrderedArray(afterRow, valueIndex.index, 'upperBound');\n    if (positionInIndex === -1) {\n      return;\n    }\n    for (let i = positionInIndex; i < valueIndex.index.length; ++i) {\n      valueIndex.index[i] += numberOfRows;\n    }\n  }\n}\n/*\r\n * Returns:\r\n * - index of the key, if the key exists in the array,\r\n * - index of the lower/upper bound (depending on handlingMisses parameter) otherwise.\r\n * Assumption: The array is ordered ascending and contains no repetitions.\r\n */\nexport function findInOrderedArray(key, values, handlingMisses = 'upperBound') {\n  let start = 0;\n  let end = values.length - 1;\n  while (start <= end) {\n    const center = Math.floor((start + end) / 2);\n    if (key > values[center]) {\n      start = center + 1;\n    } else if (key < values[center]) {\n      end = center - 1;\n    } else {\n      return center;\n    }\n  }\n  const foundIndex = handlingMisses === 'lowerBound' ? end : start;\n  const isIndexInRange = foundIndex >= 0 && foundIndex <= values.length;\n  return isIndexInRange ? foundIndex : -1;\n}","map":{"version":3,"names":["CellError","movedSimpleCellAddress","AddRowsTransformer","RemoveRowsTransformer","forceNormalizeString","EmptyValue","getRawValue","SimpleRangeValue","StatType","ColumnBinarySearch","ColumnIndex","constructor","dependencyGraph","config","stats","index","Map","transformingService","lazilyTransformingAstService","binarySearchStrategy","add","value","address","arrayValue","cellAddress","entriesFromTopLeftCorner","addSingleCellValue","remove","undefined","removeSingleValue","change","oldValue","newValue","applyChanges","contentChanges","moveValues","sourceRange","toRight","toBottom","toSheet","targetAddress","removeValues","range","find","searchKey","rangeValue","ordering","ifNoMatch","returnOccurrence","resultUsingColumnIndex","findUsingColumnIndex","key","ensureRecentData","sheet","start","col","columnMap","getColumnMap","normalizedKey","valueIndexForTheKey","get","length","rowNumber","findRowBelongingToRange","row","valueIndex","end","positionInIndex","findInOrderedArray","isRowNumberBelongingToRange","advancedFind","keyMatcher","options","addColumns","columnsSpan","sheetIndex","splice","columnStart","Array","numberOfColumns","removeColumns","removeSheet","sheetId","delete","has","set","sheetMap","getValueIndex","version","actualVersion","relevantTransformations","getTransformationsFrom","transformation","addRows","rowsSpan","removeRows","measure","BUILD_COLUMN_INDEX","addValue","size","shiftRows","rowStart","numberOfRows","removeRowsFromValues","rowEnd","rowIndex","isRowNumberAlreadyInIndex","isFoundSpanValid","afterRow","i","values","handlingMisses","center","Math","floor","foundIndex","isIndexInRange"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/Lookup/ColumnIndex.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { CellError, movedSimpleCellAddress } from \"../Cell.mjs\";\nimport { AddRowsTransformer } from \"../dependencyTransformers/AddRowsTransformer.mjs\";\nimport { RemoveRowsTransformer } from \"../dependencyTransformers/RemoveRowsTransformer.mjs\";\nimport { forceNormalizeString } from \"../interpreter/ArithmeticHelper.mjs\";\nimport { EmptyValue, getRawValue } from \"../interpreter/InterpreterValue.mjs\";\nimport { SimpleRangeValue } from \"../SimpleRangeValue.mjs\";\nimport { StatType } from \"../statistics/index.mjs\";\nimport { ColumnBinarySearch } from \"./ColumnBinarySearch.mjs\";\nexport class ColumnIndex {\n  constructor(dependencyGraph, config, stats) {\n    this.dependencyGraph = dependencyGraph;\n    this.config = config;\n    this.stats = stats;\n    this.index = new Map();\n    this.transformingService = this.dependencyGraph.lazilyTransformingAstService;\n    this.binarySearchStrategy = new ColumnBinarySearch(dependencyGraph);\n  }\n  add(value, address) {\n    if (value === EmptyValue || value instanceof CellError) {\n      return;\n    } else if (value instanceof SimpleRangeValue) {\n      for (const [arrayValue, cellAddress] of value.entriesFromTopLeftCorner(address)) {\n        this.addSingleCellValue(getRawValue(arrayValue), cellAddress);\n      }\n    } else {\n      this.addSingleCellValue(value, address);\n    }\n  }\n  remove(value, address) {\n    if (value === undefined) {\n      return;\n    }\n    if (value instanceof SimpleRangeValue) {\n      for (const [arrayValue, cellAddress] of value.entriesFromTopLeftCorner(address)) {\n        this.removeSingleValue(getRawValue(arrayValue), cellAddress);\n      }\n    } else {\n      this.removeSingleValue(value, address);\n    }\n  }\n  change(oldValue, newValue, address) {\n    if (oldValue === newValue) {\n      return;\n    }\n    this.remove(oldValue, address);\n    this.add(newValue, address);\n  }\n  applyChanges(contentChanges) {\n    for (const change of contentChanges) {\n      if (change.oldValue !== undefined) {\n        this.change(getRawValue(change.oldValue), getRawValue(change.value), change.address);\n      }\n    }\n  }\n  moveValues(sourceRange, toRight, toBottom, toSheet) {\n    for (const [value, address] of sourceRange) {\n      const targetAddress = movedSimpleCellAddress(address, toSheet, toRight, toBottom);\n      this.remove(value, address);\n      this.add(value, targetAddress);\n    }\n  }\n  removeValues(range) {\n    for (const [value, address] of range) {\n      this.remove(value, address);\n    }\n  }\n  find(searchKey, rangeValue, {\n    ordering,\n    ifNoMatch,\n    returnOccurrence\n  }) {\n    if (returnOccurrence == null) {\n      returnOccurrence = ordering === 'none' ? 'first' : 'last';\n    }\n    const resultUsingColumnIndex = this.findUsingColumnIndex(searchKey, rangeValue, returnOccurrence);\n    return resultUsingColumnIndex !== undefined ? resultUsingColumnIndex : this.binarySearchStrategy.find(searchKey, rangeValue, {\n      ordering,\n      ifNoMatch,\n      returnOccurrence\n    });\n  }\n  findUsingColumnIndex(key, rangeValue, returnOccurrence) {\n    const range = rangeValue.range;\n    if (range === undefined) {\n      return undefined;\n    }\n    this.ensureRecentData(range.sheet, range.start.col, key);\n    const columnMap = this.getColumnMap(range.sheet, range.start.col);\n    if (!columnMap) {\n      return -1;\n    }\n    const normalizedKey = typeof key === 'string' ? forceNormalizeString(key) : key;\n    const valueIndexForTheKey = columnMap.get(normalizedKey);\n    if (!valueIndexForTheKey || !valueIndexForTheKey.index || valueIndexForTheKey.index.length === 0) {\n      return undefined;\n    }\n    const rowNumber = ColumnIndex.findRowBelongingToRange(valueIndexForTheKey, range, returnOccurrence);\n    return rowNumber !== undefined ? rowNumber - range.start.row : undefined;\n  }\n  static findRowBelongingToRange(valueIndex, range, returnOccurrence) {\n    const start = range.start.row;\n    const end = range.end.row;\n    const positionInIndex = returnOccurrence === 'first' ? findInOrderedArray(start, valueIndex.index, 'upperBound') : findInOrderedArray(end, valueIndex.index, 'lowerBound');\n    if (positionInIndex === -1) {\n      return undefined;\n    }\n    const rowNumber = valueIndex.index[positionInIndex];\n    const isRowNumberBelongingToRange = rowNumber >= start && rowNumber <= end;\n    return isRowNumberBelongingToRange ? rowNumber : undefined;\n  }\n  advancedFind(keyMatcher, range, options = {\n    returnOccurrence: 'first'\n  }) {\n    return this.binarySearchStrategy.advancedFind(keyMatcher, range, options);\n  }\n  addColumns(columnsSpan) {\n    const sheetIndex = this.index.get(columnsSpan.sheet);\n    if (!sheetIndex) {\n      return;\n    }\n    sheetIndex.splice(columnsSpan.columnStart, 0, ...Array(columnsSpan.numberOfColumns));\n  }\n  removeColumns(columnsSpan) {\n    const sheetIndex = this.index.get(columnsSpan.sheet);\n    if (!sheetIndex) {\n      return;\n    }\n    sheetIndex.splice(columnsSpan.columnStart, columnsSpan.numberOfColumns);\n  }\n  removeSheet(sheetId) {\n    this.index.delete(sheetId);\n  }\n  getColumnMap(sheet, col) {\n    if (!this.index.has(sheet)) {\n      this.index.set(sheet, []);\n    }\n    const sheetMap = this.index.get(sheet); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n    let columnMap = sheetMap[col];\n    if (!columnMap) {\n      columnMap = new Map();\n      sheetMap[col] = columnMap;\n    }\n    return columnMap;\n  }\n  getValueIndex(sheet, col, value) {\n    const columnMap = this.getColumnMap(sheet, col);\n    let index = this.getColumnMap(sheet, col).get(value);\n    if (!index) {\n      index = {\n        version: this.transformingService.version(),\n        index: []\n      };\n      columnMap.set(value, index);\n    }\n    return index;\n  }\n  ensureRecentData(sheet, col, value) {\n    const valueIndex = this.getValueIndex(sheet, col, value);\n    const actualVersion = this.transformingService.version();\n    if (valueIndex.version === actualVersion) {\n      return;\n    }\n    const relevantTransformations = this.transformingService.getTransformationsFrom(valueIndex.version, transformation => {\n      return transformation.sheet === sheet && (transformation instanceof AddRowsTransformer || transformation instanceof RemoveRowsTransformer);\n    });\n    for (const transformation of relevantTransformations) {\n      if (transformation instanceof AddRowsTransformer) {\n        this.addRows(col, transformation.rowsSpan, value);\n      } else if (transformation instanceof RemoveRowsTransformer) {\n        this.removeRows(col, transformation.rowsSpan, value);\n      }\n    }\n    valueIndex.version = actualVersion;\n  }\n  addSingleCellValue(value, address) {\n    this.stats.measure(StatType.BUILD_COLUMN_INDEX, () => {\n      this.ensureRecentData(address.sheet, address.col, value);\n      if (typeof value === 'string') {\n        value = forceNormalizeString(value);\n      }\n      const valueIndex = this.getValueIndex(address.sheet, address.col, value);\n      ColumnIndex.addValue(valueIndex, address.row);\n    });\n  }\n  removeSingleValue(value, address) {\n    this.stats.measure(StatType.BUILD_COLUMN_INDEX, () => {\n      this.ensureRecentData(address.sheet, address.col, value);\n      const columnMap = this.getColumnMap(address.sheet, address.col);\n      if (typeof value === 'string') {\n        value = forceNormalizeString(value);\n      }\n      const valueIndex = columnMap.get(value);\n      if (!valueIndex) {\n        return;\n      }\n      const positionInIndex = findInOrderedArray(address.row, valueIndex.index);\n      if (positionInIndex > -1) {\n        valueIndex.index.splice(positionInIndex, 1);\n      }\n      if (valueIndex.index.length === 0) {\n        columnMap.delete(value);\n      }\n      if (columnMap.size === 0) {\n        delete this.index.get(address.sheet)[address.col]; // eslint-disable-line @typescript-eslint/no-non-null-assertion\n      }\n    });\n  }\n  addRows(col, rowsSpan, value) {\n    const valueIndex = this.getValueIndex(rowsSpan.sheet, col, value);\n    ColumnIndex.shiftRows(valueIndex, rowsSpan.rowStart, rowsSpan.numberOfRows);\n  }\n  removeRows(col, rowsSpan, value) {\n    const valueIndex = this.getValueIndex(rowsSpan.sheet, col, value);\n    ColumnIndex.removeRowsFromValues(valueIndex, rowsSpan);\n    ColumnIndex.shiftRows(valueIndex, rowsSpan.rowEnd + 1, -rowsSpan.numberOfRows);\n  }\n  static addValue(valueIndex, rowNumber) {\n    const rowIndex = findInOrderedArray(rowNumber, valueIndex.index, 'lowerBound');\n    const isRowNumberAlreadyInIndex = valueIndex.index[rowIndex] === rowNumber;\n    if (!isRowNumberAlreadyInIndex) {\n      valueIndex.index.splice(rowIndex + 1, 0, rowNumber);\n    }\n  }\n  static removeRowsFromValues(valueIndex, rowsSpan) {\n    const start = findInOrderedArray(rowsSpan.rowStart, valueIndex.index, 'upperBound');\n    const end = findInOrderedArray(rowsSpan.rowEnd, valueIndex.index, 'lowerBound');\n    const isFoundSpanValid = start > -1 && end > -1 && start <= end && valueIndex.index[start] <= rowsSpan.rowEnd;\n    if (isFoundSpanValid) {\n      valueIndex.index.splice(start, end - start + 1);\n    }\n  }\n  static shiftRows(valueIndex, afterRow, numberOfRows) {\n    const positionInIndex = findInOrderedArray(afterRow, valueIndex.index, 'upperBound');\n    if (positionInIndex === -1) {\n      return;\n    }\n    for (let i = positionInIndex; i < valueIndex.index.length; ++i) {\n      valueIndex.index[i] += numberOfRows;\n    }\n  }\n}\n/*\r\n * Returns:\r\n * - index of the key, if the key exists in the array,\r\n * - index of the lower/upper bound (depending on handlingMisses parameter) otherwise.\r\n * Assumption: The array is ordered ascending and contains no repetitions.\r\n */\nexport function findInOrderedArray(key, values, handlingMisses = 'upperBound') {\n  let start = 0;\n  let end = values.length - 1;\n  while (start <= end) {\n    const center = Math.floor((start + end) / 2);\n    if (key > values[center]) {\n      start = center + 1;\n    } else if (key < values[center]) {\n      end = center - 1;\n    } else {\n      return center;\n    }\n  }\n  const foundIndex = handlingMisses === 'lowerBound' ? end : start;\n  const isIndexInRange = foundIndex >= 0 && foundIndex <= values.length;\n  return isIndexInRange ? foundIndex : -1;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}