{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { equalSimpleCellAddress, isSimpleCellAddress, simpleCellAddress } from \"./Cell.mjs\";\nimport { SheetsNotEqual } from \"./errors.mjs\";\nimport { AstNodeType } from \"./parser/index.mjs\";\nimport { RowsSpan } from \"./Span.mjs\";\nexport const WRONG_RANGE_SIZE = 'AbsoluteCellRange: Wrong range size';\nexport function isSimpleCellRange(obj) {\n  if (obj && (typeof obj === 'object' || typeof obj === 'function')) {\n    return 'start' in obj && isSimpleCellAddress(obj.start) && 'end' in obj && isSimpleCellAddress(obj.end);\n  } else {\n    return false;\n  }\n}\nexport const simpleCellRange = (start, end) => ({\n  start,\n  end\n});\nexport class AbsoluteCellRange {\n  constructor(start, end) {\n    if (start.sheet !== end.sheet) {\n      throw new SheetsNotEqual(start.sheet, end.sheet);\n    }\n    this.start = simpleCellAddress(start.sheet, start.col, start.row);\n    this.end = simpleCellAddress(end.sheet, end.col, end.row);\n  }\n  get sheet() {\n    return this.start.sheet;\n  }\n  static fromSimpleCellAddresses(start, end) {\n    if (start.sheet !== end.sheet) {\n      throw new SheetsNotEqual(start.sheet, end.sheet);\n    }\n    const width = end.col - start.col;\n    const height = end.row - start.row;\n    if (Number.isFinite(height) && Number.isFinite(width)) {\n      return new AbsoluteCellRange(start, end);\n    }\n    if (Number.isFinite(height)) {\n      return new AbsoluteRowRange(start.sheet, start.row, end.row);\n    }\n    return new AbsoluteColumnRange(start.sheet, start.col, end.col);\n  }\n  static fromAst(ast, baseAddress) {\n    if (ast.type === AstNodeType.CELL_RANGE) {\n      return AbsoluteCellRange.fromCellRange(ast, baseAddress);\n    } else if (ast.type === AstNodeType.COLUMN_RANGE) {\n      return AbsoluteColumnRange.fromColumnRange(ast, baseAddress);\n    } else {\n      return AbsoluteRowRange.fromRowRangeAst(ast, baseAddress);\n    }\n  }\n  static fromAstOrUndef(ast, baseAddress) {\n    try {\n      return AbsoluteCellRange.fromAst(ast, baseAddress);\n    } catch (_e) {\n      return undefined;\n    }\n  }\n  static fromCellRange(x, baseAddress) {\n    return new AbsoluteCellRange(x.start.toSimpleCellAddress(baseAddress), x.end.toSimpleCellAddress(baseAddress));\n  }\n  static spanFrom(topLeftCorner, width, height) {\n    const ret = AbsoluteCellRange.spanFromOrUndef(topLeftCorner, width, height);\n    if (ret === undefined) {\n      throw new Error(WRONG_RANGE_SIZE);\n    }\n    return ret;\n  }\n  static spanFromOrUndef(topLeftCorner, width, height) {\n    if (!Number.isFinite(width) && Number.isFinite(height)) {\n      if (topLeftCorner.col !== 0) {\n        return undefined;\n      }\n      return new AbsoluteRowRange(topLeftCorner.sheet, topLeftCorner.row, topLeftCorner.row + height - 1);\n    } else if (!Number.isFinite(height) && Number.isFinite(width)) {\n      if (topLeftCorner.row !== 0) {\n        return undefined;\n      }\n      return new AbsoluteColumnRange(topLeftCorner.sheet, topLeftCorner.col, topLeftCorner.col + width - 1);\n    } else if (Number.isFinite(height) && Number.isFinite(width)) {\n      return new AbsoluteCellRange(topLeftCorner, simpleCellAddress(topLeftCorner.sheet, topLeftCorner.col + width - 1, topLeftCorner.row + height - 1));\n    }\n    return undefined;\n  }\n  static fromCoordinates(sheet, x1, y1, x2, y2) {\n    return new AbsoluteCellRange(simpleCellAddress(sheet, x1, y1), simpleCellAddress(sheet, x2, y2));\n  }\n  isFinite() {\n    return Number.isFinite(this.size());\n  }\n  doesOverlap(other) {\n    if (this.start.sheet != other.start.sheet) {\n      return false;\n    }\n    if (this.end.row < other.start.row || this.start.row > other.end.row) {\n      return false;\n    }\n    if (this.end.col < other.start.col || this.start.col > other.end.col) {\n      return false;\n    }\n    return true;\n  }\n  addressInRange(address) {\n    if (this.sheet !== address.sheet) {\n      return false;\n    }\n    return this.start.row <= address.row && this.end.row >= address.row && this.start.col <= address.col && this.end.col >= address.col;\n  }\n  columnInRange(address) {\n    if (this.sheet !== address.sheet) {\n      return false;\n    }\n    return this.start.col <= address.col && this.end.col >= address.col;\n  }\n  rowInRange(address) {\n    if (this.sheet !== address.sheet) {\n      return false;\n    }\n    return this.start.row <= address.row && this.end.row >= address.row;\n  }\n  containsRange(range) {\n    return this.addressInRange(range.start) && this.addressInRange(range.end);\n  }\n  intersectionWith(other) {\n    if (this.sheet !== other.start.sheet) {\n      return undefined;\n    }\n    const startRow = Math.max(this.start.row, other.start.row);\n    const endRow = Math.min(this.end.row, other.end.row);\n    const startCol = Math.max(this.start.col, other.start.col);\n    const endCol = Math.min(this.end.col, other.end.col);\n    if (startRow > endRow || startCol > endCol) {\n      return undefined;\n    }\n    return new AbsoluteCellRange(simpleCellAddress(this.sheet, startCol, startRow), simpleCellAddress(this.sheet, endCol, endRow));\n  }\n  includesRow(row) {\n    return this.start.row < row && this.end.row >= row;\n  }\n  includesColumn(column) {\n    return this.start.col < column && this.end.col >= column;\n  }\n  shiftByRows(numberOfRows) {\n    this.start.row += numberOfRows;\n    this.end.row += numberOfRows;\n  }\n  expandByRows(numberOfRows) {\n    this.end.row += numberOfRows;\n  }\n  shiftByColumns(numberOfColumns) {\n    this.start.col += numberOfColumns;\n    this.end.col += numberOfColumns;\n  }\n  shifted(byCols, byRows) {\n    return AbsoluteCellRange.spanFrom(simpleCellAddress(this.sheet, this.start.col + byCols, this.start.row + byRows), this.width(), this.height());\n  }\n  expandByColumns(numberOfColumns) {\n    this.end.col += numberOfColumns;\n  }\n  moveToSheet(toSheet) {\n    this.start.sheet = toSheet;\n    this.end.sheet = toSheet;\n  }\n  removeSpan(span) {\n    if (span instanceof RowsSpan) {\n      this.removeRows(span.start, span.end);\n    } else {\n      this.removeColumns(span.start, span.end);\n    }\n  }\n  shouldBeRemoved() {\n    return this.width() <= 0 || this.height() <= 0;\n  }\n  rangeWithSameWidth(startRow, numberOfRows) {\n    return AbsoluteCellRange.spanFrom(simpleCellAddress(this.sheet, this.start.col, startRow), this.width(), numberOfRows);\n  }\n  rangeWithSameHeight(startColumn, numberOfColumns) {\n    return AbsoluteCellRange.spanFrom(simpleCellAddress(this.sheet, startColumn, this.start.row), numberOfColumns, this.height());\n  }\n  toString() {\n    return `${this.start.sheet},${this.start.col},${this.start.row},${this.end.col},${this.end.row}`;\n  }\n  width() {\n    return this.end.col - this.start.col + 1;\n  }\n  height() {\n    return this.end.row - this.start.row + 1;\n  }\n  size() {\n    return this.height() * this.width();\n  }\n  arrayOfAddressesInRange() {\n    const result = [];\n    for (let y = 0; y < this.height(); ++y) {\n      result[y] = [];\n      for (let x = 0; x < this.width(); ++x) {\n        const value = simpleCellAddress(this.sheet, this.start.col + x, this.start.row + y);\n        result[y].push(value);\n      }\n    }\n    return result;\n  }\n  withStart(newStart) {\n    return new AbsoluteCellRange(newStart, this.end);\n  }\n  sameDimensionsAs(other) {\n    return this.width() === other.width() && this.height() === other.height();\n  }\n  sameAs(other) {\n    return equalSimpleCellAddress(this.start, other.start) && equalSimpleCellAddress(this.end, other.end);\n  }\n  addressesArrayMap(dependencyGraph, op) {\n    const ret = [];\n    let currentRow = this.start.row;\n    while (currentRow <= this.effectiveEndRow(dependencyGraph)) {\n      let currentColumn = this.start.col;\n      const tmp = [];\n      while (currentColumn <= this.effectiveEndColumn(dependencyGraph)) {\n        tmp.push(op(simpleCellAddress(this.start.sheet, currentColumn, currentRow)));\n        currentColumn++;\n      }\n      ret.push(tmp);\n      currentRow++;\n    }\n    return ret;\n  }\n  addresses(dependencyGraph) {\n    const ret = [];\n    let currentRow = this.start.row;\n    const limitRow = this.effectiveEndRow(dependencyGraph);\n    const limitColumn = this.effectiveEndColumn(dependencyGraph);\n    while (currentRow <= limitRow) {\n      let currentColumn = this.start.col;\n      while (currentColumn <= limitColumn) {\n        ret.push(simpleCellAddress(this.start.sheet, currentColumn, currentRow));\n        currentColumn++;\n      }\n      currentRow++;\n    }\n    return ret;\n  }\n  *addressesWithDirection(right, bottom, dependencyGraph) {\n    if (right > 0) {\n      if (bottom > 0) {\n        let currentRow = this.effectiveEndRow(dependencyGraph);\n        while (currentRow >= this.start.row) {\n          let currentColumn = this.effectiveEndColumn(dependencyGraph);\n          while (currentColumn >= this.start.col) {\n            yield simpleCellAddress(this.start.sheet, currentColumn, currentRow);\n            currentColumn -= 1;\n          }\n          currentRow -= 1;\n        }\n      } else {\n        let currentRow = this.start.row;\n        while (currentRow <= this.effectiveEndRow(dependencyGraph)) {\n          let currentColumn = this.effectiveEndColumn(dependencyGraph);\n          while (currentColumn >= this.start.col) {\n            yield simpleCellAddress(this.start.sheet, currentColumn, currentRow);\n            currentColumn -= 1;\n          }\n          currentRow += 1;\n        }\n      }\n    } else {\n      if (bottom > 0) {\n        let currentRow = this.effectiveEndRow(dependencyGraph);\n        while (currentRow >= this.start.row) {\n          let currentColumn = this.start.col;\n          while (currentColumn <= this.effectiveEndColumn(dependencyGraph)) {\n            yield simpleCellAddress(this.start.sheet, currentColumn, currentRow);\n            currentColumn += 1;\n          }\n          currentRow -= 1;\n        }\n      } else {\n        let currentRow = this.start.row;\n        while (currentRow <= this.effectiveEndRow(dependencyGraph)) {\n          let currentColumn = this.start.col;\n          while (currentColumn <= this.effectiveEndColumn(dependencyGraph)) {\n            yield simpleCellAddress(this.start.sheet, currentColumn, currentRow);\n            currentColumn += 1;\n          }\n          currentRow += 1;\n        }\n      }\n    }\n  }\n  getAddress(col, row) {\n    if (col < 0 || row < 0 || row > this.height() - 1 || col > this.width() - 1) {\n      throw Error('Index out of bound');\n    }\n    return simpleCellAddress(this.start.sheet, this.start.col + col, this.start.row + row);\n  }\n  exceedsSheetSizeLimits(maxColumns, maxRows) {\n    return this.end.col >= maxColumns || this.end.row >= maxRows;\n  }\n  effectiveEndColumn(_dependencyGraph) {\n    return this.end.col;\n  }\n  effectiveEndRow(_dependencyGraph) {\n    return this.end.row;\n  }\n  effectiveWidth(_dependencyGraph) {\n    return this.width();\n  }\n  effectiveHeight(_dependencyGraph) {\n    return this.height();\n  }\n  removeRows(rowStart, rowEnd) {\n    if (rowStart > this.end.row) {\n      return;\n    }\n    if (rowEnd < this.start.row) {\n      const numberOfRows = rowEnd - rowStart + 1;\n      return this.shiftByRows(-numberOfRows);\n    }\n    if (rowStart <= this.start.row) {\n      this.start.row = rowStart;\n    }\n    this.end.row -= Math.min(rowEnd, this.end.row) - rowStart + 1;\n  }\n  removeColumns(columnStart, columnEnd) {\n    if (columnStart > this.end.col) {\n      return;\n    }\n    if (columnEnd < this.start.col) {\n      const numberOfColumns = columnEnd - columnStart + 1;\n      return this.shiftByColumns(-numberOfColumns);\n    }\n    if (columnStart <= this.start.col) {\n      this.start.col = columnStart;\n    }\n    this.end.col -= Math.min(columnEnd, this.end.col) - columnStart + 1;\n  }\n}\nexport class AbsoluteColumnRange extends AbsoluteCellRange {\n  constructor(sheet, columnStart, columnEnd) {\n    super(simpleCellAddress(sheet, columnStart, 0), simpleCellAddress(sheet, columnEnd, Number.POSITIVE_INFINITY));\n  }\n  static fromColumnRange(x, baseAddress) {\n    const start = x.start.toSimpleColumnAddress(baseAddress);\n    const end = x.end.toSimpleColumnAddress(baseAddress);\n    if (start.sheet !== end.sheet) {\n      throw new SheetsNotEqual(start.sheet, end.sheet);\n    }\n    return new AbsoluteColumnRange(start.sheet, start.col, end.col);\n  }\n  shouldBeRemoved() {\n    return this.width() <= 0;\n  }\n  shiftByRows(_numberOfRows) {\n    return;\n  }\n  expandByRows(_numberOfRows) {\n    return;\n  }\n  shifted(byCols, _byRows) {\n    return new AbsoluteColumnRange(this.sheet, this.start.col + byCols, this.end.col + byCols);\n  }\n  rangeWithSameHeight(startColumn, numberOfColumns) {\n    return new AbsoluteColumnRange(this.sheet, startColumn, startColumn + numberOfColumns - 1);\n  }\n  exceedsSheetSizeLimits(maxColumns, _maxRows) {\n    return this.end.col >= maxColumns;\n  }\n  effectiveEndRow(dependencyGraph) {\n    return this.effectiveHeight(dependencyGraph) - 1;\n  }\n  effectiveHeight(dependencyGraph) {\n    return dependencyGraph.getSheetHeight(this.sheet);\n  }\n  removeRows(_rowStart, _rowEnd) {\n    return;\n  }\n}\nexport class AbsoluteRowRange extends AbsoluteCellRange {\n  constructor(sheet, rowStart, rowEnd) {\n    super(simpleCellAddress(sheet, 0, rowStart), simpleCellAddress(sheet, Number.POSITIVE_INFINITY, rowEnd));\n  }\n  static fromRowRangeAst(x, baseAddress) {\n    const start = x.start.toSimpleRowAddress(baseAddress);\n    const end = x.end.toSimpleRowAddress(baseAddress);\n    if (start.sheet !== end.sheet) {\n      throw new SheetsNotEqual(start.sheet, end.sheet);\n    }\n    return new AbsoluteRowRange(start.sheet, start.row, end.row);\n  }\n  shouldBeRemoved() {\n    return this.height() <= 0;\n  }\n  shiftByColumns(_numberOfColumns) {\n    return;\n  }\n  expandByColumns(_numberOfColumns) {\n    return;\n  }\n  shifted(byCols, byRows) {\n    return new AbsoluteRowRange(this.sheet, this.start.row + byRows, this.end.row + byRows);\n  }\n  rangeWithSameWidth(startRow, numberOfRows) {\n    return new AbsoluteRowRange(this.sheet, startRow, startRow + numberOfRows - 1);\n  }\n  exceedsSheetSizeLimits(_maxColumns, maxRows) {\n    return this.end.row >= maxRows;\n  }\n  effectiveEndColumn(dependencyGraph) {\n    return this.effectiveWidth(dependencyGraph) - 1;\n  }\n  effectiveWidth(dependencyGraph) {\n    return dependencyGraph.getSheetWidth(this.sheet);\n  }\n  removeColumns(_columnStart, _columnEnd) {\n    return;\n  }\n}","map":{"version":3,"names":["equalSimpleCellAddress","isSimpleCellAddress","simpleCellAddress","SheetsNotEqual","AstNodeType","RowsSpan","WRONG_RANGE_SIZE","isSimpleCellRange","obj","start","end","simpleCellRange","AbsoluteCellRange","constructor","sheet","col","row","fromSimpleCellAddresses","width","height","Number","isFinite","AbsoluteRowRange","AbsoluteColumnRange","fromAst","ast","baseAddress","type","CELL_RANGE","fromCellRange","COLUMN_RANGE","fromColumnRange","fromRowRangeAst","fromAstOrUndef","_e","undefined","x","toSimpleCellAddress","spanFrom","topLeftCorner","ret","spanFromOrUndef","Error","fromCoordinates","x1","y1","x2","y2","size","doesOverlap","other","addressInRange","address","columnInRange","rowInRange","containsRange","range","intersectionWith","startRow","Math","max","endRow","min","startCol","endCol","includesRow","includesColumn","column","shiftByRows","numberOfRows","expandByRows","shiftByColumns","numberOfColumns","shifted","byCols","byRows","expandByColumns","moveToSheet","toSheet","removeSpan","span","removeRows","removeColumns","shouldBeRemoved","rangeWithSameWidth","rangeWithSameHeight","startColumn","toString","arrayOfAddressesInRange","result","y","value","push","withStart","newStart","sameDimensionsAs","sameAs","addressesArrayMap","dependencyGraph","op","currentRow","effectiveEndRow","currentColumn","tmp","effectiveEndColumn","addresses","limitRow","limitColumn","addressesWithDirection","right","bottom","getAddress","exceedsSheetSizeLimits","maxColumns","maxRows","_dependencyGraph","effectiveWidth","effectiveHeight","rowStart","rowEnd","columnStart","columnEnd","POSITIVE_INFINITY","toSimpleColumnAddress","_numberOfRows","_byRows","_maxRows","getSheetHeight","_rowStart","_rowEnd","toSimpleRowAddress","_numberOfColumns","_maxColumns","getSheetWidth","_columnStart","_columnEnd"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/AbsoluteCellRange.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { equalSimpleCellAddress, isSimpleCellAddress, simpleCellAddress } from \"./Cell.mjs\";\nimport { SheetsNotEqual } from \"./errors.mjs\";\nimport { AstNodeType } from \"./parser/index.mjs\";\nimport { RowsSpan } from \"./Span.mjs\";\nexport const WRONG_RANGE_SIZE = 'AbsoluteCellRange: Wrong range size';\nexport function isSimpleCellRange(obj) {\n  if (obj && (typeof obj === 'object' || typeof obj === 'function')) {\n    return 'start' in obj && isSimpleCellAddress(obj.start) && 'end' in obj && isSimpleCellAddress(obj.end);\n  } else {\n    return false;\n  }\n}\nexport const simpleCellRange = (start, end) => ({\n  start,\n  end\n});\nexport class AbsoluteCellRange {\n  constructor(start, end) {\n    if (start.sheet !== end.sheet) {\n      throw new SheetsNotEqual(start.sheet, end.sheet);\n    }\n    this.start = simpleCellAddress(start.sheet, start.col, start.row);\n    this.end = simpleCellAddress(end.sheet, end.col, end.row);\n  }\n  get sheet() {\n    return this.start.sheet;\n  }\n  static fromSimpleCellAddresses(start, end) {\n    if (start.sheet !== end.sheet) {\n      throw new SheetsNotEqual(start.sheet, end.sheet);\n    }\n    const width = end.col - start.col;\n    const height = end.row - start.row;\n    if (Number.isFinite(height) && Number.isFinite(width)) {\n      return new AbsoluteCellRange(start, end);\n    }\n    if (Number.isFinite(height)) {\n      return new AbsoluteRowRange(start.sheet, start.row, end.row);\n    }\n    return new AbsoluteColumnRange(start.sheet, start.col, end.col);\n  }\n  static fromAst(ast, baseAddress) {\n    if (ast.type === AstNodeType.CELL_RANGE) {\n      return AbsoluteCellRange.fromCellRange(ast, baseAddress);\n    } else if (ast.type === AstNodeType.COLUMN_RANGE) {\n      return AbsoluteColumnRange.fromColumnRange(ast, baseAddress);\n    } else {\n      return AbsoluteRowRange.fromRowRangeAst(ast, baseAddress);\n    }\n  }\n  static fromAstOrUndef(ast, baseAddress) {\n    try {\n      return AbsoluteCellRange.fromAst(ast, baseAddress);\n    } catch (_e) {\n      return undefined;\n    }\n  }\n  static fromCellRange(x, baseAddress) {\n    return new AbsoluteCellRange(x.start.toSimpleCellAddress(baseAddress), x.end.toSimpleCellAddress(baseAddress));\n  }\n  static spanFrom(topLeftCorner, width, height) {\n    const ret = AbsoluteCellRange.spanFromOrUndef(topLeftCorner, width, height);\n    if (ret === undefined) {\n      throw new Error(WRONG_RANGE_SIZE);\n    }\n    return ret;\n  }\n  static spanFromOrUndef(topLeftCorner, width, height) {\n    if (!Number.isFinite(width) && Number.isFinite(height)) {\n      if (topLeftCorner.col !== 0) {\n        return undefined;\n      }\n      return new AbsoluteRowRange(topLeftCorner.sheet, topLeftCorner.row, topLeftCorner.row + height - 1);\n    } else if (!Number.isFinite(height) && Number.isFinite(width)) {\n      if (topLeftCorner.row !== 0) {\n        return undefined;\n      }\n      return new AbsoluteColumnRange(topLeftCorner.sheet, topLeftCorner.col, topLeftCorner.col + width - 1);\n    } else if (Number.isFinite(height) && Number.isFinite(width)) {\n      return new AbsoluteCellRange(topLeftCorner, simpleCellAddress(topLeftCorner.sheet, topLeftCorner.col + width - 1, topLeftCorner.row + height - 1));\n    }\n    return undefined;\n  }\n  static fromCoordinates(sheet, x1, y1, x2, y2) {\n    return new AbsoluteCellRange(simpleCellAddress(sheet, x1, y1), simpleCellAddress(sheet, x2, y2));\n  }\n  isFinite() {\n    return Number.isFinite(this.size());\n  }\n  doesOverlap(other) {\n    if (this.start.sheet != other.start.sheet) {\n      return false;\n    }\n    if (this.end.row < other.start.row || this.start.row > other.end.row) {\n      return false;\n    }\n    if (this.end.col < other.start.col || this.start.col > other.end.col) {\n      return false;\n    }\n    return true;\n  }\n  addressInRange(address) {\n    if (this.sheet !== address.sheet) {\n      return false;\n    }\n    return this.start.row <= address.row && this.end.row >= address.row && this.start.col <= address.col && this.end.col >= address.col;\n  }\n  columnInRange(address) {\n    if (this.sheet !== address.sheet) {\n      return false;\n    }\n    return this.start.col <= address.col && this.end.col >= address.col;\n  }\n  rowInRange(address) {\n    if (this.sheet !== address.sheet) {\n      return false;\n    }\n    return this.start.row <= address.row && this.end.row >= address.row;\n  }\n  containsRange(range) {\n    return this.addressInRange(range.start) && this.addressInRange(range.end);\n  }\n  intersectionWith(other) {\n    if (this.sheet !== other.start.sheet) {\n      return undefined;\n    }\n    const startRow = Math.max(this.start.row, other.start.row);\n    const endRow = Math.min(this.end.row, other.end.row);\n    const startCol = Math.max(this.start.col, other.start.col);\n    const endCol = Math.min(this.end.col, other.end.col);\n    if (startRow > endRow || startCol > endCol) {\n      return undefined;\n    }\n    return new AbsoluteCellRange(simpleCellAddress(this.sheet, startCol, startRow), simpleCellAddress(this.sheet, endCol, endRow));\n  }\n  includesRow(row) {\n    return this.start.row < row && this.end.row >= row;\n  }\n  includesColumn(column) {\n    return this.start.col < column && this.end.col >= column;\n  }\n  shiftByRows(numberOfRows) {\n    this.start.row += numberOfRows;\n    this.end.row += numberOfRows;\n  }\n  expandByRows(numberOfRows) {\n    this.end.row += numberOfRows;\n  }\n  shiftByColumns(numberOfColumns) {\n    this.start.col += numberOfColumns;\n    this.end.col += numberOfColumns;\n  }\n  shifted(byCols, byRows) {\n    return AbsoluteCellRange.spanFrom(simpleCellAddress(this.sheet, this.start.col + byCols, this.start.row + byRows), this.width(), this.height());\n  }\n  expandByColumns(numberOfColumns) {\n    this.end.col += numberOfColumns;\n  }\n  moveToSheet(toSheet) {\n    this.start.sheet = toSheet;\n    this.end.sheet = toSheet;\n  }\n  removeSpan(span) {\n    if (span instanceof RowsSpan) {\n      this.removeRows(span.start, span.end);\n    } else {\n      this.removeColumns(span.start, span.end);\n    }\n  }\n  shouldBeRemoved() {\n    return this.width() <= 0 || this.height() <= 0;\n  }\n  rangeWithSameWidth(startRow, numberOfRows) {\n    return AbsoluteCellRange.spanFrom(simpleCellAddress(this.sheet, this.start.col, startRow), this.width(), numberOfRows);\n  }\n  rangeWithSameHeight(startColumn, numberOfColumns) {\n    return AbsoluteCellRange.spanFrom(simpleCellAddress(this.sheet, startColumn, this.start.row), numberOfColumns, this.height());\n  }\n  toString() {\n    return `${this.start.sheet},${this.start.col},${this.start.row},${this.end.col},${this.end.row}`;\n  }\n  width() {\n    return this.end.col - this.start.col + 1;\n  }\n  height() {\n    return this.end.row - this.start.row + 1;\n  }\n  size() {\n    return this.height() * this.width();\n  }\n  arrayOfAddressesInRange() {\n    const result = [];\n    for (let y = 0; y < this.height(); ++y) {\n      result[y] = [];\n      for (let x = 0; x < this.width(); ++x) {\n        const value = simpleCellAddress(this.sheet, this.start.col + x, this.start.row + y);\n        result[y].push(value);\n      }\n    }\n    return result;\n  }\n  withStart(newStart) {\n    return new AbsoluteCellRange(newStart, this.end);\n  }\n  sameDimensionsAs(other) {\n    return this.width() === other.width() && this.height() === other.height();\n  }\n  sameAs(other) {\n    return equalSimpleCellAddress(this.start, other.start) && equalSimpleCellAddress(this.end, other.end);\n  }\n  addressesArrayMap(dependencyGraph, op) {\n    const ret = [];\n    let currentRow = this.start.row;\n    while (currentRow <= this.effectiveEndRow(dependencyGraph)) {\n      let currentColumn = this.start.col;\n      const tmp = [];\n      while (currentColumn <= this.effectiveEndColumn(dependencyGraph)) {\n        tmp.push(op(simpleCellAddress(this.start.sheet, currentColumn, currentRow)));\n        currentColumn++;\n      }\n      ret.push(tmp);\n      currentRow++;\n    }\n    return ret;\n  }\n  addresses(dependencyGraph) {\n    const ret = [];\n    let currentRow = this.start.row;\n    const limitRow = this.effectiveEndRow(dependencyGraph);\n    const limitColumn = this.effectiveEndColumn(dependencyGraph);\n    while (currentRow <= limitRow) {\n      let currentColumn = this.start.col;\n      while (currentColumn <= limitColumn) {\n        ret.push(simpleCellAddress(this.start.sheet, currentColumn, currentRow));\n        currentColumn++;\n      }\n      currentRow++;\n    }\n    return ret;\n  }\n  *addressesWithDirection(right, bottom, dependencyGraph) {\n    if (right > 0) {\n      if (bottom > 0) {\n        let currentRow = this.effectiveEndRow(dependencyGraph);\n        while (currentRow >= this.start.row) {\n          let currentColumn = this.effectiveEndColumn(dependencyGraph);\n          while (currentColumn >= this.start.col) {\n            yield simpleCellAddress(this.start.sheet, currentColumn, currentRow);\n            currentColumn -= 1;\n          }\n          currentRow -= 1;\n        }\n      } else {\n        let currentRow = this.start.row;\n        while (currentRow <= this.effectiveEndRow(dependencyGraph)) {\n          let currentColumn = this.effectiveEndColumn(dependencyGraph);\n          while (currentColumn >= this.start.col) {\n            yield simpleCellAddress(this.start.sheet, currentColumn, currentRow);\n            currentColumn -= 1;\n          }\n          currentRow += 1;\n        }\n      }\n    } else {\n      if (bottom > 0) {\n        let currentRow = this.effectiveEndRow(dependencyGraph);\n        while (currentRow >= this.start.row) {\n          let currentColumn = this.start.col;\n          while (currentColumn <= this.effectiveEndColumn(dependencyGraph)) {\n            yield simpleCellAddress(this.start.sheet, currentColumn, currentRow);\n            currentColumn += 1;\n          }\n          currentRow -= 1;\n        }\n      } else {\n        let currentRow = this.start.row;\n        while (currentRow <= this.effectiveEndRow(dependencyGraph)) {\n          let currentColumn = this.start.col;\n          while (currentColumn <= this.effectiveEndColumn(dependencyGraph)) {\n            yield simpleCellAddress(this.start.sheet, currentColumn, currentRow);\n            currentColumn += 1;\n          }\n          currentRow += 1;\n        }\n      }\n    }\n  }\n  getAddress(col, row) {\n    if (col < 0 || row < 0 || row > this.height() - 1 || col > this.width() - 1) {\n      throw Error('Index out of bound');\n    }\n    return simpleCellAddress(this.start.sheet, this.start.col + col, this.start.row + row);\n  }\n  exceedsSheetSizeLimits(maxColumns, maxRows) {\n    return this.end.col >= maxColumns || this.end.row >= maxRows;\n  }\n  effectiveEndColumn(_dependencyGraph) {\n    return this.end.col;\n  }\n  effectiveEndRow(_dependencyGraph) {\n    return this.end.row;\n  }\n  effectiveWidth(_dependencyGraph) {\n    return this.width();\n  }\n  effectiveHeight(_dependencyGraph) {\n    return this.height();\n  }\n  removeRows(rowStart, rowEnd) {\n    if (rowStart > this.end.row) {\n      return;\n    }\n    if (rowEnd < this.start.row) {\n      const numberOfRows = rowEnd - rowStart + 1;\n      return this.shiftByRows(-numberOfRows);\n    }\n    if (rowStart <= this.start.row) {\n      this.start.row = rowStart;\n    }\n    this.end.row -= Math.min(rowEnd, this.end.row) - rowStart + 1;\n  }\n  removeColumns(columnStart, columnEnd) {\n    if (columnStart > this.end.col) {\n      return;\n    }\n    if (columnEnd < this.start.col) {\n      const numberOfColumns = columnEnd - columnStart + 1;\n      return this.shiftByColumns(-numberOfColumns);\n    }\n    if (columnStart <= this.start.col) {\n      this.start.col = columnStart;\n    }\n    this.end.col -= Math.min(columnEnd, this.end.col) - columnStart + 1;\n  }\n}\nexport class AbsoluteColumnRange extends AbsoluteCellRange {\n  constructor(sheet, columnStart, columnEnd) {\n    super(simpleCellAddress(sheet, columnStart, 0), simpleCellAddress(sheet, columnEnd, Number.POSITIVE_INFINITY));\n  }\n  static fromColumnRange(x, baseAddress) {\n    const start = x.start.toSimpleColumnAddress(baseAddress);\n    const end = x.end.toSimpleColumnAddress(baseAddress);\n    if (start.sheet !== end.sheet) {\n      throw new SheetsNotEqual(start.sheet, end.sheet);\n    }\n    return new AbsoluteColumnRange(start.sheet, start.col, end.col);\n  }\n  shouldBeRemoved() {\n    return this.width() <= 0;\n  }\n  shiftByRows(_numberOfRows) {\n    return;\n  }\n  expandByRows(_numberOfRows) {\n    return;\n  }\n  shifted(byCols, _byRows) {\n    return new AbsoluteColumnRange(this.sheet, this.start.col + byCols, this.end.col + byCols);\n  }\n  rangeWithSameHeight(startColumn, numberOfColumns) {\n    return new AbsoluteColumnRange(this.sheet, startColumn, startColumn + numberOfColumns - 1);\n  }\n  exceedsSheetSizeLimits(maxColumns, _maxRows) {\n    return this.end.col >= maxColumns;\n  }\n  effectiveEndRow(dependencyGraph) {\n    return this.effectiveHeight(dependencyGraph) - 1;\n  }\n  effectiveHeight(dependencyGraph) {\n    return dependencyGraph.getSheetHeight(this.sheet);\n  }\n  removeRows(_rowStart, _rowEnd) {\n    return;\n  }\n}\nexport class AbsoluteRowRange extends AbsoluteCellRange {\n  constructor(sheet, rowStart, rowEnd) {\n    super(simpleCellAddress(sheet, 0, rowStart), simpleCellAddress(sheet, Number.POSITIVE_INFINITY, rowEnd));\n  }\n  static fromRowRangeAst(x, baseAddress) {\n    const start = x.start.toSimpleRowAddress(baseAddress);\n    const end = x.end.toSimpleRowAddress(baseAddress);\n    if (start.sheet !== end.sheet) {\n      throw new SheetsNotEqual(start.sheet, end.sheet);\n    }\n    return new AbsoluteRowRange(start.sheet, start.row, end.row);\n  }\n  shouldBeRemoved() {\n    return this.height() <= 0;\n  }\n  shiftByColumns(_numberOfColumns) {\n    return;\n  }\n  expandByColumns(_numberOfColumns) {\n    return;\n  }\n  shifted(byCols, byRows) {\n    return new AbsoluteRowRange(this.sheet, this.start.row + byRows, this.end.row + byRows);\n  }\n  rangeWithSameWidth(startRow, numberOfRows) {\n    return new AbsoluteRowRange(this.sheet, startRow, startRow + numberOfRows - 1);\n  }\n  exceedsSheetSizeLimits(_maxColumns, maxRows) {\n    return this.end.row >= maxRows;\n  }\n  effectiveEndColumn(dependencyGraph) {\n    return this.effectiveWidth(dependencyGraph) - 1;\n  }\n  effectiveWidth(dependencyGraph) {\n    return dependencyGraph.getSheetWidth(this.sheet);\n  }\n  removeColumns(_columnStart, _columnEnd) {\n    return;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}