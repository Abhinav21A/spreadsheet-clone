{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { absoluteSheetReference, ErrorType } from \"../Cell.mjs\";\nimport { Transformer } from \"./Transformer.mjs\";\nexport class RemoveRowsTransformer extends Transformer {\n  constructor(rowsSpan) {\n    super();\n    this.rowsSpan = rowsSpan;\n  }\n  get sheet() {\n    return this.rowsSpan.sheet;\n  }\n  isIrreversible() {\n    return true;\n  }\n  transformColumnRangeAst(ast, _formulaAddress) {\n    return ast;\n  }\n  transformCellAddress(dependencyAddress, formulaAddress) {\n    const absoluteDependencySheet = absoluteSheetReference(dependencyAddress, formulaAddress);\n    // Case 4\n    if (this.rowsSpan.sheet !== formulaAddress.sheet && this.rowsSpan.sheet !== absoluteDependencySheet) {\n      return false;\n    }\n    // Case 3 -- removed row in same sheet where dependency is but formula in different\n    if (this.rowsSpan.sheet !== formulaAddress.sheet && this.rowsSpan.sheet === absoluteDependencySheet) {\n      const absoluteDependencyAddress = dependencyAddress.toSimpleRowAddress(formulaAddress);\n      if (absoluteDependencyAddress.row < this.rowsSpan.rowStart) {\n        // 3.ARa\n        return false;\n      } else if (absoluteDependencyAddress.row > this.rowsSpan.rowEnd) {\n        // 3.ARb\n        return dependencyAddress.shiftedByRows(-this.rowsSpan.numberOfRows);\n      }\n    }\n    // Case 2 -- removed row in same sheet where formula but dependency in different sheet\n    if (this.rowsSpan.sheet === formulaAddress.sheet && this.rowsSpan.sheet !== absoluteDependencySheet) {\n      if (dependencyAddress.isRowAbsolute()) {\n        // 2.A\n        return false;\n      } else {\n        if (formulaAddress.row < this.rowsSpan.rowStart) {\n          // 2.Ra\n          return false;\n        } else if (formulaAddress.row > this.rowsSpan.rowEnd) {\n          // 2.Rb\n          return dependencyAddress.shiftedByRows(this.rowsSpan.numberOfRows);\n        }\n      }\n    }\n    // Case 1 -- same sheet\n    if (this.rowsSpan.sheet === formulaAddress.sheet && this.rowsSpan.sheet === absoluteDependencySheet) {\n      if (dependencyAddress.isRowAbsolute()) {\n        if (dependencyAddress.row < this.rowsSpan.rowStart) {\n          // 1.Aa\n          return false;\n        } else if (dependencyAddress.row > this.rowsSpan.rowEnd) {\n          // 1.Ab\n          return dependencyAddress.shiftedByRows(-this.rowsSpan.numberOfRows);\n        }\n      } else {\n        const absoluteDependencyAddress = dependencyAddress.toSimpleRowAddress(formulaAddress);\n        if (absoluteDependencyAddress.row < this.rowsSpan.rowStart) {\n          if (formulaAddress.row < this.rowsSpan.rowStart) {\n            // 1.Raa\n            return false;\n          } else if (formulaAddress.row > this.rowsSpan.rowEnd) {\n            // 1.Rab\n            return dependencyAddress.shiftedByRows(this.rowsSpan.numberOfRows);\n          }\n        } else if (absoluteDependencyAddress.row > this.rowsSpan.rowEnd) {\n          if (formulaAddress.row < this.rowsSpan.rowStart) {\n            // 1.Rba\n            return dependencyAddress.shiftedByRows(-this.rowsSpan.numberOfRows);\n          } else if (formulaAddress.row > this.rowsSpan.rowEnd) {\n            // 1.Rbb\n            return false;\n          }\n        }\n      }\n    }\n    // 1.Ac, 1.Rca, 1.Rcb, 3.Ac, 3.Rca, 3.Rcb\n    return ErrorType.REF;\n  }\n  transformCellRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformRowRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformColumnRange(_start, _end, _formulaAddress) {\n    throw Error('Not implemented');\n  }\n  fixNodeAddress(address) {\n    if (this.rowsSpan.sheet === address.sheet && this.rowsSpan.rowStart <= address.row) {\n      return Object.assign(Object.assign({}, address), {\n        row: address.row - this.rowsSpan.numberOfRows\n      });\n    } else {\n      return address;\n    }\n  }\n  transformRange(start, end, formulaAddress) {\n    const startSheet = absoluteSheetReference(start, formulaAddress);\n    let actualStart = start;\n    let actualEnd = end;\n    if (this.rowsSpan.sheet === startSheet) {\n      const startSCA = start.toSimpleRowAddress(formulaAddress);\n      const endSCA = end.toSimpleRowAddress(formulaAddress);\n      if (this.rowsSpan.rowStart <= startSCA.row && this.rowsSpan.rowEnd >= endSCA.row) {\n        return ErrorType.REF;\n      }\n      if (startSCA.row >= this.rowsSpan.rowStart && startSCA.row <= this.rowsSpan.rowEnd) {\n        actualStart = start.shiftedByRows(this.rowsSpan.rowEnd - startSCA.row + 1);\n      }\n      if (endSCA.row >= this.rowsSpan.rowStart && endSCA.row <= this.rowsSpan.rowEnd) {\n        actualEnd = end.shiftedByRows(-(endSCA.row - this.rowsSpan.rowStart + 1));\n      }\n    }\n    const newStart = this.transformCellAddress(actualStart, formulaAddress);\n    const newEnd = this.transformCellAddress(actualEnd, formulaAddress);\n    if (newStart === false && newEnd === false) {\n      return [actualStart, actualEnd];\n    } else if (newStart === ErrorType.REF || newEnd === ErrorType.REF) {\n      return ErrorType.REF;\n    } else {\n      return [newStart || actualStart, newEnd || actualEnd];\n    }\n  }\n}","map":{"version":3,"names":["absoluteSheetReference","ErrorType","Transformer","RemoveRowsTransformer","constructor","rowsSpan","sheet","isIrreversible","transformColumnRangeAst","ast","_formulaAddress","transformCellAddress","dependencyAddress","formulaAddress","absoluteDependencySheet","absoluteDependencyAddress","toSimpleRowAddress","row","rowStart","rowEnd","shiftedByRows","numberOfRows","isRowAbsolute","REF","transformCellRange","start","end","transformRange","transformRowRange","transformColumnRange","_start","_end","Error","fixNodeAddress","address","Object","assign","startSheet","actualStart","actualEnd","startSCA","endSCA","newStart","newEnd"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/dependencyTransformers/RemoveRowsTransformer.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { absoluteSheetReference, ErrorType } from \"../Cell.mjs\";\nimport { Transformer } from \"./Transformer.mjs\";\nexport class RemoveRowsTransformer extends Transformer {\n  constructor(rowsSpan) {\n    super();\n    this.rowsSpan = rowsSpan;\n  }\n  get sheet() {\n    return this.rowsSpan.sheet;\n  }\n  isIrreversible() {\n    return true;\n  }\n  transformColumnRangeAst(ast, _formulaAddress) {\n    return ast;\n  }\n  transformCellAddress(dependencyAddress, formulaAddress) {\n    const absoluteDependencySheet = absoluteSheetReference(dependencyAddress, formulaAddress);\n    // Case 4\n    if (this.rowsSpan.sheet !== formulaAddress.sheet && this.rowsSpan.sheet !== absoluteDependencySheet) {\n      return false;\n    }\n    // Case 3 -- removed row in same sheet where dependency is but formula in different\n    if (this.rowsSpan.sheet !== formulaAddress.sheet && this.rowsSpan.sheet === absoluteDependencySheet) {\n      const absoluteDependencyAddress = dependencyAddress.toSimpleRowAddress(formulaAddress);\n      if (absoluteDependencyAddress.row < this.rowsSpan.rowStart) {\n        // 3.ARa\n        return false;\n      } else if (absoluteDependencyAddress.row > this.rowsSpan.rowEnd) {\n        // 3.ARb\n        return dependencyAddress.shiftedByRows(-this.rowsSpan.numberOfRows);\n      }\n    }\n    // Case 2 -- removed row in same sheet where formula but dependency in different sheet\n    if (this.rowsSpan.sheet === formulaAddress.sheet && this.rowsSpan.sheet !== absoluteDependencySheet) {\n      if (dependencyAddress.isRowAbsolute()) {\n        // 2.A\n        return false;\n      } else {\n        if (formulaAddress.row < this.rowsSpan.rowStart) {\n          // 2.Ra\n          return false;\n        } else if (formulaAddress.row > this.rowsSpan.rowEnd) {\n          // 2.Rb\n          return dependencyAddress.shiftedByRows(this.rowsSpan.numberOfRows);\n        }\n      }\n    }\n    // Case 1 -- same sheet\n    if (this.rowsSpan.sheet === formulaAddress.sheet && this.rowsSpan.sheet === absoluteDependencySheet) {\n      if (dependencyAddress.isRowAbsolute()) {\n        if (dependencyAddress.row < this.rowsSpan.rowStart) {\n          // 1.Aa\n          return false;\n        } else if (dependencyAddress.row > this.rowsSpan.rowEnd) {\n          // 1.Ab\n          return dependencyAddress.shiftedByRows(-this.rowsSpan.numberOfRows);\n        }\n      } else {\n        const absoluteDependencyAddress = dependencyAddress.toSimpleRowAddress(formulaAddress);\n        if (absoluteDependencyAddress.row < this.rowsSpan.rowStart) {\n          if (formulaAddress.row < this.rowsSpan.rowStart) {\n            // 1.Raa\n            return false;\n          } else if (formulaAddress.row > this.rowsSpan.rowEnd) {\n            // 1.Rab\n            return dependencyAddress.shiftedByRows(this.rowsSpan.numberOfRows);\n          }\n        } else if (absoluteDependencyAddress.row > this.rowsSpan.rowEnd) {\n          if (formulaAddress.row < this.rowsSpan.rowStart) {\n            // 1.Rba\n            return dependencyAddress.shiftedByRows(-this.rowsSpan.numberOfRows);\n          } else if (formulaAddress.row > this.rowsSpan.rowEnd) {\n            // 1.Rbb\n            return false;\n          }\n        }\n      }\n    }\n    // 1.Ac, 1.Rca, 1.Rcb, 3.Ac, 3.Rca, 3.Rcb\n    return ErrorType.REF;\n  }\n  transformCellRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformRowRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformColumnRange(_start, _end, _formulaAddress) {\n    throw Error('Not implemented');\n  }\n  fixNodeAddress(address) {\n    if (this.rowsSpan.sheet === address.sheet && this.rowsSpan.rowStart <= address.row) {\n      return Object.assign(Object.assign({}, address), {\n        row: address.row - this.rowsSpan.numberOfRows\n      });\n    } else {\n      return address;\n    }\n  }\n  transformRange(start, end, formulaAddress) {\n    const startSheet = absoluteSheetReference(start, formulaAddress);\n    let actualStart = start;\n    let actualEnd = end;\n    if (this.rowsSpan.sheet === startSheet) {\n      const startSCA = start.toSimpleRowAddress(formulaAddress);\n      const endSCA = end.toSimpleRowAddress(formulaAddress);\n      if (this.rowsSpan.rowStart <= startSCA.row && this.rowsSpan.rowEnd >= endSCA.row) {\n        return ErrorType.REF;\n      }\n      if (startSCA.row >= this.rowsSpan.rowStart && startSCA.row <= this.rowsSpan.rowEnd) {\n        actualStart = start.shiftedByRows(this.rowsSpan.rowEnd - startSCA.row + 1);\n      }\n      if (endSCA.row >= this.rowsSpan.rowStart && endSCA.row <= this.rowsSpan.rowEnd) {\n        actualEnd = end.shiftedByRows(-(endSCA.row - this.rowsSpan.rowStart + 1));\n      }\n    }\n    const newStart = this.transformCellAddress(actualStart, formulaAddress);\n    const newEnd = this.transformCellAddress(actualEnd, formulaAddress);\n    if (newStart === false && newEnd === false) {\n      return [actualStart, actualEnd];\n    } else if (newStart === ErrorType.REF || newEnd === ErrorType.REF) {\n      return ErrorType.REF;\n    } else {\n      return [newStart || actualStart, newEnd || actualEnd];\n    }\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}