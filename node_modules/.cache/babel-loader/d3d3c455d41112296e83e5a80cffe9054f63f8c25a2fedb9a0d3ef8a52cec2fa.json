{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { ArraySize } from \"./ArraySize.mjs\";\nimport { CellError, ErrorType, simpleCellAddress } from \"./Cell.mjs\";\nimport { ErrorMessage } from \"./error-message.mjs\";\nimport { isExtendedNumber } from \"./interpreter/InterpreterValue.mjs\";\n/**\r\n * A class that represents a range of data.\r\n */\nexport class SimpleRangeValue {\n  /**\r\n   * In most cases, it's more convenient to create a `SimpleRangeValue` object\r\n   * by calling one of the [static factory methods](#fromrange).\r\n   */\n  constructor(_data,\n  /**\r\n   * A property that represents the address of the range.\r\n   */\n  range, dependencyGraph, _hasOnlyNumbers) {\n    this._data = _data;\n    this.range = range;\n    this.dependencyGraph = dependencyGraph;\n    this._hasOnlyNumbers = _hasOnlyNumbers;\n    this.size = _data === undefined ? new ArraySize(range.effectiveWidth(dependencyGraph), range.effectiveHeight(dependencyGraph)) : new ArraySize(_data[0].length, _data.length);\n  }\n  /**\r\n   * Returns the range data as a 2D array.\r\n   */\n  get data() {\n    this.ensureThatComputed();\n    return this._data;\n  }\n  /**\r\n   * A factory method. Returns a `SimpleRangeValue` object with the provided range address and the provided data.\r\n   */\n  static fromRange(data, range, dependencyGraph) {\n    return new SimpleRangeValue(data, range, dependencyGraph, true);\n  }\n  /**\r\n   * A factory method. Returns a `SimpleRangeValue` object with the provided numeric data.\r\n   */\n  static onlyNumbers(data) {\n    return new SimpleRangeValue(data, undefined, undefined, true);\n  }\n  /**\r\n   * A factory method. Returns a `SimpleRangeValue` object with the provided data.\r\n   */\n  static onlyValues(data) {\n    return new SimpleRangeValue(data, undefined, undefined, undefined);\n  }\n  /**\r\n   * A factory method. Returns a `SimpleRangeValue` object with the provided range address.\r\n   */\n  static onlyRange(range, dependencyGraph) {\n    return new SimpleRangeValue(undefined, range, dependencyGraph, undefined);\n  }\n  /**\r\n   * A factory method. Returns a `SimpleRangeValue` object that contains a single value.\r\n   */\n  static fromScalar(scalar) {\n    return new SimpleRangeValue([[scalar]], undefined, undefined, undefined);\n  }\n  /**\r\n   * Returns `true` if and only if the `SimpleRangeValue` has no address set.\r\n   */\n  isAdHoc() {\n    return this.range === undefined;\n  }\n  /**\r\n   * Returns the number of columns contained in the range.\r\n   */\n  width() {\n    return this.size.width;\n  }\n  /**\r\n   * Returns the number of rows contained in the range.\r\n   */\n  height() {\n    return this.size.height;\n  }\n  /**\r\n   * Returns the range data as a 1D array.\r\n   */\n  valuesFromTopLeftCorner() {\n    this.ensureThatComputed();\n    const ret = [];\n    for (let i = 0; i < this._data.length; i++) {\n      for (let j = 0; j < this._data[0].length; j++) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        ret.push(this._data[i][j]);\n      }\n    }\n    return ret;\n  }\n  /**\r\n   * Generates the addresses of the cells contained in the range assuming the provided address is the left corner of the range.\r\n   */\n  *effectiveAddressesFromData(leftCorner) {\n    for (let row = 0; row < this.data.length; ++row) {\n      const rowData = this.data[row];\n      for (let col = 0; col < rowData.length; ++col) {\n        yield simpleCellAddress(leftCorner.sheet, leftCorner.col + col, leftCorner.row + row);\n      }\n    }\n  }\n  /**\r\n   * Generates values and addresses of the cells contained in the range assuming the provided address is the left corner of the range.\r\n   *\r\n   * This method combines the functionalities of [`iterateValuesFromTopLeftCorner()`](#iteratevaluesfromtopleftcorner) and [`effectiveAddressesFromData()`](#effectiveaddressesfromdata).\r\n   */\n  *entriesFromTopLeftCorner(leftCorner) {\n    this.ensureThatComputed();\n    for (let row = 0; row < this.size.height; ++row) {\n      for (let col = 0; col < this.size.width; ++col) {\n        yield [this._data[row][col], simpleCellAddress(leftCorner.sheet, leftCorner.col + col, leftCorner.row + row)];\n      }\n    }\n  }\n  /**\r\n   * Generates the values of the cells contained in the range assuming the provided address is the left corner of the range.\r\n   */\n  *iterateValuesFromTopLeftCorner() {\n    yield* this.valuesFromTopLeftCorner();\n  }\n  /**\r\n   * Returns the number of cells contained in the range.\r\n   */\n  numberOfElements() {\n    return this.size.width * this.size.height;\n  }\n  /**\r\n   * Returns `true` if and only if the range contains only numeric values.\r\n   */\n  hasOnlyNumbers() {\n    if (this._hasOnlyNumbers === undefined) {\n      this._hasOnlyNumbers = true;\n      for (const row of this.data) {\n        for (const v of row) {\n          if (typeof v !== 'number') {\n            this._hasOnlyNumbers = false;\n            return false;\n          }\n        }\n      }\n    }\n    return this._hasOnlyNumbers;\n  }\n  /**\r\n   * Returns the range data as a 2D array of numbers.\r\n   *\r\n   * Internal use only.\r\n   */\n  rawNumbers() {\n    return this._data;\n  }\n  /**\r\n   * Returns the range data as a 2D array.\r\n   *\r\n   * Internal use only.\r\n   */\n  rawData() {\n    var _a;\n    this.ensureThatComputed();\n    return (_a = this._data) !== null && _a !== void 0 ? _a : [];\n  }\n  /**\r\n   * Returns `true` if and only if the range has the same width and height as the `other` range object.\r\n   */\n  sameDimensionsAs(other) {\n    return this.width() === other.width() && this.height() === other.height();\n  }\n  /**\r\n   * Computes the range data if it is not computed yet.\r\n   */\n  ensureThatComputed() {\n    if (this._data !== undefined) {\n      return;\n    }\n    this._hasOnlyNumbers = true;\n    this._data = this.range.addressesArrayMap(this.dependencyGraph, cellFromRange => {\n      const value = this.dependencyGraph.getCellValue(cellFromRange);\n      if (value instanceof SimpleRangeValue) {\n        this._hasOnlyNumbers = false;\n        return new CellError(ErrorType.VALUE, ErrorMessage.ScalarExpected);\n      } else if (isExtendedNumber(value)) {\n        return value;\n      } else {\n        this._hasOnlyNumbers = false;\n        return value;\n      }\n    });\n  }\n}","map":{"version":3,"names":["ArraySize","CellError","ErrorType","simpleCellAddress","ErrorMessage","isExtendedNumber","SimpleRangeValue","constructor","_data","range","dependencyGraph","_hasOnlyNumbers","size","undefined","effectiveWidth","effectiveHeight","length","data","ensureThatComputed","fromRange","onlyNumbers","onlyValues","onlyRange","fromScalar","scalar","isAdHoc","width","height","valuesFromTopLeftCorner","ret","i","j","push","effectiveAddressesFromData","leftCorner","row","rowData","col","sheet","entriesFromTopLeftCorner","iterateValuesFromTopLeftCorner","numberOfElements","hasOnlyNumbers","v","rawNumbers","rawData","_a","sameDimensionsAs","other","addressesArrayMap","cellFromRange","value","getCellValue","VALUE","ScalarExpected"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/SimpleRangeValue.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { ArraySize } from \"./ArraySize.mjs\";\nimport { CellError, ErrorType, simpleCellAddress } from \"./Cell.mjs\";\nimport { ErrorMessage } from \"./error-message.mjs\";\nimport { isExtendedNumber } from \"./interpreter/InterpreterValue.mjs\";\n/**\r\n * A class that represents a range of data.\r\n */\nexport class SimpleRangeValue {\n  /**\r\n   * In most cases, it's more convenient to create a `SimpleRangeValue` object\r\n   * by calling one of the [static factory methods](#fromrange).\r\n   */\n  constructor(_data,\n  /**\r\n   * A property that represents the address of the range.\r\n   */\n  range, dependencyGraph, _hasOnlyNumbers) {\n    this._data = _data;\n    this.range = range;\n    this.dependencyGraph = dependencyGraph;\n    this._hasOnlyNumbers = _hasOnlyNumbers;\n    this.size = _data === undefined ? new ArraySize(range.effectiveWidth(dependencyGraph), range.effectiveHeight(dependencyGraph)) : new ArraySize(_data[0].length, _data.length);\n  }\n  /**\r\n   * Returns the range data as a 2D array.\r\n   */\n  get data() {\n    this.ensureThatComputed();\n    return this._data;\n  }\n  /**\r\n   * A factory method. Returns a `SimpleRangeValue` object with the provided range address and the provided data.\r\n   */\n  static fromRange(data, range, dependencyGraph) {\n    return new SimpleRangeValue(data, range, dependencyGraph, true);\n  }\n  /**\r\n   * A factory method. Returns a `SimpleRangeValue` object with the provided numeric data.\r\n   */\n  static onlyNumbers(data) {\n    return new SimpleRangeValue(data, undefined, undefined, true);\n  }\n  /**\r\n   * A factory method. Returns a `SimpleRangeValue` object with the provided data.\r\n   */\n  static onlyValues(data) {\n    return new SimpleRangeValue(data, undefined, undefined, undefined);\n  }\n  /**\r\n   * A factory method. Returns a `SimpleRangeValue` object with the provided range address.\r\n   */\n  static onlyRange(range, dependencyGraph) {\n    return new SimpleRangeValue(undefined, range, dependencyGraph, undefined);\n  }\n  /**\r\n   * A factory method. Returns a `SimpleRangeValue` object that contains a single value.\r\n   */\n  static fromScalar(scalar) {\n    return new SimpleRangeValue([[scalar]], undefined, undefined, undefined);\n  }\n  /**\r\n   * Returns `true` if and only if the `SimpleRangeValue` has no address set.\r\n   */\n  isAdHoc() {\n    return this.range === undefined;\n  }\n  /**\r\n   * Returns the number of columns contained in the range.\r\n   */\n  width() {\n    return this.size.width;\n  }\n  /**\r\n   * Returns the number of rows contained in the range.\r\n   */\n  height() {\n    return this.size.height;\n  }\n  /**\r\n   * Returns the range data as a 1D array.\r\n   */\n  valuesFromTopLeftCorner() {\n    this.ensureThatComputed();\n    const ret = [];\n    for (let i = 0; i < this._data.length; i++) {\n      for (let j = 0; j < this._data[0].length; j++) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        ret.push(this._data[i][j]);\n      }\n    }\n    return ret;\n  }\n  /**\r\n   * Generates the addresses of the cells contained in the range assuming the provided address is the left corner of the range.\r\n   */\n  *effectiveAddressesFromData(leftCorner) {\n    for (let row = 0; row < this.data.length; ++row) {\n      const rowData = this.data[row];\n      for (let col = 0; col < rowData.length; ++col) {\n        yield simpleCellAddress(leftCorner.sheet, leftCorner.col + col, leftCorner.row + row);\n      }\n    }\n  }\n  /**\r\n   * Generates values and addresses of the cells contained in the range assuming the provided address is the left corner of the range.\r\n   *\r\n   * This method combines the functionalities of [`iterateValuesFromTopLeftCorner()`](#iteratevaluesfromtopleftcorner) and [`effectiveAddressesFromData()`](#effectiveaddressesfromdata).\r\n   */\n  *entriesFromTopLeftCorner(leftCorner) {\n    this.ensureThatComputed();\n    for (let row = 0; row < this.size.height; ++row) {\n      for (let col = 0; col < this.size.width; ++col) {\n        yield [this._data[row][col], simpleCellAddress(leftCorner.sheet, leftCorner.col + col, leftCorner.row + row)];\n      }\n    }\n  }\n  /**\r\n   * Generates the values of the cells contained in the range assuming the provided address is the left corner of the range.\r\n   */\n  *iterateValuesFromTopLeftCorner() {\n    yield* this.valuesFromTopLeftCorner();\n  }\n  /**\r\n   * Returns the number of cells contained in the range.\r\n   */\n  numberOfElements() {\n    return this.size.width * this.size.height;\n  }\n  /**\r\n   * Returns `true` if and only if the range contains only numeric values.\r\n   */\n  hasOnlyNumbers() {\n    if (this._hasOnlyNumbers === undefined) {\n      this._hasOnlyNumbers = true;\n      for (const row of this.data) {\n        for (const v of row) {\n          if (typeof v !== 'number') {\n            this._hasOnlyNumbers = false;\n            return false;\n          }\n        }\n      }\n    }\n    return this._hasOnlyNumbers;\n  }\n  /**\r\n   * Returns the range data as a 2D array of numbers.\r\n   *\r\n   * Internal use only.\r\n   */\n  rawNumbers() {\n    return this._data;\n  }\n  /**\r\n   * Returns the range data as a 2D array.\r\n   *\r\n   * Internal use only.\r\n   */\n  rawData() {\n    var _a;\n    this.ensureThatComputed();\n    return (_a = this._data) !== null && _a !== void 0 ? _a : [];\n  }\n  /**\r\n   * Returns `true` if and only if the range has the same width and height as the `other` range object.\r\n   */\n  sameDimensionsAs(other) {\n    return this.width() === other.width() && this.height() === other.height();\n  }\n  /**\r\n   * Computes the range data if it is not computed yet.\r\n   */\n  ensureThatComputed() {\n    if (this._data !== undefined) {\n      return;\n    }\n    this._hasOnlyNumbers = true;\n    this._data = this.range.addressesArrayMap(this.dependencyGraph, cellFromRange => {\n      const value = this.dependencyGraph.getCellValue(cellFromRange);\n      if (value instanceof SimpleRangeValue) {\n        this._hasOnlyNumbers = false;\n        return new CellError(ErrorType.VALUE, ErrorMessage.ScalarExpected);\n      } else if (isExtendedNumber(value)) {\n        return value;\n      } else {\n        this._hasOnlyNumbers = false;\n        return value;\n      }\n    });\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}