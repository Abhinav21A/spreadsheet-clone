{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { absoluteSheetReference, ErrorType } from \"../Cell.mjs\";\nimport { Transformer } from \"./Transformer.mjs\";\nexport class RemoveColumnsTransformer extends Transformer {\n  constructor(columnsSpan) {\n    super();\n    this.columnsSpan = columnsSpan;\n  }\n  get sheet() {\n    return this.columnsSpan.sheet;\n  }\n  isIrreversible() {\n    return true;\n  }\n  transformRowRangeAst(ast, _formulaAddress) {\n    return ast;\n  }\n  transformCellRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformRowRange(_start, _end, _formulaAddress) {\n    throw Error('Not implemented');\n  }\n  transformColumnRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformCellAddress(dependencyAddress, formulaAddress) {\n    const absoluteDependencySheet = absoluteSheetReference(dependencyAddress, formulaAddress);\n    // Case 4\n    if (this.columnsSpan.sheet !== formulaAddress.sheet && this.columnsSpan.sheet !== absoluteDependencySheet) {\n      return false;\n    }\n    // Case 3 -- removed column in same sheet where dependency is but formula in different\n    if (this.columnsSpan.sheet !== formulaAddress.sheet && this.columnsSpan.sheet === absoluteDependencySheet) {\n      const absoluteDependencyAddress = dependencyAddress.toSimpleColumnAddress(formulaAddress);\n      if (absoluteDependencyAddress.col < this.columnsSpan.columnStart) {\n        // 3.ARa\n        return false;\n      } else if (absoluteDependencyAddress.col > this.columnsSpan.columnEnd) {\n        // 3.ARb\n        return dependencyAddress.shiftedByColumns(-this.columnsSpan.numberOfColumns);\n      }\n    }\n    // Case 2 -- removed column in same sheet where formula but dependency in different sheet\n    if (this.columnsSpan.sheet === formulaAddress.sheet && this.columnsSpan.sheet !== absoluteDependencySheet) {\n      if (dependencyAddress.isColumnAbsolute()) {\n        // 2.A\n        return false;\n      } else {\n        if (formulaAddress.col < this.columnsSpan.columnStart) {\n          // 2.Ra\n          return false;\n        } else if (formulaAddress.col > this.columnsSpan.columnEnd) {\n          // 2.Rb\n          return dependencyAddress.shiftedByColumns(this.columnsSpan.numberOfColumns);\n        }\n      }\n    }\n    // Case 1 -- same sheet\n    if (this.columnsSpan.sheet === formulaAddress.sheet && this.columnsSpan.sheet === absoluteDependencySheet) {\n      if (dependencyAddress.isColumnAbsolute()) {\n        if (dependencyAddress.col < this.columnsSpan.columnStart) {\n          // 1.Aa\n          return false;\n        } else if (dependencyAddress.col > this.columnsSpan.columnEnd) {\n          // 1.Ab\n          return dependencyAddress.shiftedByColumns(-this.columnsSpan.numberOfColumns);\n        }\n      } else {\n        const absoluteDependencyAddress = dependencyAddress.toSimpleColumnAddress(formulaAddress);\n        if (absoluteDependencyAddress.col < this.columnsSpan.columnStart) {\n          if (formulaAddress.col < this.columnsSpan.columnStart) {\n            // 1.Raa\n            return false;\n          } else if (formulaAddress.col > this.columnsSpan.columnEnd) {\n            // 1.Rab\n            return dependencyAddress.shiftedByColumns(this.columnsSpan.numberOfColumns);\n          }\n        } else if (absoluteDependencyAddress.col > this.columnsSpan.columnEnd) {\n          if (formulaAddress.col < this.columnsSpan.columnStart) {\n            // 1.Rba\n            return dependencyAddress.shiftedByColumns(-this.columnsSpan.numberOfColumns);\n          } else if (formulaAddress.col > this.columnsSpan.columnEnd) {\n            // 1.Rbb\n            return false;\n          }\n        }\n      }\n    }\n    // 1.Ac, 1.Rca, 1.Rcb, 3.Ac, 3.Rca, 3.Rcb\n    return ErrorType.REF;\n  }\n  fixNodeAddress(address) {\n    if (this.columnsSpan.sheet === address.sheet && this.columnsSpan.columnStart <= address.col) {\n      return Object.assign(Object.assign({}, address), {\n        col: address.col - this.columnsSpan.numberOfColumns\n      });\n    } else {\n      return address;\n    }\n  }\n  transformRange(start, end, formulaAddress) {\n    const startSheet = absoluteSheetReference(start, formulaAddress);\n    let actualStart = start;\n    let actualEnd = end;\n    if (this.columnsSpan.sheet === startSheet) {\n      const startSCA = start.toSimpleColumnAddress(formulaAddress);\n      const endSCA = end.toSimpleColumnAddress(formulaAddress);\n      if (this.columnsSpan.columnStart <= startSCA.col && this.columnsSpan.columnEnd >= endSCA.col) {\n        return ErrorType.REF;\n      }\n      if (startSCA.col >= this.columnsSpan.columnStart && startSCA.col <= this.columnsSpan.columnEnd) {\n        actualStart = start.shiftedByColumns(this.columnsSpan.columnEnd - startSCA.col + 1);\n      }\n      if (endSCA.col >= this.columnsSpan.columnStart && endSCA.col <= this.columnsSpan.columnEnd) {\n        actualEnd = end.shiftedByColumns(-(endSCA.col - this.columnsSpan.columnStart + 1));\n      }\n    }\n    const newStart = this.transformCellAddress(actualStart, formulaAddress);\n    const newEnd = this.transformCellAddress(actualEnd, formulaAddress);\n    if (newStart === false && newEnd === false) {\n      return [actualStart, actualEnd];\n    } else if (newStart === ErrorType.REF || newEnd === ErrorType.REF) {\n      throw Error('Cannot happen');\n    } else {\n      return [newStart || actualStart, newEnd || actualEnd];\n    }\n  }\n}","map":{"version":3,"names":["absoluteSheetReference","ErrorType","Transformer","RemoveColumnsTransformer","constructor","columnsSpan","sheet","isIrreversible","transformRowRangeAst","ast","_formulaAddress","transformCellRange","start","end","formulaAddress","transformRange","transformRowRange","_start","_end","Error","transformColumnRange","transformCellAddress","dependencyAddress","absoluteDependencySheet","absoluteDependencyAddress","toSimpleColumnAddress","col","columnStart","columnEnd","shiftedByColumns","numberOfColumns","isColumnAbsolute","REF","fixNodeAddress","address","Object","assign","startSheet","actualStart","actualEnd","startSCA","endSCA","newStart","newEnd"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/dependencyTransformers/RemoveColumnsTransformer.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { absoluteSheetReference, ErrorType } from \"../Cell.mjs\";\nimport { Transformer } from \"./Transformer.mjs\";\nexport class RemoveColumnsTransformer extends Transformer {\n  constructor(columnsSpan) {\n    super();\n    this.columnsSpan = columnsSpan;\n  }\n  get sheet() {\n    return this.columnsSpan.sheet;\n  }\n  isIrreversible() {\n    return true;\n  }\n  transformRowRangeAst(ast, _formulaAddress) {\n    return ast;\n  }\n  transformCellRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformRowRange(_start, _end, _formulaAddress) {\n    throw Error('Not implemented');\n  }\n  transformColumnRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformCellAddress(dependencyAddress, formulaAddress) {\n    const absoluteDependencySheet = absoluteSheetReference(dependencyAddress, formulaAddress);\n    // Case 4\n    if (this.columnsSpan.sheet !== formulaAddress.sheet && this.columnsSpan.sheet !== absoluteDependencySheet) {\n      return false;\n    }\n    // Case 3 -- removed column in same sheet where dependency is but formula in different\n    if (this.columnsSpan.sheet !== formulaAddress.sheet && this.columnsSpan.sheet === absoluteDependencySheet) {\n      const absoluteDependencyAddress = dependencyAddress.toSimpleColumnAddress(formulaAddress);\n      if (absoluteDependencyAddress.col < this.columnsSpan.columnStart) {\n        // 3.ARa\n        return false;\n      } else if (absoluteDependencyAddress.col > this.columnsSpan.columnEnd) {\n        // 3.ARb\n        return dependencyAddress.shiftedByColumns(-this.columnsSpan.numberOfColumns);\n      }\n    }\n    // Case 2 -- removed column in same sheet where formula but dependency in different sheet\n    if (this.columnsSpan.sheet === formulaAddress.sheet && this.columnsSpan.sheet !== absoluteDependencySheet) {\n      if (dependencyAddress.isColumnAbsolute()) {\n        // 2.A\n        return false;\n      } else {\n        if (formulaAddress.col < this.columnsSpan.columnStart) {\n          // 2.Ra\n          return false;\n        } else if (formulaAddress.col > this.columnsSpan.columnEnd) {\n          // 2.Rb\n          return dependencyAddress.shiftedByColumns(this.columnsSpan.numberOfColumns);\n        }\n      }\n    }\n    // Case 1 -- same sheet\n    if (this.columnsSpan.sheet === formulaAddress.sheet && this.columnsSpan.sheet === absoluteDependencySheet) {\n      if (dependencyAddress.isColumnAbsolute()) {\n        if (dependencyAddress.col < this.columnsSpan.columnStart) {\n          // 1.Aa\n          return false;\n        } else if (dependencyAddress.col > this.columnsSpan.columnEnd) {\n          // 1.Ab\n          return dependencyAddress.shiftedByColumns(-this.columnsSpan.numberOfColumns);\n        }\n      } else {\n        const absoluteDependencyAddress = dependencyAddress.toSimpleColumnAddress(formulaAddress);\n        if (absoluteDependencyAddress.col < this.columnsSpan.columnStart) {\n          if (formulaAddress.col < this.columnsSpan.columnStart) {\n            // 1.Raa\n            return false;\n          } else if (formulaAddress.col > this.columnsSpan.columnEnd) {\n            // 1.Rab\n            return dependencyAddress.shiftedByColumns(this.columnsSpan.numberOfColumns);\n          }\n        } else if (absoluteDependencyAddress.col > this.columnsSpan.columnEnd) {\n          if (formulaAddress.col < this.columnsSpan.columnStart) {\n            // 1.Rba\n            return dependencyAddress.shiftedByColumns(-this.columnsSpan.numberOfColumns);\n          } else if (formulaAddress.col > this.columnsSpan.columnEnd) {\n            // 1.Rbb\n            return false;\n          }\n        }\n      }\n    }\n    // 1.Ac, 1.Rca, 1.Rcb, 3.Ac, 3.Rca, 3.Rcb\n    return ErrorType.REF;\n  }\n  fixNodeAddress(address) {\n    if (this.columnsSpan.sheet === address.sheet && this.columnsSpan.columnStart <= address.col) {\n      return Object.assign(Object.assign({}, address), {\n        col: address.col - this.columnsSpan.numberOfColumns\n      });\n    } else {\n      return address;\n    }\n  }\n  transformRange(start, end, formulaAddress) {\n    const startSheet = absoluteSheetReference(start, formulaAddress);\n    let actualStart = start;\n    let actualEnd = end;\n    if (this.columnsSpan.sheet === startSheet) {\n      const startSCA = start.toSimpleColumnAddress(formulaAddress);\n      const endSCA = end.toSimpleColumnAddress(formulaAddress);\n      if (this.columnsSpan.columnStart <= startSCA.col && this.columnsSpan.columnEnd >= endSCA.col) {\n        return ErrorType.REF;\n      }\n      if (startSCA.col >= this.columnsSpan.columnStart && startSCA.col <= this.columnsSpan.columnEnd) {\n        actualStart = start.shiftedByColumns(this.columnsSpan.columnEnd - startSCA.col + 1);\n      }\n      if (endSCA.col >= this.columnsSpan.columnStart && endSCA.col <= this.columnsSpan.columnEnd) {\n        actualEnd = end.shiftedByColumns(-(endSCA.col - this.columnsSpan.columnStart + 1));\n      }\n    }\n    const newStart = this.transformCellAddress(actualStart, formulaAddress);\n    const newEnd = this.transformCellAddress(actualEnd, formulaAddress);\n    if (newStart === false && newEnd === false) {\n      return [actualStart, actualEnd];\n    } else if (newStart === ErrorType.REF || newEnd === ErrorType.REF) {\n      throw Error('Cannot happen');\n    } else {\n      return [newStart || actualStart, newEnd || actualEnd];\n    }\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}