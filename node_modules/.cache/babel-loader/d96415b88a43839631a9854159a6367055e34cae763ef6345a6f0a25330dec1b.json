{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from \"./AbsoluteCellRange.mjs\";\nimport { absolutizeDependencies } from \"./absolutizeDependencies.mjs\";\nimport { CellError, ErrorType } from \"./Cell.mjs\";\nimport { ContentChanges } from \"./ContentChanges.mjs\";\nimport { ArrayVertex, RangeVertex } from \"./DependencyGraph/index.mjs\";\nimport { FormulaVertex } from \"./DependencyGraph/FormulaCellVertex.mjs\";\nimport { InterpreterState } from \"./interpreter/InterpreterState.mjs\";\nimport { EmptyValue, getRawValue } from \"./interpreter/InterpreterValue.mjs\";\nimport { SimpleRangeValue } from \"./SimpleRangeValue.mjs\";\nimport { StatType } from \"./statistics/index.mjs\";\nexport class Evaluator {\n  constructor(config, stats, interpreter, lazilyTransformingAstService, dependencyGraph, columnSearch) {\n    this.config = config;\n    this.stats = stats;\n    this.interpreter = interpreter;\n    this.lazilyTransformingAstService = lazilyTransformingAstService;\n    this.dependencyGraph = dependencyGraph;\n    this.columnSearch = columnSearch;\n  }\n  run() {\n    this.stats.start(StatType.TOP_SORT);\n    const {\n      sorted,\n      cycled\n    } = this.dependencyGraph.topSortWithScc();\n    this.stats.end(StatType.TOP_SORT);\n    this.stats.measure(StatType.EVALUATION, () => {\n      this.recomputeFormulas(cycled, sorted);\n    });\n  }\n  partialRun(vertices) {\n    const changes = ContentChanges.empty();\n    this.stats.measure(StatType.EVALUATION, () => {\n      this.dependencyGraph.graph.getTopSortedWithSccSubgraphFrom(vertices, vertex => {\n        if (vertex instanceof FormulaVertex) {\n          const currentValue = vertex.isComputed() ? vertex.getCellValue() : undefined;\n          const newCellValue = this.recomputeFormulaVertexValue(vertex);\n          if (newCellValue !== currentValue) {\n            const address = vertex.getAddress(this.lazilyTransformingAstService);\n            changes.addChange(newCellValue, address);\n            this.columnSearch.change(getRawValue(currentValue), getRawValue(newCellValue), address);\n            return true;\n          }\n          return false;\n        } else if (vertex instanceof RangeVertex) {\n          vertex.clearCache();\n          return true;\n        } else {\n          return true;\n        }\n      }, vertex => {\n        if (vertex instanceof RangeVertex) {\n          vertex.clearCache();\n        } else if (vertex instanceof FormulaVertex) {\n          const address = vertex.getAddress(this.lazilyTransformingAstService);\n          this.columnSearch.remove(getRawValue(vertex.valueOrUndef()), address);\n          const error = new CellError(ErrorType.CYCLE, undefined, vertex);\n          vertex.setCellValue(error);\n          changes.addChange(error, address);\n        }\n      });\n    });\n    return changes;\n  }\n  runAndForget(ast, address, dependencies) {\n    const tmpRanges = [];\n    for (const dep of absolutizeDependencies(dependencies, address)) {\n      if (dep instanceof AbsoluteCellRange) {\n        const range = dep;\n        if (this.dependencyGraph.getRange(range.start, range.end) === undefined) {\n          const rangeVertex = new RangeVertex(range);\n          this.dependencyGraph.rangeMapping.setRange(rangeVertex);\n          tmpRanges.push(rangeVertex);\n        }\n      }\n    }\n    const ret = this.evaluateAstToCellValue(ast, new InterpreterState(address, this.config.useArrayArithmetic));\n    tmpRanges.forEach(rangeVertex => {\n      this.dependencyGraph.rangeMapping.removeRange(rangeVertex);\n    });\n    return ret;\n  }\n  /**\r\n   * Recalculates formulas in the topological sort order\r\n   */\n  recomputeFormulas(cycled, sorted) {\n    cycled.forEach(vertex => {\n      if (vertex instanceof FormulaVertex) {\n        vertex.setCellValue(new CellError(ErrorType.CYCLE, undefined, vertex));\n      }\n    });\n    sorted.forEach(vertex => {\n      if (vertex instanceof FormulaVertex) {\n        const newCellValue = this.recomputeFormulaVertexValue(vertex);\n        const address = vertex.getAddress(this.lazilyTransformingAstService);\n        this.columnSearch.add(getRawValue(newCellValue), address);\n      } else if (vertex instanceof RangeVertex) {\n        vertex.clearCache();\n      }\n    });\n  }\n  recomputeFormulaVertexValue(vertex) {\n    const address = vertex.getAddress(this.lazilyTransformingAstService);\n    if (vertex instanceof ArrayVertex && (vertex.array.size.isRef || !this.dependencyGraph.isThereSpaceForArray(vertex))) {\n      return vertex.setNoSpace();\n    } else {\n      const formula = vertex.getFormula(this.lazilyTransformingAstService);\n      const newCellValue = this.evaluateAstToCellValue(formula, new InterpreterState(address, this.config.useArrayArithmetic, vertex));\n      return vertex.setCellValue(newCellValue);\n    }\n  }\n  evaluateAstToCellValue(ast, state) {\n    const interpreterValue = this.interpreter.evaluateAst(ast, state);\n    if (interpreterValue instanceof SimpleRangeValue) {\n      return interpreterValue;\n    } else if (interpreterValue === EmptyValue && this.config.evaluateNullToZero) {\n      return 0;\n    } else {\n      return interpreterValue;\n    }\n  }\n}","map":{"version":3,"names":["AbsoluteCellRange","absolutizeDependencies","CellError","ErrorType","ContentChanges","ArrayVertex","RangeVertex","FormulaVertex","InterpreterState","EmptyValue","getRawValue","SimpleRangeValue","StatType","Evaluator","constructor","config","stats","interpreter","lazilyTransformingAstService","dependencyGraph","columnSearch","run","start","TOP_SORT","sorted","cycled","topSortWithScc","end","measure","EVALUATION","recomputeFormulas","partialRun","vertices","changes","empty","graph","getTopSortedWithSccSubgraphFrom","vertex","currentValue","isComputed","getCellValue","undefined","newCellValue","recomputeFormulaVertexValue","address","getAddress","addChange","change","clearCache","remove","valueOrUndef","error","CYCLE","setCellValue","runAndForget","ast","dependencies","tmpRanges","dep","range","getRange","rangeVertex","rangeMapping","setRange","push","ret","evaluateAstToCellValue","useArrayArithmetic","forEach","removeRange","add","array","size","isRef","isThereSpaceForArray","setNoSpace","formula","getFormula","state","interpreterValue","evaluateAst","evaluateNullToZero"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/Evaluator.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from \"./AbsoluteCellRange.mjs\";\nimport { absolutizeDependencies } from \"./absolutizeDependencies.mjs\";\nimport { CellError, ErrorType } from \"./Cell.mjs\";\nimport { ContentChanges } from \"./ContentChanges.mjs\";\nimport { ArrayVertex, RangeVertex } from \"./DependencyGraph/index.mjs\";\nimport { FormulaVertex } from \"./DependencyGraph/FormulaCellVertex.mjs\";\nimport { InterpreterState } from \"./interpreter/InterpreterState.mjs\";\nimport { EmptyValue, getRawValue } from \"./interpreter/InterpreterValue.mjs\";\nimport { SimpleRangeValue } from \"./SimpleRangeValue.mjs\";\nimport { StatType } from \"./statistics/index.mjs\";\nexport class Evaluator {\n  constructor(config, stats, interpreter, lazilyTransformingAstService, dependencyGraph, columnSearch) {\n    this.config = config;\n    this.stats = stats;\n    this.interpreter = interpreter;\n    this.lazilyTransformingAstService = lazilyTransformingAstService;\n    this.dependencyGraph = dependencyGraph;\n    this.columnSearch = columnSearch;\n  }\n  run() {\n    this.stats.start(StatType.TOP_SORT);\n    const {\n      sorted,\n      cycled\n    } = this.dependencyGraph.topSortWithScc();\n    this.stats.end(StatType.TOP_SORT);\n    this.stats.measure(StatType.EVALUATION, () => {\n      this.recomputeFormulas(cycled, sorted);\n    });\n  }\n  partialRun(vertices) {\n    const changes = ContentChanges.empty();\n    this.stats.measure(StatType.EVALUATION, () => {\n      this.dependencyGraph.graph.getTopSortedWithSccSubgraphFrom(vertices, vertex => {\n        if (vertex instanceof FormulaVertex) {\n          const currentValue = vertex.isComputed() ? vertex.getCellValue() : undefined;\n          const newCellValue = this.recomputeFormulaVertexValue(vertex);\n          if (newCellValue !== currentValue) {\n            const address = vertex.getAddress(this.lazilyTransformingAstService);\n            changes.addChange(newCellValue, address);\n            this.columnSearch.change(getRawValue(currentValue), getRawValue(newCellValue), address);\n            return true;\n          }\n          return false;\n        } else if (vertex instanceof RangeVertex) {\n          vertex.clearCache();\n          return true;\n        } else {\n          return true;\n        }\n      }, vertex => {\n        if (vertex instanceof RangeVertex) {\n          vertex.clearCache();\n        } else if (vertex instanceof FormulaVertex) {\n          const address = vertex.getAddress(this.lazilyTransformingAstService);\n          this.columnSearch.remove(getRawValue(vertex.valueOrUndef()), address);\n          const error = new CellError(ErrorType.CYCLE, undefined, vertex);\n          vertex.setCellValue(error);\n          changes.addChange(error, address);\n        }\n      });\n    });\n    return changes;\n  }\n  runAndForget(ast, address, dependencies) {\n    const tmpRanges = [];\n    for (const dep of absolutizeDependencies(dependencies, address)) {\n      if (dep instanceof AbsoluteCellRange) {\n        const range = dep;\n        if (this.dependencyGraph.getRange(range.start, range.end) === undefined) {\n          const rangeVertex = new RangeVertex(range);\n          this.dependencyGraph.rangeMapping.setRange(rangeVertex);\n          tmpRanges.push(rangeVertex);\n        }\n      }\n    }\n    const ret = this.evaluateAstToCellValue(ast, new InterpreterState(address, this.config.useArrayArithmetic));\n    tmpRanges.forEach(rangeVertex => {\n      this.dependencyGraph.rangeMapping.removeRange(rangeVertex);\n    });\n    return ret;\n  }\n  /**\r\n   * Recalculates formulas in the topological sort order\r\n   */\n  recomputeFormulas(cycled, sorted) {\n    cycled.forEach(vertex => {\n      if (vertex instanceof FormulaVertex) {\n        vertex.setCellValue(new CellError(ErrorType.CYCLE, undefined, vertex));\n      }\n    });\n    sorted.forEach(vertex => {\n      if (vertex instanceof FormulaVertex) {\n        const newCellValue = this.recomputeFormulaVertexValue(vertex);\n        const address = vertex.getAddress(this.lazilyTransformingAstService);\n        this.columnSearch.add(getRawValue(newCellValue), address);\n      } else if (vertex instanceof RangeVertex) {\n        vertex.clearCache();\n      }\n    });\n  }\n  recomputeFormulaVertexValue(vertex) {\n    const address = vertex.getAddress(this.lazilyTransformingAstService);\n    if (vertex instanceof ArrayVertex && (vertex.array.size.isRef || !this.dependencyGraph.isThereSpaceForArray(vertex))) {\n      return vertex.setNoSpace();\n    } else {\n      const formula = vertex.getFormula(this.lazilyTransformingAstService);\n      const newCellValue = this.evaluateAstToCellValue(formula, new InterpreterState(address, this.config.useArrayArithmetic, vertex));\n      return vertex.setCellValue(newCellValue);\n    }\n  }\n  evaluateAstToCellValue(ast, state) {\n    const interpreterValue = this.interpreter.evaluateAst(ast, state);\n    if (interpreterValue instanceof SimpleRangeValue) {\n      return interpreterValue;\n    } else if (interpreterValue === EmptyValue && this.config.evaluateNullToZero) {\n      return 0;\n    } else {\n      return interpreterValue;\n    }\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}