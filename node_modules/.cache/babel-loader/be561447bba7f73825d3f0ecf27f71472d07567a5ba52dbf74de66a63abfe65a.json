{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { absoluteSheetReference, ErrorType } from \"../Cell.mjs\";\nimport { Transformer } from \"./Transformer.mjs\";\nexport class AddColumnsTransformer extends Transformer {\n  constructor(columnsSpan) {\n    super();\n    this.columnsSpan = columnsSpan;\n  }\n  get sheet() {\n    return this.columnsSpan.sheet;\n  }\n  isIrreversible() {\n    return false;\n  }\n  transformRowRangeAst(ast, _formulaAddress) {\n    return ast;\n  }\n  transformCellRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformRowRange(_start, _end, _formulaAddress) {\n    throw Error('Not implemented');\n  }\n  transformColumnRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformCellAddress(dependencyAddress, formulaAddress) {\n    const absoluteDependencySheet = absoluteSheetReference(dependencyAddress, formulaAddress);\n    // Case 4 and 5\n    if (absoluteDependencySheet !== this.columnsSpan.sheet && formulaAddress.sheet !== this.columnsSpan.sheet) {\n      return false;\n    }\n    const absolutizedDependencyAddress = dependencyAddress.toSimpleColumnAddress(formulaAddress);\n    // Case 3\n    if (absoluteDependencySheet === this.columnsSpan.sheet && formulaAddress.sheet !== this.columnsSpan.sheet) {\n      if (this.columnsSpan.columnStart <= absolutizedDependencyAddress.col) {\n        return dependencyAddress.shiftedByColumns(this.columnsSpan.numberOfColumns);\n      } else {\n        return false;\n      }\n    }\n    // Case 2\n    if (formulaAddress.sheet === this.columnsSpan.sheet && absoluteDependencySheet !== this.columnsSpan.sheet) {\n      if (dependencyAddress.isColumnAbsolute()) {\n        return false;\n      }\n      if (formulaAddress.col < this.columnsSpan.columnStart) {\n        return false;\n      }\n      return dependencyAddress.shiftedByColumns(-this.columnsSpan.numberOfColumns);\n    }\n    // Case 1\n    if (dependencyAddress.isColumnAbsolute()) {\n      if (dependencyAddress.col < this.columnsSpan.columnStart) {\n        // Case Aa\n        return false;\n      } else {\n        // Case Ab\n        return dependencyAddress.shiftedByColumns(this.columnsSpan.numberOfColumns);\n      }\n    } else {\n      const absolutizedDependencyAddress = dependencyAddress.toSimpleColumnAddress(formulaAddress);\n      if (absolutizedDependencyAddress.col < this.columnsSpan.columnStart) {\n        if (formulaAddress.col < this.columnsSpan.columnStart) {\n          // Case Raa\n          return false;\n        } else {\n          // Case Rab\n          return dependencyAddress.shiftedByColumns(-this.columnsSpan.numberOfColumns);\n        }\n      } else {\n        if (formulaAddress.col < this.columnsSpan.columnStart) {\n          // Case Rba\n          return dependencyAddress.shiftedByColumns(this.columnsSpan.numberOfColumns);\n        } else {\n          // Case Rbb\n          return false;\n        }\n      }\n    }\n  }\n  fixNodeAddress(address) {\n    if (this.columnsSpan.sheet === address.sheet && this.columnsSpan.columnStart <= address.col) {\n      return Object.assign(Object.assign({}, address), {\n        col: address.col + this.columnsSpan.numberOfColumns\n      });\n    } else {\n      return address;\n    }\n  }\n  transformRange(start, end, formulaAddress) {\n    const newStart = this.transformCellAddress(start, formulaAddress);\n    const newEnd = this.transformCellAddress(end, formulaAddress);\n    if (newStart === ErrorType.REF || newEnd === ErrorType.REF) {\n      return ErrorType.REF;\n    } else if (newStart || newEnd) {\n      return [newStart || start, newEnd || end];\n    } else {\n      return false;\n    }\n  }\n}","map":{"version":3,"names":["absoluteSheetReference","ErrorType","Transformer","AddColumnsTransformer","constructor","columnsSpan","sheet","isIrreversible","transformRowRangeAst","ast","_formulaAddress","transformCellRange","start","end","formulaAddress","transformRange","transformRowRange","_start","_end","Error","transformColumnRange","transformCellAddress","dependencyAddress","absoluteDependencySheet","absolutizedDependencyAddress","toSimpleColumnAddress","columnStart","col","shiftedByColumns","numberOfColumns","isColumnAbsolute","fixNodeAddress","address","Object","assign","newStart","newEnd","REF"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/dependencyTransformers/AddColumnsTransformer.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { absoluteSheetReference, ErrorType } from \"../Cell.mjs\";\nimport { Transformer } from \"./Transformer.mjs\";\nexport class AddColumnsTransformer extends Transformer {\n  constructor(columnsSpan) {\n    super();\n    this.columnsSpan = columnsSpan;\n  }\n  get sheet() {\n    return this.columnsSpan.sheet;\n  }\n  isIrreversible() {\n    return false;\n  }\n  transformRowRangeAst(ast, _formulaAddress) {\n    return ast;\n  }\n  transformCellRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformRowRange(_start, _end, _formulaAddress) {\n    throw Error('Not implemented');\n  }\n  transformColumnRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformCellAddress(dependencyAddress, formulaAddress) {\n    const absoluteDependencySheet = absoluteSheetReference(dependencyAddress, formulaAddress);\n    // Case 4 and 5\n    if (absoluteDependencySheet !== this.columnsSpan.sheet && formulaAddress.sheet !== this.columnsSpan.sheet) {\n      return false;\n    }\n    const absolutizedDependencyAddress = dependencyAddress.toSimpleColumnAddress(formulaAddress);\n    // Case 3\n    if (absoluteDependencySheet === this.columnsSpan.sheet && formulaAddress.sheet !== this.columnsSpan.sheet) {\n      if (this.columnsSpan.columnStart <= absolutizedDependencyAddress.col) {\n        return dependencyAddress.shiftedByColumns(this.columnsSpan.numberOfColumns);\n      } else {\n        return false;\n      }\n    }\n    // Case 2\n    if (formulaAddress.sheet === this.columnsSpan.sheet && absoluteDependencySheet !== this.columnsSpan.sheet) {\n      if (dependencyAddress.isColumnAbsolute()) {\n        return false;\n      }\n      if (formulaAddress.col < this.columnsSpan.columnStart) {\n        return false;\n      }\n      return dependencyAddress.shiftedByColumns(-this.columnsSpan.numberOfColumns);\n    }\n    // Case 1\n    if (dependencyAddress.isColumnAbsolute()) {\n      if (dependencyAddress.col < this.columnsSpan.columnStart) {\n        // Case Aa\n        return false;\n      } else {\n        // Case Ab\n        return dependencyAddress.shiftedByColumns(this.columnsSpan.numberOfColumns);\n      }\n    } else {\n      const absolutizedDependencyAddress = dependencyAddress.toSimpleColumnAddress(formulaAddress);\n      if (absolutizedDependencyAddress.col < this.columnsSpan.columnStart) {\n        if (formulaAddress.col < this.columnsSpan.columnStart) {\n          // Case Raa\n          return false;\n        } else {\n          // Case Rab\n          return dependencyAddress.shiftedByColumns(-this.columnsSpan.numberOfColumns);\n        }\n      } else {\n        if (formulaAddress.col < this.columnsSpan.columnStart) {\n          // Case Rba\n          return dependencyAddress.shiftedByColumns(this.columnsSpan.numberOfColumns);\n        } else {\n          // Case Rbb\n          return false;\n        }\n      }\n    }\n  }\n  fixNodeAddress(address) {\n    if (this.columnsSpan.sheet === address.sheet && this.columnsSpan.columnStart <= address.col) {\n      return Object.assign(Object.assign({}, address), {\n        col: address.col + this.columnsSpan.numberOfColumns\n      });\n    } else {\n      return address;\n    }\n  }\n  transformRange(start, end, formulaAddress) {\n    const newStart = this.transformCellAddress(start, formulaAddress);\n    const newEnd = this.transformCellAddress(end, formulaAddress);\n    if (newStart === ErrorType.REF || newEnd === ErrorType.REF) {\n      return ErrorType.REF;\n    } else if (newStart || newEnd) {\n      return [newStart || start, newEnd || end];\n    } else {\n      return false;\n    }\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}