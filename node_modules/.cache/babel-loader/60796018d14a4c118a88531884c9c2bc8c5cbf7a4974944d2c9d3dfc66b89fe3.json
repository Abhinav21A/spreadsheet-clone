{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from \"../AbsoluteCellRange.mjs\";\nimport { simpleCellAddress } from \"../Cell.mjs\";\n/**\r\n * Mapping from address ranges to range vertices\r\n */\nexport class RangeMapping {\n  constructor() {\n    /** Map in which actual data is stored. */\n    this.rangeMapping = new Map();\n  }\n  getMappingSize(sheet) {\n    var _a, _b;\n    return (_b = (_a = this.rangeMapping.get(sheet)) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0;\n  }\n  /**\r\n   * Saves range vertex\r\n   *\r\n   * @param vertex - vertex to save\r\n   */\n  setRange(vertex) {\n    let sheetMap = this.rangeMapping.get(vertex.getStart().sheet);\n    if (sheetMap === undefined) {\n      sheetMap = new Map();\n      this.rangeMapping.set(vertex.getStart().sheet, sheetMap);\n    }\n    const key = keyFromAddresses(vertex.getStart(), vertex.getEnd());\n    sheetMap.set(key, vertex);\n  }\n  removeRange(vertex) {\n    const sheet = vertex.getStart().sheet;\n    const sheetMap = this.rangeMapping.get(sheet);\n    if (sheetMap === undefined) {\n      return;\n    }\n    const key = keyFromAddresses(vertex.getStart(), vertex.getEnd());\n    sheetMap.delete(key);\n    if (sheetMap.size === 0) {\n      this.rangeMapping.delete(sheet);\n    }\n  }\n  /**\r\n   * Returns associated vertex for given range\r\n   *\r\n   * @param start - top-left corner of the range\r\n   * @param end - bottom-right corner of the range\r\n   */\n  getRange(start, end) {\n    const sheetMap = this.rangeMapping.get(start.sheet);\n    const key = keyFromAddresses(start, end);\n    return sheetMap === null || sheetMap === void 0 ? void 0 : sheetMap.get(key);\n  }\n  fetchRange(start, end) {\n    const maybeRange = this.getRange(start, end);\n    if (!maybeRange) {\n      throw Error('Range does not exist');\n    }\n    return maybeRange;\n  }\n  truncateRanges(span, coordinate) {\n    const verticesToRemove = Array();\n    const updated = Array();\n    const verticesWithChangedSize = Array();\n    const sheet = span.sheet;\n    for (const [key, vertex] of this.entriesFromSheet(span.sheet)) {\n      const range = vertex.range;\n      if (span.start <= coordinate(vertex.range.end)) {\n        range.removeSpan(span);\n        if (range.shouldBeRemoved()) {\n          this.removeByKey(sheet, key);\n          verticesToRemove.push(vertex);\n        } else {\n          updated.push([key, vertex]);\n        }\n        verticesWithChangedSize.push(vertex);\n      }\n    }\n    const verticesToMerge = [];\n    updated.sort((left, right) => compareBy(left[1], right[1], coordinate));\n    for (const [oldKey, vertex] of updated) {\n      const newKey = keyFromRange(vertex.range);\n      if (newKey === oldKey) {\n        continue;\n      }\n      const existingVertex = this.getByKey(sheet, newKey);\n      this.removeByKey(sheet, oldKey);\n      if (existingVertex !== undefined && vertex != existingVertex) {\n        verticesToMerge.push([existingVertex, vertex]);\n      } else {\n        this.setRange(vertex);\n      }\n    }\n    return {\n      verticesToRemove,\n      verticesToMerge,\n      verticesWithChangedSize\n    };\n  }\n  moveAllRangesInSheetAfterRowByRows(sheet, row, numberOfRows) {\n    return this.updateVerticesFromSheet(sheet, (key, vertex) => {\n      if (row <= vertex.start.row) {\n        vertex.range.shiftByRows(numberOfRows);\n        return {\n          changedSize: false,\n          vertex: vertex\n        };\n      } else if (row > vertex.start.row && row <= vertex.end.row) {\n        vertex.range.expandByRows(numberOfRows);\n        return {\n          changedSize: true,\n          vertex: vertex\n        };\n      } else {\n        return undefined;\n      }\n    });\n  }\n  moveAllRangesInSheetAfterColumnByColumns(sheet, column, numberOfColumns) {\n    return this.updateVerticesFromSheet(sheet, (key, vertex) => {\n      if (column <= vertex.start.col) {\n        vertex.range.shiftByColumns(numberOfColumns);\n        return {\n          changedSize: false,\n          vertex: vertex\n        };\n      } else if (column > vertex.start.col && column <= vertex.end.col) {\n        vertex.range.expandByColumns(numberOfColumns);\n        return {\n          changedSize: true,\n          vertex: vertex\n        };\n      } else {\n        return undefined;\n      }\n    });\n  }\n  moveRangesInsideSourceRange(sourceRange, toRight, toBottom, toSheet) {\n    this.updateVerticesFromSheet(sourceRange.sheet, (key, vertex) => {\n      if (sourceRange.containsRange(vertex.range)) {\n        vertex.range.shiftByColumns(toRight);\n        vertex.range.shiftByRows(toBottom);\n        vertex.range.moveToSheet(toSheet);\n        return {\n          changedSize: false,\n          vertex: vertex\n        };\n      } else {\n        return undefined;\n      }\n    });\n  }\n  removeRangesInSheet(sheet) {\n    if (this.rangeMapping.has(sheet)) {\n      const ranges = this.rangeMapping.get(sheet).values();\n      this.rangeMapping.delete(sheet);\n      return ranges;\n    }\n    return [][Symbol.iterator]();\n  }\n  *rangesInSheet(sheet) {\n    const sheetMap = this.rangeMapping.get(sheet);\n    if (!sheetMap) {\n      return;\n    }\n    yield* sheetMap.values();\n  }\n  *rangeVerticesContainedInRange(sourceRange) {\n    for (const rangeVertex of this.rangesInSheet(sourceRange.sheet)) {\n      if (sourceRange.containsRange(rangeVertex.range)) {\n        yield rangeVertex;\n      }\n    }\n  }\n  /**\r\n   * Finds smaller range does have own vertex.\r\n   *\r\n   * @param range\r\n   */\n  findSmallerRange(range) {\n    if (range.height() > 1 && Number.isFinite(range.height())) {\n      const valuesRangeEndRowLess = simpleCellAddress(range.end.sheet, range.end.col, range.end.row - 1);\n      const rowLessVertex = this.getRange(range.start, valuesRangeEndRowLess);\n      if (rowLessVertex !== undefined) {\n        const restRange = AbsoluteCellRange.fromSimpleCellAddresses(simpleCellAddress(range.start.sheet, range.start.col, range.end.row), range.end);\n        return {\n          smallerRangeVertex: rowLessVertex,\n          restRange\n        };\n      }\n    }\n    return {\n      restRange: range\n    };\n  }\n  *entriesFromSheet(sheet) {\n    const sheetMap = this.rangeMapping.get(sheet);\n    if (!sheetMap) {\n      return;\n    }\n    yield* sheetMap.entries();\n  }\n  removeByKey(sheet, key) {\n    this.rangeMapping.get(sheet).delete(key);\n  }\n  getByKey(sheet, key) {\n    var _a;\n    return (_a = this.rangeMapping.get(sheet)) === null || _a === void 0 ? void 0 : _a.get(key);\n  }\n  updateVerticesFromSheet(sheet, fn) {\n    const updated = Array();\n    for (const [key, vertex] of this.entriesFromSheet(sheet)) {\n      const result = fn(key, vertex);\n      if (result !== undefined) {\n        this.removeByKey(sheet, key);\n        updated.push(result);\n      }\n    }\n    updated.forEach(entry => {\n      this.setRange(entry.vertex);\n    });\n    return {\n      verticesWithChangedSize: updated.filter(entry => entry.changedSize).map(entry => entry.vertex)\n    };\n  }\n}\nfunction keyFromAddresses(start, end) {\n  return `${start.col},${start.row},${end.col},${end.row}`;\n}\nfunction keyFromRange(range) {\n  return keyFromAddresses(range.start, range.end);\n}\nconst compareBy = (left, right, coordinate) => {\n  const leftStart = coordinate(left.range.start);\n  const rightStart = coordinate(left.range.start);\n  if (leftStart === rightStart) {\n    const leftEnd = coordinate(left.range.end);\n    const rightEnd = coordinate(right.range.end);\n    return leftEnd - rightEnd;\n  } else {\n    return leftStart - rightStart;\n  }\n};","map":{"version":3,"names":["AbsoluteCellRange","simpleCellAddress","RangeMapping","constructor","rangeMapping","Map","getMappingSize","sheet","_a","_b","get","size","setRange","vertex","sheetMap","getStart","undefined","set","key","keyFromAddresses","getEnd","removeRange","delete","getRange","start","end","fetchRange","maybeRange","Error","truncateRanges","span","coordinate","verticesToRemove","Array","updated","verticesWithChangedSize","entriesFromSheet","range","removeSpan","shouldBeRemoved","removeByKey","push","verticesToMerge","sort","left","right","compareBy","oldKey","newKey","keyFromRange","existingVertex","getByKey","moveAllRangesInSheetAfterRowByRows","row","numberOfRows","updateVerticesFromSheet","shiftByRows","changedSize","expandByRows","moveAllRangesInSheetAfterColumnByColumns","column","numberOfColumns","col","shiftByColumns","expandByColumns","moveRangesInsideSourceRange","sourceRange","toRight","toBottom","toSheet","containsRange","moveToSheet","removeRangesInSheet","has","ranges","values","Symbol","iterator","rangesInSheet","rangeVerticesContainedInRange","rangeVertex","findSmallerRange","height","Number","isFinite","valuesRangeEndRowLess","rowLessVertex","restRange","fromSimpleCellAddresses","smallerRangeVertex","entries","fn","result","forEach","entry","filter","map","leftStart","rightStart","leftEnd","rightEnd"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/DependencyGraph/RangeMapping.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from \"../AbsoluteCellRange.mjs\";\nimport { simpleCellAddress } from \"../Cell.mjs\";\n/**\r\n * Mapping from address ranges to range vertices\r\n */\nexport class RangeMapping {\n  constructor() {\n    /** Map in which actual data is stored. */\n    this.rangeMapping = new Map();\n  }\n  getMappingSize(sheet) {\n    var _a, _b;\n    return (_b = (_a = this.rangeMapping.get(sheet)) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0;\n  }\n  /**\r\n   * Saves range vertex\r\n   *\r\n   * @param vertex - vertex to save\r\n   */\n  setRange(vertex) {\n    let sheetMap = this.rangeMapping.get(vertex.getStart().sheet);\n    if (sheetMap === undefined) {\n      sheetMap = new Map();\n      this.rangeMapping.set(vertex.getStart().sheet, sheetMap);\n    }\n    const key = keyFromAddresses(vertex.getStart(), vertex.getEnd());\n    sheetMap.set(key, vertex);\n  }\n  removeRange(vertex) {\n    const sheet = vertex.getStart().sheet;\n    const sheetMap = this.rangeMapping.get(sheet);\n    if (sheetMap === undefined) {\n      return;\n    }\n    const key = keyFromAddresses(vertex.getStart(), vertex.getEnd());\n    sheetMap.delete(key);\n    if (sheetMap.size === 0) {\n      this.rangeMapping.delete(sheet);\n    }\n  }\n  /**\r\n   * Returns associated vertex for given range\r\n   *\r\n   * @param start - top-left corner of the range\r\n   * @param end - bottom-right corner of the range\r\n   */\n  getRange(start, end) {\n    const sheetMap = this.rangeMapping.get(start.sheet);\n    const key = keyFromAddresses(start, end);\n    return sheetMap === null || sheetMap === void 0 ? void 0 : sheetMap.get(key);\n  }\n  fetchRange(start, end) {\n    const maybeRange = this.getRange(start, end);\n    if (!maybeRange) {\n      throw Error('Range does not exist');\n    }\n    return maybeRange;\n  }\n  truncateRanges(span, coordinate) {\n    const verticesToRemove = Array();\n    const updated = Array();\n    const verticesWithChangedSize = Array();\n    const sheet = span.sheet;\n    for (const [key, vertex] of this.entriesFromSheet(span.sheet)) {\n      const range = vertex.range;\n      if (span.start <= coordinate(vertex.range.end)) {\n        range.removeSpan(span);\n        if (range.shouldBeRemoved()) {\n          this.removeByKey(sheet, key);\n          verticesToRemove.push(vertex);\n        } else {\n          updated.push([key, vertex]);\n        }\n        verticesWithChangedSize.push(vertex);\n      }\n    }\n    const verticesToMerge = [];\n    updated.sort((left, right) => compareBy(left[1], right[1], coordinate));\n    for (const [oldKey, vertex] of updated) {\n      const newKey = keyFromRange(vertex.range);\n      if (newKey === oldKey) {\n        continue;\n      }\n      const existingVertex = this.getByKey(sheet, newKey);\n      this.removeByKey(sheet, oldKey);\n      if (existingVertex !== undefined && vertex != existingVertex) {\n        verticesToMerge.push([existingVertex, vertex]);\n      } else {\n        this.setRange(vertex);\n      }\n    }\n    return {\n      verticesToRemove,\n      verticesToMerge,\n      verticesWithChangedSize\n    };\n  }\n  moveAllRangesInSheetAfterRowByRows(sheet, row, numberOfRows) {\n    return this.updateVerticesFromSheet(sheet, (key, vertex) => {\n      if (row <= vertex.start.row) {\n        vertex.range.shiftByRows(numberOfRows);\n        return {\n          changedSize: false,\n          vertex: vertex\n        };\n      } else if (row > vertex.start.row && row <= vertex.end.row) {\n        vertex.range.expandByRows(numberOfRows);\n        return {\n          changedSize: true,\n          vertex: vertex\n        };\n      } else {\n        return undefined;\n      }\n    });\n  }\n  moveAllRangesInSheetAfterColumnByColumns(sheet, column, numberOfColumns) {\n    return this.updateVerticesFromSheet(sheet, (key, vertex) => {\n      if (column <= vertex.start.col) {\n        vertex.range.shiftByColumns(numberOfColumns);\n        return {\n          changedSize: false,\n          vertex: vertex\n        };\n      } else if (column > vertex.start.col && column <= vertex.end.col) {\n        vertex.range.expandByColumns(numberOfColumns);\n        return {\n          changedSize: true,\n          vertex: vertex\n        };\n      } else {\n        return undefined;\n      }\n    });\n  }\n  moveRangesInsideSourceRange(sourceRange, toRight, toBottom, toSheet) {\n    this.updateVerticesFromSheet(sourceRange.sheet, (key, vertex) => {\n      if (sourceRange.containsRange(vertex.range)) {\n        vertex.range.shiftByColumns(toRight);\n        vertex.range.shiftByRows(toBottom);\n        vertex.range.moveToSheet(toSheet);\n        return {\n          changedSize: false,\n          vertex: vertex\n        };\n      } else {\n        return undefined;\n      }\n    });\n  }\n  removeRangesInSheet(sheet) {\n    if (this.rangeMapping.has(sheet)) {\n      const ranges = this.rangeMapping.get(sheet).values();\n      this.rangeMapping.delete(sheet);\n      return ranges;\n    }\n    return [][Symbol.iterator]();\n  }\n  *rangesInSheet(sheet) {\n    const sheetMap = this.rangeMapping.get(sheet);\n    if (!sheetMap) {\n      return;\n    }\n    yield* sheetMap.values();\n  }\n  *rangeVerticesContainedInRange(sourceRange) {\n    for (const rangeVertex of this.rangesInSheet(sourceRange.sheet)) {\n      if (sourceRange.containsRange(rangeVertex.range)) {\n        yield rangeVertex;\n      }\n    }\n  }\n  /**\r\n   * Finds smaller range does have own vertex.\r\n   *\r\n   * @param range\r\n   */\n  findSmallerRange(range) {\n    if (range.height() > 1 && Number.isFinite(range.height())) {\n      const valuesRangeEndRowLess = simpleCellAddress(range.end.sheet, range.end.col, range.end.row - 1);\n      const rowLessVertex = this.getRange(range.start, valuesRangeEndRowLess);\n      if (rowLessVertex !== undefined) {\n        const restRange = AbsoluteCellRange.fromSimpleCellAddresses(simpleCellAddress(range.start.sheet, range.start.col, range.end.row), range.end);\n        return {\n          smallerRangeVertex: rowLessVertex,\n          restRange\n        };\n      }\n    }\n    return {\n      restRange: range\n    };\n  }\n  *entriesFromSheet(sheet) {\n    const sheetMap = this.rangeMapping.get(sheet);\n    if (!sheetMap) {\n      return;\n    }\n    yield* sheetMap.entries();\n  }\n  removeByKey(sheet, key) {\n    this.rangeMapping.get(sheet).delete(key);\n  }\n  getByKey(sheet, key) {\n    var _a;\n    return (_a = this.rangeMapping.get(sheet)) === null || _a === void 0 ? void 0 : _a.get(key);\n  }\n  updateVerticesFromSheet(sheet, fn) {\n    const updated = Array();\n    for (const [key, vertex] of this.entriesFromSheet(sheet)) {\n      const result = fn(key, vertex);\n      if (result !== undefined) {\n        this.removeByKey(sheet, key);\n        updated.push(result);\n      }\n    }\n    updated.forEach(entry => {\n      this.setRange(entry.vertex);\n    });\n    return {\n      verticesWithChangedSize: updated.filter(entry => entry.changedSize).map(entry => entry.vertex)\n    };\n  }\n}\nfunction keyFromAddresses(start, end) {\n  return `${start.col},${start.row},${end.col},${end.row}`;\n}\nfunction keyFromRange(range) {\n  return keyFromAddresses(range.start, range.end);\n}\nconst compareBy = (left, right, coordinate) => {\n  const leftStart = coordinate(left.range.start);\n  const rightStart = coordinate(left.range.start);\n  if (leftStart === rightStart) {\n    const leftEnd = coordinate(left.range.end);\n    const rightEnd = coordinate(right.range.end);\n    return leftEnd - rightEnd;\n  } else {\n    return leftStart - rightStart;\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}