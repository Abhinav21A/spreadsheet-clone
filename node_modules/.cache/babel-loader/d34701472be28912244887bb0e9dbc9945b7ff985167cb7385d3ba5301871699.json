{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { absoluteSheetReference, invalidSimpleColumnAddress, simpleColumnAddress } from \"../Cell.mjs\";\nimport { columnIndexToLabel } from \"./addressRepresentationConverters.mjs\";\nexport var ReferenceType;\n(function (ReferenceType) {\n  ReferenceType[\"RELATIVE\"] = \"RELATIVE\";\n  ReferenceType[\"ABSOLUTE\"] = \"ABSOLUTE\";\n})(ReferenceType || (ReferenceType = {}));\nexport class ColumnAddress {\n  constructor(type, col, sheet) {\n    this.type = type;\n    this.col = col;\n    this.sheet = sheet;\n  }\n  static absolute(column, sheet) {\n    return new ColumnAddress(ReferenceType.ABSOLUTE, column, sheet);\n  }\n  static relative(column, sheet) {\n    return new ColumnAddress(ReferenceType.RELATIVE, column, sheet);\n  }\n  static compareByAbsoluteAddress(baseAddress) {\n    return (colA, colB) => colA.toSimpleColumnAddress(baseAddress).col - colB.toSimpleColumnAddress(baseAddress).col;\n  }\n  isColumnAbsolute() {\n    return this.type === ReferenceType.ABSOLUTE;\n  }\n  isColumnRelative() {\n    return this.type === ReferenceType.RELATIVE;\n  }\n  isAbsolute() {\n    return this.type === ReferenceType.ABSOLUTE && this.sheet !== undefined;\n  }\n  moved(toSheet, toRight, _toBottom) {\n    const newSheet = this.sheet === undefined ? undefined : toSheet;\n    return new ColumnAddress(this.type, this.col + toRight, newSheet);\n  }\n  shiftedByColumns(numberOfColumns) {\n    return new ColumnAddress(this.type, this.col + numberOfColumns, this.sheet);\n  }\n  toSimpleColumnAddress(baseAddress) {\n    const sheet = absoluteSheetReference(this, baseAddress);\n    let column = this.col;\n    if (this.isColumnRelative()) {\n      column = baseAddress.col + this.col;\n    }\n    return simpleColumnAddress(sheet, column);\n  }\n  shiftRelativeDimensions(toRight, _toBottom) {\n    const col = this.isColumnRelative() ? this.col + toRight : this.col;\n    return new ColumnAddress(this.type, col, this.sheet);\n  }\n  shiftAbsoluteDimensions(toRight, _toBottom) {\n    const col = this.isColumnAbsolute() ? this.col + toRight : this.col;\n    return new ColumnAddress(this.type, col, this.sheet);\n  }\n  withSheet(sheet) {\n    return new ColumnAddress(this.type, this.col, sheet);\n  }\n  isInvalid(baseAddress) {\n    return this.toSimpleColumnAddress(baseAddress).col < 0;\n  }\n  hash(withSheet) {\n    const sheetPart = withSheet && this.sheet !== undefined ? `#${this.sheet}` : '';\n    switch (this.type) {\n      case ReferenceType.RELATIVE:\n        {\n          return `${sheetPart}#COLR${this.col}`;\n        }\n      case ReferenceType.ABSOLUTE:\n        {\n          return `${sheetPart}#COLA${this.col}`;\n        }\n    }\n  }\n  unparse(baseAddress) {\n    const simpleAddress = this.toSimpleColumnAddress(baseAddress);\n    if (invalidSimpleColumnAddress(simpleAddress)) {\n      return undefined;\n    }\n    const column = columnIndexToLabel(simpleAddress.col);\n    const dollar = this.type === ReferenceType.ABSOLUTE ? '$' : '';\n    return `${dollar}${column}`;\n  }\n  exceedsSheetSizeLimits(maxColumns) {\n    return this.col >= maxColumns;\n  }\n}","map":{"version":3,"names":["absoluteSheetReference","invalidSimpleColumnAddress","simpleColumnAddress","columnIndexToLabel","ReferenceType","ColumnAddress","constructor","type","col","sheet","absolute","column","ABSOLUTE","relative","RELATIVE","compareByAbsoluteAddress","baseAddress","colA","colB","toSimpleColumnAddress","isColumnAbsolute","isColumnRelative","isAbsolute","undefined","moved","toSheet","toRight","_toBottom","newSheet","shiftedByColumns","numberOfColumns","shiftRelativeDimensions","shiftAbsoluteDimensions","withSheet","isInvalid","hash","sheetPart","unparse","simpleAddress","dollar","exceedsSheetSizeLimits","maxColumns"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/parser/ColumnAddress.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { absoluteSheetReference, invalidSimpleColumnAddress, simpleColumnAddress } from \"../Cell.mjs\";\nimport { columnIndexToLabel } from \"./addressRepresentationConverters.mjs\";\nexport var ReferenceType;\n(function (ReferenceType) {\n  ReferenceType[\"RELATIVE\"] = \"RELATIVE\";\n  ReferenceType[\"ABSOLUTE\"] = \"ABSOLUTE\";\n})(ReferenceType || (ReferenceType = {}));\nexport class ColumnAddress {\n  constructor(type, col, sheet) {\n    this.type = type;\n    this.col = col;\n    this.sheet = sheet;\n  }\n  static absolute(column, sheet) {\n    return new ColumnAddress(ReferenceType.ABSOLUTE, column, sheet);\n  }\n  static relative(column, sheet) {\n    return new ColumnAddress(ReferenceType.RELATIVE, column, sheet);\n  }\n  static compareByAbsoluteAddress(baseAddress) {\n    return (colA, colB) => colA.toSimpleColumnAddress(baseAddress).col - colB.toSimpleColumnAddress(baseAddress).col;\n  }\n  isColumnAbsolute() {\n    return this.type === ReferenceType.ABSOLUTE;\n  }\n  isColumnRelative() {\n    return this.type === ReferenceType.RELATIVE;\n  }\n  isAbsolute() {\n    return this.type === ReferenceType.ABSOLUTE && this.sheet !== undefined;\n  }\n  moved(toSheet, toRight, _toBottom) {\n    const newSheet = this.sheet === undefined ? undefined : toSheet;\n    return new ColumnAddress(this.type, this.col + toRight, newSheet);\n  }\n  shiftedByColumns(numberOfColumns) {\n    return new ColumnAddress(this.type, this.col + numberOfColumns, this.sheet);\n  }\n  toSimpleColumnAddress(baseAddress) {\n    const sheet = absoluteSheetReference(this, baseAddress);\n    let column = this.col;\n    if (this.isColumnRelative()) {\n      column = baseAddress.col + this.col;\n    }\n    return simpleColumnAddress(sheet, column);\n  }\n  shiftRelativeDimensions(toRight, _toBottom) {\n    const col = this.isColumnRelative() ? this.col + toRight : this.col;\n    return new ColumnAddress(this.type, col, this.sheet);\n  }\n  shiftAbsoluteDimensions(toRight, _toBottom) {\n    const col = this.isColumnAbsolute() ? this.col + toRight : this.col;\n    return new ColumnAddress(this.type, col, this.sheet);\n  }\n  withSheet(sheet) {\n    return new ColumnAddress(this.type, this.col, sheet);\n  }\n  isInvalid(baseAddress) {\n    return this.toSimpleColumnAddress(baseAddress).col < 0;\n  }\n  hash(withSheet) {\n    const sheetPart = withSheet && this.sheet !== undefined ? `#${this.sheet}` : '';\n    switch (this.type) {\n      case ReferenceType.RELATIVE:\n        {\n          return `${sheetPart}#COLR${this.col}`;\n        }\n      case ReferenceType.ABSOLUTE:\n        {\n          return `${sheetPart}#COLA${this.col}`;\n        }\n    }\n  }\n  unparse(baseAddress) {\n    const simpleAddress = this.toSimpleColumnAddress(baseAddress);\n    if (invalidSimpleColumnAddress(simpleAddress)) {\n      return undefined;\n    }\n    const column = columnIndexToLabel(simpleAddress.col);\n    const dollar = this.type === ReferenceType.ABSOLUTE ? '$' : '';\n    return `${dollar}${column}`;\n  }\n  exceedsSheetSizeLimits(maxColumns) {\n    return this.col >= maxColumns;\n  }\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,sBAAsB,EAAEC,0BAA0B,EAAEC,mBAAmB,QAAQ,aAAa;AACrG,SAASC,kBAAkB,QAAQ,uCAAuC;AAC1E,OAAO,IAAIC,aAAa;AACxB,CAAC,UAAUA,aAAa,EAAE;EACxBA,aAAa,CAAC,UAAU,CAAC,GAAG,UAAU;EACtCA,aAAa,CAAC,UAAU,CAAC,GAAG,UAAU;AACxC,CAAC,EAAEA,aAAa,KAAKA,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC;AACzC,OAAO,MAAMC,aAAa,CAAC;EACzBC,WAAWA,CAACC,IAAI,EAAEC,GAAG,EAAEC,KAAK,EAAE;IAC5B,IAAI,CAACF,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,GAAG,GAAGA,GAAG;IACd,IAAI,CAACC,KAAK,GAAGA,KAAK;EACpB;EACA,OAAOC,QAAQA,CAACC,MAAM,EAAEF,KAAK,EAAE;IAC7B,OAAO,IAAIJ,aAAa,CAACD,aAAa,CAACQ,QAAQ,EAAED,MAAM,EAAEF,KAAK,CAAC;EACjE;EACA,OAAOI,QAAQA,CAACF,MAAM,EAAEF,KAAK,EAAE;IAC7B,OAAO,IAAIJ,aAAa,CAACD,aAAa,CAACU,QAAQ,EAAEH,MAAM,EAAEF,KAAK,CAAC;EACjE;EACA,OAAOM,wBAAwBA,CAACC,WAAW,EAAE;IAC3C,OAAO,CAACC,IAAI,EAAEC,IAAI,KAAKD,IAAI,CAACE,qBAAqB,CAACH,WAAW,CAAC,CAACR,GAAG,GAAGU,IAAI,CAACC,qBAAqB,CAACH,WAAW,CAAC,CAACR,GAAG;EAClH;EACAY,gBAAgBA,CAAA,EAAG;IACjB,OAAO,IAAI,CAACb,IAAI,KAAKH,aAAa,CAACQ,QAAQ;EAC7C;EACAS,gBAAgBA,CAAA,EAAG;IACjB,OAAO,IAAI,CAACd,IAAI,KAAKH,aAAa,CAACU,QAAQ;EAC7C;EACAQ,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI,CAACf,IAAI,KAAKH,aAAa,CAACQ,QAAQ,IAAI,IAAI,CAACH,KAAK,KAAKc,SAAS;EACzE;EACAC,KAAKA,CAACC,OAAO,EAAEC,OAAO,EAAEC,SAAS,EAAE;IACjC,MAAMC,QAAQ,GAAG,IAAI,CAACnB,KAAK,KAAKc,SAAS,GAAGA,SAAS,GAAGE,OAAO;IAC/D,OAAO,IAAIpB,aAAa,CAAC,IAAI,CAACE,IAAI,EAAE,IAAI,CAACC,GAAG,GAAGkB,OAAO,EAAEE,QAAQ,CAAC;EACnE;EACAC,gBAAgBA,CAACC,eAAe,EAAE;IAChC,OAAO,IAAIzB,aAAa,CAAC,IAAI,CAACE,IAAI,EAAE,IAAI,CAACC,GAAG,GAAGsB,eAAe,EAAE,IAAI,CAACrB,KAAK,CAAC;EAC7E;EACAU,qBAAqBA,CAACH,WAAW,EAAE;IACjC,MAAMP,KAAK,GAAGT,sBAAsB,CAAC,IAAI,EAAEgB,WAAW,CAAC;IACvD,IAAIL,MAAM,GAAG,IAAI,CAACH,GAAG;IACrB,IAAI,IAAI,CAACa,gBAAgB,CAAC,CAAC,EAAE;MAC3BV,MAAM,GAAGK,WAAW,CAACR,GAAG,GAAG,IAAI,CAACA,GAAG;IACrC;IACA,OAAON,mBAAmB,CAACO,KAAK,EAAEE,MAAM,CAAC;EAC3C;EACAoB,uBAAuBA,CAACL,OAAO,EAAEC,SAAS,EAAE;IAC1C,MAAMnB,GAAG,GAAG,IAAI,CAACa,gBAAgB,CAAC,CAAC,GAAG,IAAI,CAACb,GAAG,GAAGkB,OAAO,GAAG,IAAI,CAAClB,GAAG;IACnE,OAAO,IAAIH,aAAa,CAAC,IAAI,CAACE,IAAI,EAAEC,GAAG,EAAE,IAAI,CAACC,KAAK,CAAC;EACtD;EACAuB,uBAAuBA,CAACN,OAAO,EAAEC,SAAS,EAAE;IAC1C,MAAMnB,GAAG,GAAG,IAAI,CAACY,gBAAgB,CAAC,CAAC,GAAG,IAAI,CAACZ,GAAG,GAAGkB,OAAO,GAAG,IAAI,CAAClB,GAAG;IACnE,OAAO,IAAIH,aAAa,CAAC,IAAI,CAACE,IAAI,EAAEC,GAAG,EAAE,IAAI,CAACC,KAAK,CAAC;EACtD;EACAwB,SAASA,CAACxB,KAAK,EAAE;IACf,OAAO,IAAIJ,aAAa,CAAC,IAAI,CAACE,IAAI,EAAE,IAAI,CAACC,GAAG,EAAEC,KAAK,CAAC;EACtD;EACAyB,SAASA,CAAClB,WAAW,EAAE;IACrB,OAAO,IAAI,CAACG,qBAAqB,CAACH,WAAW,CAAC,CAACR,GAAG,GAAG,CAAC;EACxD;EACA2B,IAAIA,CAACF,SAAS,EAAE;IACd,MAAMG,SAAS,GAAGH,SAAS,IAAI,IAAI,CAACxB,KAAK,KAAKc,SAAS,GAAG,IAAI,IAAI,CAACd,KAAK,EAAE,GAAG,EAAE;IAC/E,QAAQ,IAAI,CAACF,IAAI;MACf,KAAKH,aAAa,CAACU,QAAQ;QACzB;UACE,OAAO,GAAGsB,SAAS,QAAQ,IAAI,CAAC5B,GAAG,EAAE;QACvC;MACF,KAAKJ,aAAa,CAACQ,QAAQ;QACzB;UACE,OAAO,GAAGwB,SAAS,QAAQ,IAAI,CAAC5B,GAAG,EAAE;QACvC;IACJ;EACF;EACA6B,OAAOA,CAACrB,WAAW,EAAE;IACnB,MAAMsB,aAAa,GAAG,IAAI,CAACnB,qBAAqB,CAACH,WAAW,CAAC;IAC7D,IAAIf,0BAA0B,CAACqC,aAAa,CAAC,EAAE;MAC7C,OAAOf,SAAS;IAClB;IACA,MAAMZ,MAAM,GAAGR,kBAAkB,CAACmC,aAAa,CAAC9B,GAAG,CAAC;IACpD,MAAM+B,MAAM,GAAG,IAAI,CAAChC,IAAI,KAAKH,aAAa,CAACQ,QAAQ,GAAG,GAAG,GAAG,EAAE;IAC9D,OAAO,GAAG2B,MAAM,GAAG5B,MAAM,EAAE;EAC7B;EACA6B,sBAAsBA,CAACC,UAAU,EAAE;IACjC,OAAO,IAAI,CAACjC,GAAG,IAAIiC,UAAU;EAC/B;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}