{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { CellError, CellValueTypeOrd, ErrorType, getCellValueType } from \"../Cell.mjs\";\nimport { ErrorMessage } from \"../error-message.mjs\";\nimport { collatorFromConfig } from \"../StringHelper.mjs\";\nimport { cloneNumber, CurrencyNumber, DateNumber, DateTimeNumber, EmptyValue, getRawValue, getTypeFormatOfExtendedNumber, isExtendedNumber, NumberType, PercentNumber, TimeNumber } from \"./InterpreterValue.mjs\";\nimport { SimpleRangeValue } from \"../SimpleRangeValue.mjs\";\nconst COMPLEX_NUMBER_SYMBOL = 'i';\nconst complexParsingRegexp = /^\\s*([+-]?)\\s*(([\\d\\.,]+(e[+-]?\\d+)?)\\s*([ij]?)|([ij]))\\s*(([+-])\\s*([+-]?)\\s*(([\\d\\.,]+(e[+-]?\\d+)?)\\s*([ij]?)|([ij])))?$/;\nexport class ArithmeticHelper {\n  constructor(config, dateTimeHelper, numberLiteralsHelper) {\n    this.config = config;\n    this.dateTimeHelper = dateTimeHelper;\n    this.numberLiteralsHelper = numberLiteralsHelper;\n    this.lt = (left, right) => {\n      return this.compare(left, right) < 0;\n    };\n    this.leq = (left, right) => {\n      return this.compare(left, right) <= 0;\n    };\n    this.gt = (left, right) => {\n      return this.compare(left, right) > 0;\n    };\n    this.geq = (left, right) => {\n      return this.compare(left, right) >= 0;\n    };\n    this.eq = (left, right) => {\n      return this.compare(left, right) === 0;\n    };\n    this.neq = (left, right) => {\n      return this.compare(left, right) !== 0;\n    };\n    this.pow = (left, right) => {\n      return Math.pow(getRawValue(left), getRawValue(right));\n    };\n    this.addWithEpsilonRaw = (left, right) => {\n      const ret = left + right;\n      if (Math.abs(ret) < this.actualEps * Math.abs(left)) {\n        return 0;\n      } else {\n        return ret;\n      }\n    };\n    this.addWithEpsilon = (left, right) => {\n      const typeOfResult = inferExtendedNumberTypeAdditive(left, right);\n      return this.ExtendedNumberFactory(this.addWithEpsilonRaw(getRawValue(left), getRawValue(right)), typeOfResult);\n    };\n    this.unaryMinus = arg => {\n      return cloneNumber(arg, -getRawValue(arg));\n    };\n    this.unaryPlus = arg => arg;\n    this.unaryPercent = arg => {\n      return new PercentNumber(getRawValue(arg) / 100);\n    };\n    this.concat = (left, right) => {\n      return left.concat(right);\n    };\n    this.nonstrictadd = (left, right) => {\n      if (left instanceof CellError) {\n        return left;\n      } else if (right instanceof CellError) {\n        return right;\n      } else if (typeof left === 'number') {\n        if (typeof right === 'number') {\n          return this.addWithEpsilonRaw(left, right);\n        } else {\n          return left;\n        }\n      } else if (typeof right === 'number') {\n        return right;\n      } else {\n        return 0;\n      }\n    };\n    /**\r\n     * Subtracts two numbers\r\n     *\r\n     * Implementation of subtracting which is used in interpreter.\r\n     *\r\n     * @param left - left operand of subtraction\r\n     * @param right - right operand of subtraction\r\n     * @param eps - precision of comparison\r\n     */\n    this.subtract = (leftArg, rightArg) => {\n      const typeOfResult = inferExtendedNumberTypeAdditive(leftArg, rightArg);\n      const left = getRawValue(leftArg);\n      const right = getRawValue(rightArg);\n      let ret = left - right;\n      if (Math.abs(ret) < this.actualEps * Math.abs(left)) {\n        ret = 0;\n      }\n      return this.ExtendedNumberFactory(ret, typeOfResult);\n    };\n    this.divide = (leftArg, rightArg) => {\n      const left = getRawValue(leftArg);\n      const right = getRawValue(rightArg);\n      if (right === 0) {\n        return new CellError(ErrorType.DIV_BY_ZERO);\n      } else {\n        const typeOfResult = inferExtendedNumberTypeMultiplicative(leftArg, rightArg);\n        return this.ExtendedNumberFactory(left / right, typeOfResult);\n      }\n    };\n    this.multiply = (left, right) => {\n      const typeOfResult = inferExtendedNumberTypeMultiplicative(left, right);\n      return this.ExtendedNumberFactory(getRawValue(left) * getRawValue(right), typeOfResult);\n    };\n    this.manyToExactComplex = args => {\n      const ret = [];\n      for (const arg of args) {\n        if (arg instanceof CellError) {\n          return arg;\n        } else if (isExtendedNumber(arg) || typeof arg === 'string') {\n          const coerced = this.coerceScalarToComplex(arg);\n          if (!(coerced instanceof CellError)) {\n            ret.push(coerced);\n          }\n        }\n      }\n      return ret;\n    };\n    this.coerceNumbersExactRanges = args => this.manyToNumbers(args, this.manyToExactNumbers);\n    this.coerceNumbersCoerceRangesDropNulls = args => this.manyToNumbers(args, this.manyToCoercedNumbersDropNulls);\n    this.manyToExactNumbers = args => {\n      const ret = [];\n      for (const arg of args) {\n        if (arg instanceof CellError) {\n          return arg;\n        } else if (isExtendedNumber(arg)) {\n          ret.push(getRawValue(arg));\n        }\n      }\n      return ret;\n    };\n    this.manyToOnlyNumbersDropNulls = args => {\n      const ret = [];\n      for (const arg of args) {\n        if (arg instanceof CellError) {\n          return arg;\n        } else if (isExtendedNumber(arg)) {\n          ret.push(getRawValue(arg));\n        } else if (arg !== EmptyValue) {\n          return new CellError(ErrorType.VALUE, ErrorMessage.NumberExpected);\n        }\n      }\n      return ret;\n    };\n    this.manyToCoercedNumbersDropNulls = args => {\n      const ret = [];\n      for (const arg of args) {\n        if (arg instanceof CellError) {\n          return arg;\n        }\n        if (arg === EmptyValue) {\n          continue;\n        }\n        const coerced = this.coerceScalarToNumberOrError(arg);\n        if (isExtendedNumber(coerced)) {\n          ret.push(getRawValue(coerced));\n        }\n      }\n      return ret;\n    };\n    this.collator = collatorFromConfig(config);\n    this.actualEps = config.smartRounding ? config.precisionEpsilon : 0;\n  }\n  eqMatcherFunction(pattern) {\n    const regexp = this.buildRegex(pattern);\n    return cellValue => typeof cellValue === 'string' && regexp.test(this.normalizeString(cellValue));\n  }\n  neqMatcherFunction(pattern) {\n    const regexp = this.buildRegex(pattern);\n    return cellValue => {\n      return !(typeof cellValue === 'string') || !regexp.test(this.normalizeString(cellValue));\n    };\n  }\n  searchString(pattern, text) {\n    var _a;\n    const regexp = this.buildRegex(pattern, false);\n    const result = regexp.exec(text);\n    return (_a = result === null || result === void 0 ? void 0 : result.index) !== null && _a !== void 0 ? _a : -1;\n  }\n  requiresRegex(pattern) {\n    if (!this.config.useRegularExpressions && !this.config.useWildcards) {\n      return !this.config.matchWholeCell;\n    }\n    for (let i = 0; i < pattern.length; i++) {\n      const c = pattern.charAt(i);\n      if (isWildcard(c) || this.config.useRegularExpressions && needsEscape(c)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  floatCmp(leftArg, rightArg) {\n    const left = getRawValue(leftArg);\n    const right = getRawValue(rightArg);\n    const mod = 1 + this.actualEps;\n    if (right >= 0 && left * mod >= right && left <= right * mod) {\n      return 0;\n    } else if (right <= 0 && left * mod <= right && left >= right * mod) {\n      return 0;\n    } else if (left > right) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n  coerceScalarToNumberOrError(arg) {\n    var _a;\n    if (arg instanceof CellError) {\n      return arg;\n    }\n    return (_a = this.coerceToMaybeNumber(arg)) !== null && _a !== void 0 ? _a : new CellError(ErrorType.VALUE, ErrorMessage.NumberCoercion);\n  }\n  coerceToMaybeNumber(arg) {\n    var _a;\n    return (_a = this.coerceNonDateScalarToMaybeNumber(arg)) !== null && _a !== void 0 ? _a : typeof arg === 'string' ? this.dateTimeHelper.dateStringToDateNumber(arg) : undefined;\n  }\n  coerceNonDateScalarToMaybeNumber(arg) {\n    if (arg === EmptyValue) {\n      return 0;\n    } else if (typeof arg === 'string') {\n      if (arg === '') {\n        return 0;\n      }\n      const maybePercentNumber = this.coerceStringToMaybePercentNumber(arg);\n      if (maybePercentNumber !== undefined) {\n        return maybePercentNumber;\n      }\n      const maybeCurrencyNumber = this.coerceStringToMaybeCurrencyNumber(arg);\n      if (maybeCurrencyNumber !== undefined) {\n        return maybeCurrencyNumber;\n      }\n      return this.numberLiteralsHelper.numericStringToMaybeNumber(arg.trim());\n    } else if (isExtendedNumber(arg)) {\n      return arg;\n    } else if (typeof arg === 'boolean') {\n      return Number(arg);\n    } else {\n      return undefined;\n    }\n  }\n  coerceStringToMaybePercentNumber(input) {\n    const trimmedInput = input.trim();\n    if (trimmedInput.endsWith('%')) {\n      const numOfPercents = trimmedInput.slice(0, trimmedInput.length - 1).trim();\n      const parsedNumOfPercents = this.numberLiteralsHelper.numericStringToMaybeNumber(numOfPercents);\n      if (parsedNumOfPercents !== undefined) {\n        return new PercentNumber(parsedNumOfPercents / 100);\n      }\n    }\n    return undefined;\n  }\n  coerceStringToMaybeCurrencyNumber(input) {\n    const matchedCurrency = this.currencyMatcher(input.trim());\n    if (matchedCurrency !== undefined) {\n      const [currencySymbol, currencyValue] = matchedCurrency;\n      const parsedCurrencyValue = this.numberLiteralsHelper.numericStringToMaybeNumber(currencyValue);\n      if (parsedCurrencyValue !== undefined) {\n        return new CurrencyNumber(parsedCurrencyValue, currencySymbol);\n      }\n    }\n    return undefined;\n  }\n  currencyMatcher(token) {\n    for (const currency of this.config.currencySymbol) {\n      if (token.startsWith(currency)) {\n        return [currency, token.slice(currency.length).trim()];\n      }\n      if (token.endsWith(currency)) {\n        return [currency, token.slice(0, token.length - currency.length).trim()];\n      }\n    }\n    return undefined;\n  }\n  coerceComplexExactRanges(args) {\n    const vals = [];\n    for (const arg of args) {\n      if (arg instanceof SimpleRangeValue) {\n        vals.push(arg);\n      } else if (arg !== EmptyValue) {\n        const coerced = this.coerceScalarToComplex(arg);\n        if (coerced instanceof CellError) {\n          return coerced;\n        } else {\n          vals.push(coerced);\n        }\n      }\n    }\n    const expandedVals = [];\n    for (const val of vals) {\n      if (val instanceof SimpleRangeValue) {\n        const arr = this.manyToExactComplex(val.valuesFromTopLeftCorner());\n        if (arr instanceof CellError) {\n          return arr;\n        } else {\n          expandedVals.push(...arr);\n        }\n      } else {\n        expandedVals.push(val);\n      }\n    }\n    return expandedVals;\n  }\n  coerceScalarToComplex(arg) {\n    if (arg instanceof CellError) {\n      return arg;\n    } else if (arg === EmptyValue) {\n      return [0, 0];\n    } else if (isExtendedNumber(arg)) {\n      return [getRawValue(arg), 0];\n    } else if (typeof arg === 'string') {\n      return this.coerceStringToComplex(arg);\n    } else {\n      return new CellError(ErrorType.NUM, ErrorMessage.ComplexNumberExpected);\n    }\n  }\n  ExtendedNumberFactory(value, typeFormat) {\n    const {\n      type,\n      format\n    } = typeFormat;\n    switch (type) {\n      case NumberType.NUMBER_RAW:\n        return value;\n      case NumberType.NUMBER_CURRENCY:\n        {\n          return new CurrencyNumber(value, format !== null && format !== void 0 ? format : this.config.currencySymbol[0]);\n        }\n      case NumberType.NUMBER_DATE:\n        return new DateNumber(value, format);\n      case NumberType.NUMBER_DATETIME:\n        return new DateTimeNumber(value, format);\n      case NumberType.NUMBER_TIME:\n        return new TimeNumber(value, format);\n      case NumberType.NUMBER_PERCENT:\n        return new PercentNumber(value, format);\n    }\n  }\n  buildRegex(pattern, matchWholeCell = true) {\n    pattern = this.normalizeString(pattern);\n    let regexpStr;\n    let useWildcards = this.config.useWildcards;\n    let useRegularExpressions = this.config.useRegularExpressions;\n    if (useRegularExpressions) {\n      try {\n        RegExp(pattern);\n      } catch (e) {\n        useRegularExpressions = false;\n        useWildcards = false;\n      }\n    }\n    if (useRegularExpressions) {\n      regexpStr = escapeNoCharacters(pattern, this.config.caseSensitive);\n    } else if (useWildcards) {\n      regexpStr = escapeNonWildcards(pattern, this.config.caseSensitive);\n    } else {\n      regexpStr = escapeAllCharacters(pattern, this.config.caseSensitive);\n    }\n    if (this.config.matchWholeCell && matchWholeCell) {\n      return RegExp('^(' + regexpStr + ')$');\n    } else {\n      return RegExp(regexpStr);\n    }\n  }\n  normalizeString(str) {\n    if (!this.config.caseSensitive) {\n      str = str.toLowerCase();\n    }\n    if (!this.config.accentSensitive) {\n      str = normalizeString(str, 'nfd').replace(/[\\u0300-\\u036f]/g, '');\n    }\n    return str;\n  }\n  compare(left, right) {\n    if (typeof left === 'string' || typeof right === 'string') {\n      const leftTmp = typeof left === 'string' ? this.dateTimeHelper.dateStringToDateNumber(left) : left;\n      const rightTmp = typeof right === 'string' ? this.dateTimeHelper.dateStringToDateNumber(right) : right;\n      if (isExtendedNumber(leftTmp) && isExtendedNumber(rightTmp)) {\n        return this.floatCmp(leftTmp, rightTmp);\n      }\n    }\n    if (left === EmptyValue) {\n      left = coerceEmptyToValue(right);\n    } else if (right === EmptyValue) {\n      right = coerceEmptyToValue(left);\n    }\n    if (typeof left === 'string' && typeof right === 'string') {\n      return this.stringCmp(left, right);\n    } else if (typeof left === 'boolean' && typeof right === 'boolean') {\n      return numberCmp(coerceBooleanToNumber(left), coerceBooleanToNumber(right));\n    } else if (isExtendedNumber(left) && isExtendedNumber(right)) {\n      return this.floatCmp(left, right);\n    } else if (left === EmptyValue && right === EmptyValue) {\n      return 0;\n    } else {\n      return numberCmp(CellValueTypeOrd(getCellValueType(left)), CellValueTypeOrd(getCellValueType(right)));\n    }\n  }\n  stringCmp(left, right) {\n    return this.collator.compare(left, right);\n  }\n  manyToNumbers(args, rangeFn) {\n    const vals = [];\n    for (const arg of args) {\n      if (arg instanceof SimpleRangeValue) {\n        vals.push(arg);\n      } else {\n        const coerced = getRawValue(this.coerceScalarToNumberOrError(arg));\n        if (coerced instanceof CellError) {\n          return coerced;\n        } else {\n          vals.push(coerced);\n        }\n      }\n    }\n    const expandedVals = [];\n    for (const val of vals) {\n      if (val instanceof SimpleRangeValue) {\n        const arr = rangeFn(val.valuesFromTopLeftCorner());\n        if (arr instanceof CellError) {\n          return arr;\n        } else {\n          expandedVals.push(...arr);\n        }\n      } else {\n        expandedVals.push(val);\n      }\n    }\n    return expandedVals;\n  }\n  coerceStringToComplex(arg) {\n    const match = complexParsingRegexp.exec(arg);\n    if (match === null) {\n      return new CellError(ErrorType.NUM, ErrorMessage.ComplexNumberExpected);\n    }\n    let val1;\n    if (match[6] !== undefined) {\n      val1 = match[1] === '-' ? [0, -1] : [0, 1];\n    } else {\n      val1 = this.parseComplexToken(match[1] + match[3], match[5]);\n    }\n    if (val1 instanceof CellError) {\n      return val1;\n    }\n    if (match[8] === undefined) {\n      return val1;\n    }\n    let val2;\n    if (match[14] !== undefined) {\n      val2 = match[9] === '-' ? [0, -1] : [0, 1];\n    } else {\n      val2 = this.parseComplexToken(match[9] + match[11], match[13]);\n    }\n    if (val2 instanceof CellError) {\n      return val2;\n    }\n    if (match[5] !== '' || match[13] === '') {\n      return new CellError(ErrorType.NUM, ErrorMessage.ComplexNumberExpected);\n    }\n    if (match[8] === '+') {\n      return [val1[0] + val2[0], val1[1] + val2[1]];\n    } else {\n      return [val1[0] - val2[0], val1[1] - val2[1]];\n    }\n  }\n  parseComplexToken(arg, mod) {\n    const val = getRawValue(this.coerceNonDateScalarToMaybeNumber(arg));\n    if (val === undefined) {\n      return new CellError(ErrorType.NUM, ErrorMessage.ComplexNumberExpected);\n    }\n    if (mod === '') {\n      return [val, 0];\n    } else {\n      return [0, val];\n    }\n  }\n}\nexport function coerceComplexToString([re, im], symb) {\n  if (!isFinite(re) || !isFinite(im)) {\n    return new CellError(ErrorType.NUM, ErrorMessage.NaN);\n  }\n  symb = symb !== null && symb !== void 0 ? symb : COMPLEX_NUMBER_SYMBOL;\n  if (im === 0) {\n    return `${re}`;\n  }\n  const imStr = `${im === -1 || im === 1 ? '' : Math.abs(im)}${symb}`;\n  if (re === 0) {\n    return `${im < 0 ? '-' : ''}${imStr}`;\n  }\n  return `${re}${im < 0 ? '-' : '+'}${imStr}`;\n}\nexport function coerceToRange(arg) {\n  if (arg instanceof SimpleRangeValue) {\n    return arg;\n  } else {\n    return SimpleRangeValue.fromScalar(arg);\n  }\n}\nexport function coerceToRangeNumbersOrError(arg) {\n  if (arg instanceof SimpleRangeValue && arg.hasOnlyNumbers() || arg instanceof CellError) {\n    return arg;\n  } else if (isExtendedNumber(arg)) {\n    return SimpleRangeValue.fromScalar(arg);\n  } else {\n    return null;\n  }\n}\nexport function coerceBooleanToNumber(arg) {\n  return Number(arg);\n}\nexport function coerceEmptyToValue(arg) {\n  if (typeof arg === 'string') {\n    return '';\n  } else if (isExtendedNumber(arg)) {\n    return 0;\n  } else if (typeof arg === 'boolean') {\n    return false;\n  } else {\n    return EmptyValue;\n  }\n}\n/**\r\n * Coerce scalar value to boolean if possible, or error if value is an error\r\n *\r\n * @param arg\r\n */\nexport function coerceScalarToBoolean(arg) {\n  if (arg instanceof CellError || typeof arg === 'boolean') {\n    return arg;\n  } else if (arg === EmptyValue) {\n    return false;\n  } else if (isExtendedNumber(arg)) {\n    return getRawValue(arg) !== 0;\n  } else {\n    const argUppered = arg.toUpperCase();\n    if (argUppered === 'TRUE') {\n      return true;\n    } else if (argUppered === 'FALSE') {\n      return false;\n    } else if (argUppered === '') {\n      return false;\n    } else {\n      return undefined;\n    }\n  }\n}\nexport function coerceScalarToString(arg) {\n  if (arg instanceof CellError || typeof arg === 'string') {\n    return arg;\n  } else if (arg === EmptyValue) {\n    return '';\n  } else if (isExtendedNumber(arg)) {\n    return getRawValue(arg).toString();\n  } else {\n    return arg ? 'TRUE' : 'FALSE';\n  }\n}\nexport function zeroIfEmpty(arg) {\n  return arg === EmptyValue ? 0 : arg;\n}\nexport function numberCmp(leftArg, rightArg) {\n  const left = getRawValue(leftArg);\n  const right = getRawValue(rightArg);\n  if (left > right) {\n    return 1;\n  } else if (left < right) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\nexport function isNumberOverflow(arg) {\n  return isNaN(arg) || arg === Infinity || arg === -Infinity;\n}\nexport function fixNegativeZero(arg) {\n  if (arg === 0) {\n    return 0;\n  } else {\n    return arg;\n  }\n}\nfunction isWildcard(c) {\n  return ['*', '?'].includes(c);\n}\nconst escapedCharacters = ['{', '}', '[', ']', '(', ')', '<', '>', '=', '.', '+', '-', ',', '\\\\', '$', '^', '!'];\nfunction needsEscape(c) {\n  return escapedCharacters.includes(c);\n}\nfunction escapeNonWildcards(pattern, caseSensitive) {\n  let str = '';\n  for (let i = 0; i < pattern.length; i++) {\n    const c = pattern.charAt(i);\n    if (c === '~') {\n      if (i == pattern.length - 1) {\n        str += '~';\n        continue;\n      }\n      const d = pattern.charAt(i + 1);\n      if (isWildcard(d) || needsEscape(d)) {\n        str += '\\\\' + d;\n        i++;\n      } else {\n        str += d;\n        i++;\n      }\n    } else if (isWildcard(c)) {\n      str += '.' + c;\n    } else if (needsEscape(c)) {\n      str += '\\\\' + c;\n    } else if (caseSensitive) {\n      str += c;\n    } else {\n      str += c.toLowerCase();\n    }\n  }\n  return str;\n}\nfunction escapeAllCharacters(pattern, caseSensitive) {\n  let str = '';\n  for (let i = 0; i < pattern.length; i++) {\n    const c = pattern.charAt(i);\n    if (isWildcard(c) || needsEscape(c)) {\n      str += '\\\\' + c;\n    } else if (caseSensitive) {\n      str += c;\n    } else {\n      str += c.toLowerCase();\n    }\n  }\n  return str;\n}\nfunction escapeNoCharacters(pattern, caseSensitive) {\n  let str = '';\n  for (let i = 0; i < pattern.length; i++) {\n    const c = pattern.charAt(i);\n    if (isWildcard(c) || needsEscape(c)) {\n      str += c;\n    } else if (caseSensitive) {\n      str += c;\n    } else {\n      str += c.toLowerCase();\n    }\n  }\n  return str;\n}\nfunction inferExtendedNumberTypeAdditive(leftArg, rightArg) {\n  const {\n    type: leftType,\n    format: leftFormat\n  } = getTypeFormatOfExtendedNumber(leftArg);\n  const {\n    type: rightType,\n    format: rightFormat\n  } = getTypeFormatOfExtendedNumber(rightArg);\n  if (leftType === NumberType.NUMBER_RAW) {\n    return {\n      type: rightType,\n      format: rightFormat\n    };\n  }\n  if (rightType === NumberType.NUMBER_RAW) {\n    return {\n      type: leftType,\n      format: leftFormat\n    };\n  }\n  if ((leftType === NumberType.NUMBER_DATETIME || leftType === NumberType.NUMBER_DATE) && (rightType === NumberType.NUMBER_DATETIME || rightType === NumberType.NUMBER_DATE)) {\n    return {\n      type: NumberType.NUMBER_RAW\n    };\n  }\n  if (leftType === NumberType.NUMBER_TIME) {\n    if (rightType === NumberType.NUMBER_DATE) {\n      return {\n        type: NumberType.NUMBER_DATETIME,\n        format: `${rightFormat} ${leftFormat}`\n      };\n    }\n    if (rightType === NumberType.NUMBER_DATETIME) {\n      return {\n        type: NumberType.NUMBER_DATETIME,\n        format: rightFormat\n      };\n    }\n  }\n  if (rightType === NumberType.NUMBER_TIME) {\n    if (leftType === NumberType.NUMBER_DATE) {\n      return {\n        type: NumberType.NUMBER_DATETIME,\n        format: `${leftFormat} ${rightFormat}`\n      };\n    }\n    if (leftType === NumberType.NUMBER_DATETIME) {\n      return {\n        type: NumberType.NUMBER_DATETIME,\n        format: leftFormat\n      };\n    }\n  }\n  return {\n    type: leftType,\n    format: leftFormat\n  };\n}\nfunction inferExtendedNumberTypeMultiplicative(leftArg, rightArg) {\n  let {\n    type: leftType,\n    format: leftFormat\n  } = getTypeFormatOfExtendedNumber(leftArg);\n  let {\n    type: rightType,\n    format: rightFormat\n  } = getTypeFormatOfExtendedNumber(rightArg);\n  if (leftType === NumberType.NUMBER_PERCENT) {\n    leftType = NumberType.NUMBER_RAW;\n    leftFormat = undefined;\n  }\n  if (rightType === NumberType.NUMBER_PERCENT) {\n    rightType = NumberType.NUMBER_RAW;\n    rightFormat = undefined;\n  }\n  if (leftType === NumberType.NUMBER_RAW) {\n    return {\n      type: rightType,\n      format: rightFormat\n    };\n  }\n  if (rightType === NumberType.NUMBER_RAW) {\n    return {\n      type: leftType,\n      format: leftFormat\n    };\n  }\n  return {\n    type: NumberType.NUMBER_RAW\n  };\n}\nexport function forceNormalizeString(str) {\n  return normalizeString(str.toLowerCase(), 'nfd').replace(/[\\u0300-\\u036f]/g, '');\n}\nexport function coerceRangeToScalar(arg, state) {\n  var _a;\n  if (arg.isAdHoc()) {\n    return (_a = arg.data[0]) === null || _a === void 0 ? void 0 : _a[0];\n  }\n  const range = arg.range;\n  if (state.formulaAddress.sheet === range.sheet) {\n    if (range.width() === 1) {\n      const offset = state.formulaAddress.row - range.start.row;\n      if (offset >= 0 && offset < range.height()) {\n        return arg.data[offset][0];\n      }\n    } else if (range.height() === 1) {\n      const offset = state.formulaAddress.col - range.start.col;\n      if (offset >= 0 && offset < range.width()) {\n        return arg.data[0][offset];\n      }\n    }\n  }\n  return undefined;\n}\nexport function normalizeString(str, form) {\n  return str.normalize(form.toUpperCase());\n}","map":{"version":3,"names":["CellError","CellValueTypeOrd","ErrorType","getCellValueType","ErrorMessage","collatorFromConfig","cloneNumber","CurrencyNumber","DateNumber","DateTimeNumber","EmptyValue","getRawValue","getTypeFormatOfExtendedNumber","isExtendedNumber","NumberType","PercentNumber","TimeNumber","SimpleRangeValue","COMPLEX_NUMBER_SYMBOL","complexParsingRegexp","ArithmeticHelper","constructor","config","dateTimeHelper","numberLiteralsHelper","lt","left","right","compare","leq","gt","geq","eq","neq","pow","Math","addWithEpsilonRaw","ret","abs","actualEps","addWithEpsilon","typeOfResult","inferExtendedNumberTypeAdditive","ExtendedNumberFactory","unaryMinus","arg","unaryPlus","unaryPercent","concat","nonstrictadd","subtract","leftArg","rightArg","divide","DIV_BY_ZERO","inferExtendedNumberTypeMultiplicative","multiply","manyToExactComplex","args","coerced","coerceScalarToComplex","push","coerceNumbersExactRanges","manyToNumbers","manyToExactNumbers","coerceNumbersCoerceRangesDropNulls","manyToCoercedNumbersDropNulls","manyToOnlyNumbersDropNulls","VALUE","NumberExpected","coerceScalarToNumberOrError","collator","smartRounding","precisionEpsilon","eqMatcherFunction","pattern","regexp","buildRegex","cellValue","test","normalizeString","neqMatcherFunction","searchString","text","_a","result","exec","index","requiresRegex","useRegularExpressions","useWildcards","matchWholeCell","i","length","c","charAt","isWildcard","needsEscape","floatCmp","mod","coerceToMaybeNumber","NumberCoercion","coerceNonDateScalarToMaybeNumber","dateStringToDateNumber","undefined","maybePercentNumber","coerceStringToMaybePercentNumber","maybeCurrencyNumber","coerceStringToMaybeCurrencyNumber","numericStringToMaybeNumber","trim","Number","input","trimmedInput","endsWith","numOfPercents","slice","parsedNumOfPercents","matchedCurrency","currencyMatcher","currencySymbol","currencyValue","parsedCurrencyValue","token","currency","startsWith","coerceComplexExactRanges","vals","expandedVals","val","arr","valuesFromTopLeftCorner","coerceStringToComplex","NUM","ComplexNumberExpected","value","typeFormat","type","format","NUMBER_RAW","NUMBER_CURRENCY","NUMBER_DATE","NUMBER_DATETIME","NUMBER_TIME","NUMBER_PERCENT","regexpStr","RegExp","e","escapeNoCharacters","caseSensitive","escapeNonWildcards","escapeAllCharacters","str","toLowerCase","accentSensitive","replace","leftTmp","rightTmp","coerceEmptyToValue","stringCmp","numberCmp","coerceBooleanToNumber","rangeFn","match","val1","parseComplexToken","val2","coerceComplexToString","re","im","symb","isFinite","NaN","imStr","coerceToRange","fromScalar","coerceToRangeNumbersOrError","hasOnlyNumbers","coerceScalarToBoolean","argUppered","toUpperCase","coerceScalarToString","toString","zeroIfEmpty","isNumberOverflow","isNaN","Infinity","fixNegativeZero","includes","escapedCharacters","d","leftType","leftFormat","rightType","rightFormat","forceNormalizeString","coerceRangeToScalar","state","isAdHoc","data","range","formulaAddress","sheet","width","offset","row","start","height","col","form","normalize"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/interpreter/ArithmeticHelper.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { CellError, CellValueTypeOrd, ErrorType, getCellValueType } from \"../Cell.mjs\";\nimport { ErrorMessage } from \"../error-message.mjs\";\nimport { collatorFromConfig } from \"../StringHelper.mjs\";\nimport { cloneNumber, CurrencyNumber, DateNumber, DateTimeNumber, EmptyValue, getRawValue, getTypeFormatOfExtendedNumber, isExtendedNumber, NumberType, PercentNumber, TimeNumber } from \"./InterpreterValue.mjs\";\nimport { SimpleRangeValue } from \"../SimpleRangeValue.mjs\";\nconst COMPLEX_NUMBER_SYMBOL = 'i';\nconst complexParsingRegexp = /^\\s*([+-]?)\\s*(([\\d\\.,]+(e[+-]?\\d+)?)\\s*([ij]?)|([ij]))\\s*(([+-])\\s*([+-]?)\\s*(([\\d\\.,]+(e[+-]?\\d+)?)\\s*([ij]?)|([ij])))?$/;\nexport class ArithmeticHelper {\n  constructor(config, dateTimeHelper, numberLiteralsHelper) {\n    this.config = config;\n    this.dateTimeHelper = dateTimeHelper;\n    this.numberLiteralsHelper = numberLiteralsHelper;\n    this.lt = (left, right) => {\n      return this.compare(left, right) < 0;\n    };\n    this.leq = (left, right) => {\n      return this.compare(left, right) <= 0;\n    };\n    this.gt = (left, right) => {\n      return this.compare(left, right) > 0;\n    };\n    this.geq = (left, right) => {\n      return this.compare(left, right) >= 0;\n    };\n    this.eq = (left, right) => {\n      return this.compare(left, right) === 0;\n    };\n    this.neq = (left, right) => {\n      return this.compare(left, right) !== 0;\n    };\n    this.pow = (left, right) => {\n      return Math.pow(getRawValue(left), getRawValue(right));\n    };\n    this.addWithEpsilonRaw = (left, right) => {\n      const ret = left + right;\n      if (Math.abs(ret) < this.actualEps * Math.abs(left)) {\n        return 0;\n      } else {\n        return ret;\n      }\n    };\n    this.addWithEpsilon = (left, right) => {\n      const typeOfResult = inferExtendedNumberTypeAdditive(left, right);\n      return this.ExtendedNumberFactory(this.addWithEpsilonRaw(getRawValue(left), getRawValue(right)), typeOfResult);\n    };\n    this.unaryMinus = arg => {\n      return cloneNumber(arg, -getRawValue(arg));\n    };\n    this.unaryPlus = arg => arg;\n    this.unaryPercent = arg => {\n      return new PercentNumber(getRawValue(arg) / 100);\n    };\n    this.concat = (left, right) => {\n      return left.concat(right);\n    };\n    this.nonstrictadd = (left, right) => {\n      if (left instanceof CellError) {\n        return left;\n      } else if (right instanceof CellError) {\n        return right;\n      } else if (typeof left === 'number') {\n        if (typeof right === 'number') {\n          return this.addWithEpsilonRaw(left, right);\n        } else {\n          return left;\n        }\n      } else if (typeof right === 'number') {\n        return right;\n      } else {\n        return 0;\n      }\n    };\n    /**\r\n     * Subtracts two numbers\r\n     *\r\n     * Implementation of subtracting which is used in interpreter.\r\n     *\r\n     * @param left - left operand of subtraction\r\n     * @param right - right operand of subtraction\r\n     * @param eps - precision of comparison\r\n     */\n    this.subtract = (leftArg, rightArg) => {\n      const typeOfResult = inferExtendedNumberTypeAdditive(leftArg, rightArg);\n      const left = getRawValue(leftArg);\n      const right = getRawValue(rightArg);\n      let ret = left - right;\n      if (Math.abs(ret) < this.actualEps * Math.abs(left)) {\n        ret = 0;\n      }\n      return this.ExtendedNumberFactory(ret, typeOfResult);\n    };\n    this.divide = (leftArg, rightArg) => {\n      const left = getRawValue(leftArg);\n      const right = getRawValue(rightArg);\n      if (right === 0) {\n        return new CellError(ErrorType.DIV_BY_ZERO);\n      } else {\n        const typeOfResult = inferExtendedNumberTypeMultiplicative(leftArg, rightArg);\n        return this.ExtendedNumberFactory(left / right, typeOfResult);\n      }\n    };\n    this.multiply = (left, right) => {\n      const typeOfResult = inferExtendedNumberTypeMultiplicative(left, right);\n      return this.ExtendedNumberFactory(getRawValue(left) * getRawValue(right), typeOfResult);\n    };\n    this.manyToExactComplex = args => {\n      const ret = [];\n      for (const arg of args) {\n        if (arg instanceof CellError) {\n          return arg;\n        } else if (isExtendedNumber(arg) || typeof arg === 'string') {\n          const coerced = this.coerceScalarToComplex(arg);\n          if (!(coerced instanceof CellError)) {\n            ret.push(coerced);\n          }\n        }\n      }\n      return ret;\n    };\n    this.coerceNumbersExactRanges = args => this.manyToNumbers(args, this.manyToExactNumbers);\n    this.coerceNumbersCoerceRangesDropNulls = args => this.manyToNumbers(args, this.manyToCoercedNumbersDropNulls);\n    this.manyToExactNumbers = args => {\n      const ret = [];\n      for (const arg of args) {\n        if (arg instanceof CellError) {\n          return arg;\n        } else if (isExtendedNumber(arg)) {\n          ret.push(getRawValue(arg));\n        }\n      }\n      return ret;\n    };\n    this.manyToOnlyNumbersDropNulls = args => {\n      const ret = [];\n      for (const arg of args) {\n        if (arg instanceof CellError) {\n          return arg;\n        } else if (isExtendedNumber(arg)) {\n          ret.push(getRawValue(arg));\n        } else if (arg !== EmptyValue) {\n          return new CellError(ErrorType.VALUE, ErrorMessage.NumberExpected);\n        }\n      }\n      return ret;\n    };\n    this.manyToCoercedNumbersDropNulls = args => {\n      const ret = [];\n      for (const arg of args) {\n        if (arg instanceof CellError) {\n          return arg;\n        }\n        if (arg === EmptyValue) {\n          continue;\n        }\n        const coerced = this.coerceScalarToNumberOrError(arg);\n        if (isExtendedNumber(coerced)) {\n          ret.push(getRawValue(coerced));\n        }\n      }\n      return ret;\n    };\n    this.collator = collatorFromConfig(config);\n    this.actualEps = config.smartRounding ? config.precisionEpsilon : 0;\n  }\n  eqMatcherFunction(pattern) {\n    const regexp = this.buildRegex(pattern);\n    return cellValue => typeof cellValue === 'string' && regexp.test(this.normalizeString(cellValue));\n  }\n  neqMatcherFunction(pattern) {\n    const regexp = this.buildRegex(pattern);\n    return cellValue => {\n      return !(typeof cellValue === 'string') || !regexp.test(this.normalizeString(cellValue));\n    };\n  }\n  searchString(pattern, text) {\n    var _a;\n    const regexp = this.buildRegex(pattern, false);\n    const result = regexp.exec(text);\n    return (_a = result === null || result === void 0 ? void 0 : result.index) !== null && _a !== void 0 ? _a : -1;\n  }\n  requiresRegex(pattern) {\n    if (!this.config.useRegularExpressions && !this.config.useWildcards) {\n      return !this.config.matchWholeCell;\n    }\n    for (let i = 0; i < pattern.length; i++) {\n      const c = pattern.charAt(i);\n      if (isWildcard(c) || this.config.useRegularExpressions && needsEscape(c)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  floatCmp(leftArg, rightArg) {\n    const left = getRawValue(leftArg);\n    const right = getRawValue(rightArg);\n    const mod = 1 + this.actualEps;\n    if (right >= 0 && left * mod >= right && left <= right * mod) {\n      return 0;\n    } else if (right <= 0 && left * mod <= right && left >= right * mod) {\n      return 0;\n    } else if (left > right) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n  coerceScalarToNumberOrError(arg) {\n    var _a;\n    if (arg instanceof CellError) {\n      return arg;\n    }\n    return (_a = this.coerceToMaybeNumber(arg)) !== null && _a !== void 0 ? _a : new CellError(ErrorType.VALUE, ErrorMessage.NumberCoercion);\n  }\n  coerceToMaybeNumber(arg) {\n    var _a;\n    return (_a = this.coerceNonDateScalarToMaybeNumber(arg)) !== null && _a !== void 0 ? _a : typeof arg === 'string' ? this.dateTimeHelper.dateStringToDateNumber(arg) : undefined;\n  }\n  coerceNonDateScalarToMaybeNumber(arg) {\n    if (arg === EmptyValue) {\n      return 0;\n    } else if (typeof arg === 'string') {\n      if (arg === '') {\n        return 0;\n      }\n      const maybePercentNumber = this.coerceStringToMaybePercentNumber(arg);\n      if (maybePercentNumber !== undefined) {\n        return maybePercentNumber;\n      }\n      const maybeCurrencyNumber = this.coerceStringToMaybeCurrencyNumber(arg);\n      if (maybeCurrencyNumber !== undefined) {\n        return maybeCurrencyNumber;\n      }\n      return this.numberLiteralsHelper.numericStringToMaybeNumber(arg.trim());\n    } else if (isExtendedNumber(arg)) {\n      return arg;\n    } else if (typeof arg === 'boolean') {\n      return Number(arg);\n    } else {\n      return undefined;\n    }\n  }\n  coerceStringToMaybePercentNumber(input) {\n    const trimmedInput = input.trim();\n    if (trimmedInput.endsWith('%')) {\n      const numOfPercents = trimmedInput.slice(0, trimmedInput.length - 1).trim();\n      const parsedNumOfPercents = this.numberLiteralsHelper.numericStringToMaybeNumber(numOfPercents);\n      if (parsedNumOfPercents !== undefined) {\n        return new PercentNumber(parsedNumOfPercents / 100);\n      }\n    }\n    return undefined;\n  }\n  coerceStringToMaybeCurrencyNumber(input) {\n    const matchedCurrency = this.currencyMatcher(input.trim());\n    if (matchedCurrency !== undefined) {\n      const [currencySymbol, currencyValue] = matchedCurrency;\n      const parsedCurrencyValue = this.numberLiteralsHelper.numericStringToMaybeNumber(currencyValue);\n      if (parsedCurrencyValue !== undefined) {\n        return new CurrencyNumber(parsedCurrencyValue, currencySymbol);\n      }\n    }\n    return undefined;\n  }\n  currencyMatcher(token) {\n    for (const currency of this.config.currencySymbol) {\n      if (token.startsWith(currency)) {\n        return [currency, token.slice(currency.length).trim()];\n      }\n      if (token.endsWith(currency)) {\n        return [currency, token.slice(0, token.length - currency.length).trim()];\n      }\n    }\n    return undefined;\n  }\n  coerceComplexExactRanges(args) {\n    const vals = [];\n    for (const arg of args) {\n      if (arg instanceof SimpleRangeValue) {\n        vals.push(arg);\n      } else if (arg !== EmptyValue) {\n        const coerced = this.coerceScalarToComplex(arg);\n        if (coerced instanceof CellError) {\n          return coerced;\n        } else {\n          vals.push(coerced);\n        }\n      }\n    }\n    const expandedVals = [];\n    for (const val of vals) {\n      if (val instanceof SimpleRangeValue) {\n        const arr = this.manyToExactComplex(val.valuesFromTopLeftCorner());\n        if (arr instanceof CellError) {\n          return arr;\n        } else {\n          expandedVals.push(...arr);\n        }\n      } else {\n        expandedVals.push(val);\n      }\n    }\n    return expandedVals;\n  }\n  coerceScalarToComplex(arg) {\n    if (arg instanceof CellError) {\n      return arg;\n    } else if (arg === EmptyValue) {\n      return [0, 0];\n    } else if (isExtendedNumber(arg)) {\n      return [getRawValue(arg), 0];\n    } else if (typeof arg === 'string') {\n      return this.coerceStringToComplex(arg);\n    } else {\n      return new CellError(ErrorType.NUM, ErrorMessage.ComplexNumberExpected);\n    }\n  }\n  ExtendedNumberFactory(value, typeFormat) {\n    const {\n      type,\n      format\n    } = typeFormat;\n    switch (type) {\n      case NumberType.NUMBER_RAW:\n        return value;\n      case NumberType.NUMBER_CURRENCY:\n        {\n          return new CurrencyNumber(value, format !== null && format !== void 0 ? format : this.config.currencySymbol[0]);\n        }\n      case NumberType.NUMBER_DATE:\n        return new DateNumber(value, format);\n      case NumberType.NUMBER_DATETIME:\n        return new DateTimeNumber(value, format);\n      case NumberType.NUMBER_TIME:\n        return new TimeNumber(value, format);\n      case NumberType.NUMBER_PERCENT:\n        return new PercentNumber(value, format);\n    }\n  }\n  buildRegex(pattern, matchWholeCell = true) {\n    pattern = this.normalizeString(pattern);\n    let regexpStr;\n    let useWildcards = this.config.useWildcards;\n    let useRegularExpressions = this.config.useRegularExpressions;\n    if (useRegularExpressions) {\n      try {\n        RegExp(pattern);\n      } catch (e) {\n        useRegularExpressions = false;\n        useWildcards = false;\n      }\n    }\n    if (useRegularExpressions) {\n      regexpStr = escapeNoCharacters(pattern, this.config.caseSensitive);\n    } else if (useWildcards) {\n      regexpStr = escapeNonWildcards(pattern, this.config.caseSensitive);\n    } else {\n      regexpStr = escapeAllCharacters(pattern, this.config.caseSensitive);\n    }\n    if (this.config.matchWholeCell && matchWholeCell) {\n      return RegExp('^(' + regexpStr + ')$');\n    } else {\n      return RegExp(regexpStr);\n    }\n  }\n  normalizeString(str) {\n    if (!this.config.caseSensitive) {\n      str = str.toLowerCase();\n    }\n    if (!this.config.accentSensitive) {\n      str = normalizeString(str, 'nfd').replace(/[\\u0300-\\u036f]/g, '');\n    }\n    return str;\n  }\n  compare(left, right) {\n    if (typeof left === 'string' || typeof right === 'string') {\n      const leftTmp = typeof left === 'string' ? this.dateTimeHelper.dateStringToDateNumber(left) : left;\n      const rightTmp = typeof right === 'string' ? this.dateTimeHelper.dateStringToDateNumber(right) : right;\n      if (isExtendedNumber(leftTmp) && isExtendedNumber(rightTmp)) {\n        return this.floatCmp(leftTmp, rightTmp);\n      }\n    }\n    if (left === EmptyValue) {\n      left = coerceEmptyToValue(right);\n    } else if (right === EmptyValue) {\n      right = coerceEmptyToValue(left);\n    }\n    if (typeof left === 'string' && typeof right === 'string') {\n      return this.stringCmp(left, right);\n    } else if (typeof left === 'boolean' && typeof right === 'boolean') {\n      return numberCmp(coerceBooleanToNumber(left), coerceBooleanToNumber(right));\n    } else if (isExtendedNumber(left) && isExtendedNumber(right)) {\n      return this.floatCmp(left, right);\n    } else if (left === EmptyValue && right === EmptyValue) {\n      return 0;\n    } else {\n      return numberCmp(CellValueTypeOrd(getCellValueType(left)), CellValueTypeOrd(getCellValueType(right)));\n    }\n  }\n  stringCmp(left, right) {\n    return this.collator.compare(left, right);\n  }\n  manyToNumbers(args, rangeFn) {\n    const vals = [];\n    for (const arg of args) {\n      if (arg instanceof SimpleRangeValue) {\n        vals.push(arg);\n      } else {\n        const coerced = getRawValue(this.coerceScalarToNumberOrError(arg));\n        if (coerced instanceof CellError) {\n          return coerced;\n        } else {\n          vals.push(coerced);\n        }\n      }\n    }\n    const expandedVals = [];\n    for (const val of vals) {\n      if (val instanceof SimpleRangeValue) {\n        const arr = rangeFn(val.valuesFromTopLeftCorner());\n        if (arr instanceof CellError) {\n          return arr;\n        } else {\n          expandedVals.push(...arr);\n        }\n      } else {\n        expandedVals.push(val);\n      }\n    }\n    return expandedVals;\n  }\n  coerceStringToComplex(arg) {\n    const match = complexParsingRegexp.exec(arg);\n    if (match === null) {\n      return new CellError(ErrorType.NUM, ErrorMessage.ComplexNumberExpected);\n    }\n    let val1;\n    if (match[6] !== undefined) {\n      val1 = match[1] === '-' ? [0, -1] : [0, 1];\n    } else {\n      val1 = this.parseComplexToken(match[1] + match[3], match[5]);\n    }\n    if (val1 instanceof CellError) {\n      return val1;\n    }\n    if (match[8] === undefined) {\n      return val1;\n    }\n    let val2;\n    if (match[14] !== undefined) {\n      val2 = match[9] === '-' ? [0, -1] : [0, 1];\n    } else {\n      val2 = this.parseComplexToken(match[9] + match[11], match[13]);\n    }\n    if (val2 instanceof CellError) {\n      return val2;\n    }\n    if (match[5] !== '' || match[13] === '') {\n      return new CellError(ErrorType.NUM, ErrorMessage.ComplexNumberExpected);\n    }\n    if (match[8] === '+') {\n      return [val1[0] + val2[0], val1[1] + val2[1]];\n    } else {\n      return [val1[0] - val2[0], val1[1] - val2[1]];\n    }\n  }\n  parseComplexToken(arg, mod) {\n    const val = getRawValue(this.coerceNonDateScalarToMaybeNumber(arg));\n    if (val === undefined) {\n      return new CellError(ErrorType.NUM, ErrorMessage.ComplexNumberExpected);\n    }\n    if (mod === '') {\n      return [val, 0];\n    } else {\n      return [0, val];\n    }\n  }\n}\nexport function coerceComplexToString([re, im], symb) {\n  if (!isFinite(re) || !isFinite(im)) {\n    return new CellError(ErrorType.NUM, ErrorMessage.NaN);\n  }\n  symb = symb !== null && symb !== void 0 ? symb : COMPLEX_NUMBER_SYMBOL;\n  if (im === 0) {\n    return `${re}`;\n  }\n  const imStr = `${im === -1 || im === 1 ? '' : Math.abs(im)}${symb}`;\n  if (re === 0) {\n    return `${im < 0 ? '-' : ''}${imStr}`;\n  }\n  return `${re}${im < 0 ? '-' : '+'}${imStr}`;\n}\nexport function coerceToRange(arg) {\n  if (arg instanceof SimpleRangeValue) {\n    return arg;\n  } else {\n    return SimpleRangeValue.fromScalar(arg);\n  }\n}\nexport function coerceToRangeNumbersOrError(arg) {\n  if (arg instanceof SimpleRangeValue && arg.hasOnlyNumbers() || arg instanceof CellError) {\n    return arg;\n  } else if (isExtendedNumber(arg)) {\n    return SimpleRangeValue.fromScalar(arg);\n  } else {\n    return null;\n  }\n}\nexport function coerceBooleanToNumber(arg) {\n  return Number(arg);\n}\nexport function coerceEmptyToValue(arg) {\n  if (typeof arg === 'string') {\n    return '';\n  } else if (isExtendedNumber(arg)) {\n    return 0;\n  } else if (typeof arg === 'boolean') {\n    return false;\n  } else {\n    return EmptyValue;\n  }\n}\n/**\r\n * Coerce scalar value to boolean if possible, or error if value is an error\r\n *\r\n * @param arg\r\n */\nexport function coerceScalarToBoolean(arg) {\n  if (arg instanceof CellError || typeof arg === 'boolean') {\n    return arg;\n  } else if (arg === EmptyValue) {\n    return false;\n  } else if (isExtendedNumber(arg)) {\n    return getRawValue(arg) !== 0;\n  } else {\n    const argUppered = arg.toUpperCase();\n    if (argUppered === 'TRUE') {\n      return true;\n    } else if (argUppered === 'FALSE') {\n      return false;\n    } else if (argUppered === '') {\n      return false;\n    } else {\n      return undefined;\n    }\n  }\n}\nexport function coerceScalarToString(arg) {\n  if (arg instanceof CellError || typeof arg === 'string') {\n    return arg;\n  } else if (arg === EmptyValue) {\n    return '';\n  } else if (isExtendedNumber(arg)) {\n    return getRawValue(arg).toString();\n  } else {\n    return arg ? 'TRUE' : 'FALSE';\n  }\n}\nexport function zeroIfEmpty(arg) {\n  return arg === EmptyValue ? 0 : arg;\n}\nexport function numberCmp(leftArg, rightArg) {\n  const left = getRawValue(leftArg);\n  const right = getRawValue(rightArg);\n  if (left > right) {\n    return 1;\n  } else if (left < right) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\nexport function isNumberOverflow(arg) {\n  return isNaN(arg) || arg === Infinity || arg === -Infinity;\n}\nexport function fixNegativeZero(arg) {\n  if (arg === 0) {\n    return 0;\n  } else {\n    return arg;\n  }\n}\nfunction isWildcard(c) {\n  return ['*', '?'].includes(c);\n}\nconst escapedCharacters = ['{', '}', '[', ']', '(', ')', '<', '>', '=', '.', '+', '-', ',', '\\\\', '$', '^', '!'];\nfunction needsEscape(c) {\n  return escapedCharacters.includes(c);\n}\nfunction escapeNonWildcards(pattern, caseSensitive) {\n  let str = '';\n  for (let i = 0; i < pattern.length; i++) {\n    const c = pattern.charAt(i);\n    if (c === '~') {\n      if (i == pattern.length - 1) {\n        str += '~';\n        continue;\n      }\n      const d = pattern.charAt(i + 1);\n      if (isWildcard(d) || needsEscape(d)) {\n        str += '\\\\' + d;\n        i++;\n      } else {\n        str += d;\n        i++;\n      }\n    } else if (isWildcard(c)) {\n      str += '.' + c;\n    } else if (needsEscape(c)) {\n      str += '\\\\' + c;\n    } else if (caseSensitive) {\n      str += c;\n    } else {\n      str += c.toLowerCase();\n    }\n  }\n  return str;\n}\nfunction escapeAllCharacters(pattern, caseSensitive) {\n  let str = '';\n  for (let i = 0; i < pattern.length; i++) {\n    const c = pattern.charAt(i);\n    if (isWildcard(c) || needsEscape(c)) {\n      str += '\\\\' + c;\n    } else if (caseSensitive) {\n      str += c;\n    } else {\n      str += c.toLowerCase();\n    }\n  }\n  return str;\n}\nfunction escapeNoCharacters(pattern, caseSensitive) {\n  let str = '';\n  for (let i = 0; i < pattern.length; i++) {\n    const c = pattern.charAt(i);\n    if (isWildcard(c) || needsEscape(c)) {\n      str += c;\n    } else if (caseSensitive) {\n      str += c;\n    } else {\n      str += c.toLowerCase();\n    }\n  }\n  return str;\n}\nfunction inferExtendedNumberTypeAdditive(leftArg, rightArg) {\n  const {\n    type: leftType,\n    format: leftFormat\n  } = getTypeFormatOfExtendedNumber(leftArg);\n  const {\n    type: rightType,\n    format: rightFormat\n  } = getTypeFormatOfExtendedNumber(rightArg);\n  if (leftType === NumberType.NUMBER_RAW) {\n    return {\n      type: rightType,\n      format: rightFormat\n    };\n  }\n  if (rightType === NumberType.NUMBER_RAW) {\n    return {\n      type: leftType,\n      format: leftFormat\n    };\n  }\n  if ((leftType === NumberType.NUMBER_DATETIME || leftType === NumberType.NUMBER_DATE) && (rightType === NumberType.NUMBER_DATETIME || rightType === NumberType.NUMBER_DATE)) {\n    return {\n      type: NumberType.NUMBER_RAW\n    };\n  }\n  if (leftType === NumberType.NUMBER_TIME) {\n    if (rightType === NumberType.NUMBER_DATE) {\n      return {\n        type: NumberType.NUMBER_DATETIME,\n        format: `${rightFormat} ${leftFormat}`\n      };\n    }\n    if (rightType === NumberType.NUMBER_DATETIME) {\n      return {\n        type: NumberType.NUMBER_DATETIME,\n        format: rightFormat\n      };\n    }\n  }\n  if (rightType === NumberType.NUMBER_TIME) {\n    if (leftType === NumberType.NUMBER_DATE) {\n      return {\n        type: NumberType.NUMBER_DATETIME,\n        format: `${leftFormat} ${rightFormat}`\n      };\n    }\n    if (leftType === NumberType.NUMBER_DATETIME) {\n      return {\n        type: NumberType.NUMBER_DATETIME,\n        format: leftFormat\n      };\n    }\n  }\n  return {\n    type: leftType,\n    format: leftFormat\n  };\n}\nfunction inferExtendedNumberTypeMultiplicative(leftArg, rightArg) {\n  let {\n    type: leftType,\n    format: leftFormat\n  } = getTypeFormatOfExtendedNumber(leftArg);\n  let {\n    type: rightType,\n    format: rightFormat\n  } = getTypeFormatOfExtendedNumber(rightArg);\n  if (leftType === NumberType.NUMBER_PERCENT) {\n    leftType = NumberType.NUMBER_RAW;\n    leftFormat = undefined;\n  }\n  if (rightType === NumberType.NUMBER_PERCENT) {\n    rightType = NumberType.NUMBER_RAW;\n    rightFormat = undefined;\n  }\n  if (leftType === NumberType.NUMBER_RAW) {\n    return {\n      type: rightType,\n      format: rightFormat\n    };\n  }\n  if (rightType === NumberType.NUMBER_RAW) {\n    return {\n      type: leftType,\n      format: leftFormat\n    };\n  }\n  return {\n    type: NumberType.NUMBER_RAW\n  };\n}\nexport function forceNormalizeString(str) {\n  return normalizeString(str.toLowerCase(), 'nfd').replace(/[\\u0300-\\u036f]/g, '');\n}\nexport function coerceRangeToScalar(arg, state) {\n  var _a;\n  if (arg.isAdHoc()) {\n    return (_a = arg.data[0]) === null || _a === void 0 ? void 0 : _a[0];\n  }\n  const range = arg.range;\n  if (state.formulaAddress.sheet === range.sheet) {\n    if (range.width() === 1) {\n      const offset = state.formulaAddress.row - range.start.row;\n      if (offset >= 0 && offset < range.height()) {\n        return arg.data[offset][0];\n      }\n    } else if (range.height() === 1) {\n      const offset = state.formulaAddress.col - range.start.col;\n      if (offset >= 0 && offset < range.width()) {\n        return arg.data[0][offset];\n      }\n    }\n  }\n  return undefined;\n}\nexport function normalizeString(str, form) {\n  return str.normalize(form.toUpperCase());\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}