{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { ErrorType } from \"../Cell.mjs\";\nimport { NoSheetWithIdError } from \"../index.mjs\";\nimport { sheetIndexToString } from \"./addressRepresentationConverters.mjs\";\nimport { AstNodeType, imageWithWhitespace, RangeSheetReferenceType } from \"./Ast.mjs\";\nimport { binaryOpTokenMap } from \"./binaryOpTokenMap.mjs\";\nexport class Unparser {\n  constructor(config, lexerConfig, sheetMappingFn, namedExpressions) {\n    this.config = config;\n    this.lexerConfig = lexerConfig;\n    this.sheetMappingFn = sheetMappingFn;\n    this.namedExpressions = namedExpressions;\n  }\n  unparse(ast, address) {\n    return '=' + this.unparseAst(ast, address);\n  }\n  unparseAst(ast, address) {\n    var _a, _b;\n    switch (ast.type) {\n      case AstNodeType.EMPTY:\n        {\n          return imageWithWhitespace('', ast.leadingWhitespace);\n        }\n      case AstNodeType.NUMBER:\n        {\n          return imageWithWhitespace(formatNumber(ast.value, this.config.decimalSeparator), ast.leadingWhitespace);\n        }\n      case AstNodeType.STRING:\n        {\n          return imageWithWhitespace('\"' + ast.value + '\"', ast.leadingWhitespace);\n        }\n      case AstNodeType.FUNCTION_CALL:\n        {\n          const args = ast.args.map(arg => arg !== undefined ? this.unparseAst(arg, address) : '').join(this.config.functionArgSeparator);\n          const procedureName = this.config.translationPackage.isFunctionTranslated(ast.procedureName) ? this.config.translationPackage.getFunctionTranslation(ast.procedureName) : ast.procedureName;\n          const rightPart = procedureName + '(' + args + imageWithWhitespace(')', ast.internalWhitespace);\n          return imageWithWhitespace(rightPart, ast.leadingWhitespace);\n        }\n      case AstNodeType.NAMED_EXPRESSION:\n        {\n          const originalNamedExpressionName = (_a = this.namedExpressions.nearestNamedExpression(ast.expressionName, address.sheet)) === null || _a === void 0 ? void 0 : _a.displayName;\n          return imageWithWhitespace(originalNamedExpressionName || ast.expressionName, ast.leadingWhitespace);\n        }\n      case AstNodeType.CELL_REFERENCE:\n        {\n          let image;\n          if (ast.reference.sheet !== undefined) {\n            image = this.unparseSheetName(ast.reference.sheet) + '!';\n          } else {\n            image = '';\n          }\n          image += (_b = ast.reference.unparse(address)) !== null && _b !== void 0 ? _b : this.config.translationPackage.getErrorTranslation(ErrorType.REF);\n          return imageWithWhitespace(image, ast.leadingWhitespace);\n        }\n      case AstNodeType.COLUMN_RANGE:\n      case AstNodeType.ROW_RANGE:\n      case AstNodeType.CELL_RANGE:\n        {\n          return imageWithWhitespace(this.formatRange(ast, address), ast.leadingWhitespace);\n        }\n      case AstNodeType.PLUS_UNARY_OP:\n        {\n          const unparsedExpr = this.unparseAst(ast.value, address);\n          return imageWithWhitespace('+', ast.leadingWhitespace) + unparsedExpr;\n        }\n      case AstNodeType.MINUS_UNARY_OP:\n        {\n          const unparsedExpr = this.unparseAst(ast.value, address);\n          return imageWithWhitespace('-', ast.leadingWhitespace) + unparsedExpr;\n        }\n      case AstNodeType.PERCENT_OP:\n        {\n          return this.unparseAst(ast.value, address) + imageWithWhitespace('%', ast.leadingWhitespace);\n        }\n      case AstNodeType.ERROR:\n        {\n          const image = this.config.translationPackage.getErrorTranslation(ast.error ? ast.error.type : ErrorType.ERROR);\n          return imageWithWhitespace(image, ast.leadingWhitespace);\n        }\n      case AstNodeType.ERROR_WITH_RAW_INPUT:\n        {\n          return imageWithWhitespace(ast.rawInput, ast.leadingWhitespace);\n        }\n      case AstNodeType.PARENTHESIS:\n        {\n          const expression = this.unparseAst(ast.expression, address);\n          const rightPart = '(' + expression + imageWithWhitespace(')', ast.internalWhitespace);\n          return imageWithWhitespace(rightPart, ast.leadingWhitespace);\n        }\n      case AstNodeType.ARRAY:\n        {\n          const ret = '{' + ast.args.map(row => row.map(val => this.unparseAst(val, address)).join(this.config.arrayColumnSeparator)).join(this.config.arrayRowSeparator) + imageWithWhitespace('}', ast.internalWhitespace);\n          return imageWithWhitespace(ret, ast.leadingWhitespace);\n        }\n      default:\n        {\n          const left = this.unparseAst(ast.left, address);\n          const right = this.unparseAst(ast.right, address);\n          return left + imageWithWhitespace(binaryOpTokenMap[ast.type], ast.leadingWhitespace) + right;\n        }\n    }\n  }\n  unparseSheetName(sheetId) {\n    const sheetName = sheetIndexToString(sheetId, this.sheetMappingFn);\n    if (sheetName === undefined) {\n      throw new NoSheetWithIdError(sheetId);\n    }\n    return sheetName;\n  }\n  formatRange(ast, baseAddress) {\n    let startSheeet = '';\n    let endSheet = '';\n    if (ast.start.sheet !== undefined && ast.sheetReferenceType !== RangeSheetReferenceType.RELATIVE) {\n      startSheeet = this.unparseSheetName(ast.start.sheet) + '!';\n    }\n    if (ast.end.sheet !== undefined && ast.sheetReferenceType === RangeSheetReferenceType.BOTH_ABSOLUTE) {\n      endSheet = this.unparseSheetName(ast.end.sheet) + '!';\n    }\n    const unparsedStart = ast.start.unparse(baseAddress);\n    const unparsedEnd = ast.end.unparse(baseAddress);\n    if (unparsedStart === undefined || unparsedEnd === undefined) {\n      return this.config.translationPackage.getErrorTranslation(ErrorType.REF);\n    }\n    return `${startSheeet}${unparsedStart}:${endSheet}${unparsedEnd}`;\n  }\n}\nexport function formatNumber(number, decimalSeparator) {\n  const numericString = number.toString();\n  return numericString.replace('.', decimalSeparator);\n}","map":{"version":3,"names":["ErrorType","NoSheetWithIdError","sheetIndexToString","AstNodeType","imageWithWhitespace","RangeSheetReferenceType","binaryOpTokenMap","Unparser","constructor","config","lexerConfig","sheetMappingFn","namedExpressions","unparse","ast","address","unparseAst","_a","_b","type","EMPTY","leadingWhitespace","NUMBER","formatNumber","value","decimalSeparator","STRING","FUNCTION_CALL","args","map","arg","undefined","join","functionArgSeparator","procedureName","translationPackage","isFunctionTranslated","getFunctionTranslation","rightPart","internalWhitespace","NAMED_EXPRESSION","originalNamedExpressionName","nearestNamedExpression","expressionName","sheet","displayName","CELL_REFERENCE","image","reference","unparseSheetName","getErrorTranslation","REF","COLUMN_RANGE","ROW_RANGE","CELL_RANGE","formatRange","PLUS_UNARY_OP","unparsedExpr","MINUS_UNARY_OP","PERCENT_OP","ERROR","error","ERROR_WITH_RAW_INPUT","rawInput","PARENTHESIS","expression","ARRAY","ret","row","val","arrayColumnSeparator","arrayRowSeparator","left","right","sheetId","sheetName","baseAddress","startSheeet","endSheet","start","sheetReferenceType","RELATIVE","end","BOTH_ABSOLUTE","unparsedStart","unparsedEnd","number","numericString","toString","replace"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/parser/Unparser.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { ErrorType } from \"../Cell.mjs\";\nimport { NoSheetWithIdError } from \"../index.mjs\";\nimport { sheetIndexToString } from \"./addressRepresentationConverters.mjs\";\nimport { AstNodeType, imageWithWhitespace, RangeSheetReferenceType } from \"./Ast.mjs\";\nimport { binaryOpTokenMap } from \"./binaryOpTokenMap.mjs\";\nexport class Unparser {\n  constructor(config, lexerConfig, sheetMappingFn, namedExpressions) {\n    this.config = config;\n    this.lexerConfig = lexerConfig;\n    this.sheetMappingFn = sheetMappingFn;\n    this.namedExpressions = namedExpressions;\n  }\n  unparse(ast, address) {\n    return '=' + this.unparseAst(ast, address);\n  }\n  unparseAst(ast, address) {\n    var _a, _b;\n    switch (ast.type) {\n      case AstNodeType.EMPTY:\n        {\n          return imageWithWhitespace('', ast.leadingWhitespace);\n        }\n      case AstNodeType.NUMBER:\n        {\n          return imageWithWhitespace(formatNumber(ast.value, this.config.decimalSeparator), ast.leadingWhitespace);\n        }\n      case AstNodeType.STRING:\n        {\n          return imageWithWhitespace('\"' + ast.value + '\"', ast.leadingWhitespace);\n        }\n      case AstNodeType.FUNCTION_CALL:\n        {\n          const args = ast.args.map(arg => arg !== undefined ? this.unparseAst(arg, address) : '').join(this.config.functionArgSeparator);\n          const procedureName = this.config.translationPackage.isFunctionTranslated(ast.procedureName) ? this.config.translationPackage.getFunctionTranslation(ast.procedureName) : ast.procedureName;\n          const rightPart = procedureName + '(' + args + imageWithWhitespace(')', ast.internalWhitespace);\n          return imageWithWhitespace(rightPart, ast.leadingWhitespace);\n        }\n      case AstNodeType.NAMED_EXPRESSION:\n        {\n          const originalNamedExpressionName = (_a = this.namedExpressions.nearestNamedExpression(ast.expressionName, address.sheet)) === null || _a === void 0 ? void 0 : _a.displayName;\n          return imageWithWhitespace(originalNamedExpressionName || ast.expressionName, ast.leadingWhitespace);\n        }\n      case AstNodeType.CELL_REFERENCE:\n        {\n          let image;\n          if (ast.reference.sheet !== undefined) {\n            image = this.unparseSheetName(ast.reference.sheet) + '!';\n          } else {\n            image = '';\n          }\n          image += (_b = ast.reference.unparse(address)) !== null && _b !== void 0 ? _b : this.config.translationPackage.getErrorTranslation(ErrorType.REF);\n          return imageWithWhitespace(image, ast.leadingWhitespace);\n        }\n      case AstNodeType.COLUMN_RANGE:\n      case AstNodeType.ROW_RANGE:\n      case AstNodeType.CELL_RANGE:\n        {\n          return imageWithWhitespace(this.formatRange(ast, address), ast.leadingWhitespace);\n        }\n      case AstNodeType.PLUS_UNARY_OP:\n        {\n          const unparsedExpr = this.unparseAst(ast.value, address);\n          return imageWithWhitespace('+', ast.leadingWhitespace) + unparsedExpr;\n        }\n      case AstNodeType.MINUS_UNARY_OP:\n        {\n          const unparsedExpr = this.unparseAst(ast.value, address);\n          return imageWithWhitespace('-', ast.leadingWhitespace) + unparsedExpr;\n        }\n      case AstNodeType.PERCENT_OP:\n        {\n          return this.unparseAst(ast.value, address) + imageWithWhitespace('%', ast.leadingWhitespace);\n        }\n      case AstNodeType.ERROR:\n        {\n          const image = this.config.translationPackage.getErrorTranslation(ast.error ? ast.error.type : ErrorType.ERROR);\n          return imageWithWhitespace(image, ast.leadingWhitespace);\n        }\n      case AstNodeType.ERROR_WITH_RAW_INPUT:\n        {\n          return imageWithWhitespace(ast.rawInput, ast.leadingWhitespace);\n        }\n      case AstNodeType.PARENTHESIS:\n        {\n          const expression = this.unparseAst(ast.expression, address);\n          const rightPart = '(' + expression + imageWithWhitespace(')', ast.internalWhitespace);\n          return imageWithWhitespace(rightPart, ast.leadingWhitespace);\n        }\n      case AstNodeType.ARRAY:\n        {\n          const ret = '{' + ast.args.map(row => row.map(val => this.unparseAst(val, address)).join(this.config.arrayColumnSeparator)).join(this.config.arrayRowSeparator) + imageWithWhitespace('}', ast.internalWhitespace);\n          return imageWithWhitespace(ret, ast.leadingWhitespace);\n        }\n      default:\n        {\n          const left = this.unparseAst(ast.left, address);\n          const right = this.unparseAst(ast.right, address);\n          return left + imageWithWhitespace(binaryOpTokenMap[ast.type], ast.leadingWhitespace) + right;\n        }\n    }\n  }\n  unparseSheetName(sheetId) {\n    const sheetName = sheetIndexToString(sheetId, this.sheetMappingFn);\n    if (sheetName === undefined) {\n      throw new NoSheetWithIdError(sheetId);\n    }\n    return sheetName;\n  }\n  formatRange(ast, baseAddress) {\n    let startSheeet = '';\n    let endSheet = '';\n    if (ast.start.sheet !== undefined && ast.sheetReferenceType !== RangeSheetReferenceType.RELATIVE) {\n      startSheeet = this.unparseSheetName(ast.start.sheet) + '!';\n    }\n    if (ast.end.sheet !== undefined && ast.sheetReferenceType === RangeSheetReferenceType.BOTH_ABSOLUTE) {\n      endSheet = this.unparseSheetName(ast.end.sheet) + '!';\n    }\n    const unparsedStart = ast.start.unparse(baseAddress);\n    const unparsedEnd = ast.end.unparse(baseAddress);\n    if (unparsedStart === undefined || unparsedEnd === undefined) {\n      return this.config.translationPackage.getErrorTranslation(ErrorType.REF);\n    }\n    return `${startSheeet}${unparsedStart}:${endSheet}${unparsedEnd}`;\n  }\n}\nexport function formatNumber(number, decimalSeparator) {\n  const numericString = number.toString();\n  return numericString.replace('.', decimalSeparator);\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,SAAS,QAAQ,aAAa;AACvC,SAASC,kBAAkB,QAAQ,cAAc;AACjD,SAASC,kBAAkB,QAAQ,uCAAuC;AAC1E,SAASC,WAAW,EAAEC,mBAAmB,EAAEC,uBAAuB,QAAQ,WAAW;AACrF,SAASC,gBAAgB,QAAQ,wBAAwB;AACzD,OAAO,MAAMC,QAAQ,CAAC;EACpBC,WAAWA,CAACC,MAAM,EAAEC,WAAW,EAAEC,cAAc,EAAEC,gBAAgB,EAAE;IACjE,IAAI,CAACH,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACC,cAAc,GAAGA,cAAc;IACpC,IAAI,CAACC,gBAAgB,GAAGA,gBAAgB;EAC1C;EACAC,OAAOA,CAACC,GAAG,EAAEC,OAAO,EAAE;IACpB,OAAO,GAAG,GAAG,IAAI,CAACC,UAAU,CAACF,GAAG,EAAEC,OAAO,CAAC;EAC5C;EACAC,UAAUA,CAACF,GAAG,EAAEC,OAAO,EAAE;IACvB,IAAIE,EAAE,EAAEC,EAAE;IACV,QAAQJ,GAAG,CAACK,IAAI;MACd,KAAKhB,WAAW,CAACiB,KAAK;QACpB;UACE,OAAOhB,mBAAmB,CAAC,EAAE,EAAEU,GAAG,CAACO,iBAAiB,CAAC;QACvD;MACF,KAAKlB,WAAW,CAACmB,MAAM;QACrB;UACE,OAAOlB,mBAAmB,CAACmB,YAAY,CAACT,GAAG,CAACU,KAAK,EAAE,IAAI,CAACf,MAAM,CAACgB,gBAAgB,CAAC,EAAEX,GAAG,CAACO,iBAAiB,CAAC;QAC1G;MACF,KAAKlB,WAAW,CAACuB,MAAM;QACrB;UACE,OAAOtB,mBAAmB,CAAC,GAAG,GAAGU,GAAG,CAACU,KAAK,GAAG,GAAG,EAAEV,GAAG,CAACO,iBAAiB,CAAC;QAC1E;MACF,KAAKlB,WAAW,CAACwB,aAAa;QAC5B;UACE,MAAMC,IAAI,GAAGd,GAAG,CAACc,IAAI,CAACC,GAAG,CAACC,GAAG,IAAIA,GAAG,KAAKC,SAAS,GAAG,IAAI,CAACf,UAAU,CAACc,GAAG,EAAEf,OAAO,CAAC,GAAG,EAAE,CAAC,CAACiB,IAAI,CAAC,IAAI,CAACvB,MAAM,CAACwB,oBAAoB,CAAC;UAC/H,MAAMC,aAAa,GAAG,IAAI,CAACzB,MAAM,CAAC0B,kBAAkB,CAACC,oBAAoB,CAACtB,GAAG,CAACoB,aAAa,CAAC,GAAG,IAAI,CAACzB,MAAM,CAAC0B,kBAAkB,CAACE,sBAAsB,CAACvB,GAAG,CAACoB,aAAa,CAAC,GAAGpB,GAAG,CAACoB,aAAa;UAC3L,MAAMI,SAAS,GAAGJ,aAAa,GAAG,GAAG,GAAGN,IAAI,GAAGxB,mBAAmB,CAAC,GAAG,EAAEU,GAAG,CAACyB,kBAAkB,CAAC;UAC/F,OAAOnC,mBAAmB,CAACkC,SAAS,EAAExB,GAAG,CAACO,iBAAiB,CAAC;QAC9D;MACF,KAAKlB,WAAW,CAACqC,gBAAgB;QAC/B;UACE,MAAMC,2BAA2B,GAAG,CAACxB,EAAE,GAAG,IAAI,CAACL,gBAAgB,CAAC8B,sBAAsB,CAAC5B,GAAG,CAAC6B,cAAc,EAAE5B,OAAO,CAAC6B,KAAK,CAAC,MAAM,IAAI,IAAI3B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC4B,WAAW;UAC9K,OAAOzC,mBAAmB,CAACqC,2BAA2B,IAAI3B,GAAG,CAAC6B,cAAc,EAAE7B,GAAG,CAACO,iBAAiB,CAAC;QACtG;MACF,KAAKlB,WAAW,CAAC2C,cAAc;QAC7B;UACE,IAAIC,KAAK;UACT,IAAIjC,GAAG,CAACkC,SAAS,CAACJ,KAAK,KAAKb,SAAS,EAAE;YACrCgB,KAAK,GAAG,IAAI,CAACE,gBAAgB,CAACnC,GAAG,CAACkC,SAAS,CAACJ,KAAK,CAAC,GAAG,GAAG;UAC1D,CAAC,MAAM;YACLG,KAAK,GAAG,EAAE;UACZ;UACAA,KAAK,IAAI,CAAC7B,EAAE,GAAGJ,GAAG,CAACkC,SAAS,CAACnC,OAAO,CAACE,OAAO,CAAC,MAAM,IAAI,IAAIG,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,IAAI,CAACT,MAAM,CAAC0B,kBAAkB,CAACe,mBAAmB,CAAClD,SAAS,CAACmD,GAAG,CAAC;UACjJ,OAAO/C,mBAAmB,CAAC2C,KAAK,EAAEjC,GAAG,CAACO,iBAAiB,CAAC;QAC1D;MACF,KAAKlB,WAAW,CAACiD,YAAY;MAC7B,KAAKjD,WAAW,CAACkD,SAAS;MAC1B,KAAKlD,WAAW,CAACmD,UAAU;QACzB;UACE,OAAOlD,mBAAmB,CAAC,IAAI,CAACmD,WAAW,CAACzC,GAAG,EAAEC,OAAO,CAAC,EAAED,GAAG,CAACO,iBAAiB,CAAC;QACnF;MACF,KAAKlB,WAAW,CAACqD,aAAa;QAC5B;UACE,MAAMC,YAAY,GAAG,IAAI,CAACzC,UAAU,CAACF,GAAG,CAACU,KAAK,EAAET,OAAO,CAAC;UACxD,OAAOX,mBAAmB,CAAC,GAAG,EAAEU,GAAG,CAACO,iBAAiB,CAAC,GAAGoC,YAAY;QACvE;MACF,KAAKtD,WAAW,CAACuD,cAAc;QAC7B;UACE,MAAMD,YAAY,GAAG,IAAI,CAACzC,UAAU,CAACF,GAAG,CAACU,KAAK,EAAET,OAAO,CAAC;UACxD,OAAOX,mBAAmB,CAAC,GAAG,EAAEU,GAAG,CAACO,iBAAiB,CAAC,GAAGoC,YAAY;QACvE;MACF,KAAKtD,WAAW,CAACwD,UAAU;QACzB;UACE,OAAO,IAAI,CAAC3C,UAAU,CAACF,GAAG,CAACU,KAAK,EAAET,OAAO,CAAC,GAAGX,mBAAmB,CAAC,GAAG,EAAEU,GAAG,CAACO,iBAAiB,CAAC;QAC9F;MACF,KAAKlB,WAAW,CAACyD,KAAK;QACpB;UACE,MAAMb,KAAK,GAAG,IAAI,CAACtC,MAAM,CAAC0B,kBAAkB,CAACe,mBAAmB,CAACpC,GAAG,CAAC+C,KAAK,GAAG/C,GAAG,CAAC+C,KAAK,CAAC1C,IAAI,GAAGnB,SAAS,CAAC4D,KAAK,CAAC;UAC9G,OAAOxD,mBAAmB,CAAC2C,KAAK,EAAEjC,GAAG,CAACO,iBAAiB,CAAC;QAC1D;MACF,KAAKlB,WAAW,CAAC2D,oBAAoB;QACnC;UACE,OAAO1D,mBAAmB,CAACU,GAAG,CAACiD,QAAQ,EAAEjD,GAAG,CAACO,iBAAiB,CAAC;QACjE;MACF,KAAKlB,WAAW,CAAC6D,WAAW;QAC1B;UACE,MAAMC,UAAU,GAAG,IAAI,CAACjD,UAAU,CAACF,GAAG,CAACmD,UAAU,EAAElD,OAAO,CAAC;UAC3D,MAAMuB,SAAS,GAAG,GAAG,GAAG2B,UAAU,GAAG7D,mBAAmB,CAAC,GAAG,EAAEU,GAAG,CAACyB,kBAAkB,CAAC;UACrF,OAAOnC,mBAAmB,CAACkC,SAAS,EAAExB,GAAG,CAACO,iBAAiB,CAAC;QAC9D;MACF,KAAKlB,WAAW,CAAC+D,KAAK;QACpB;UACE,MAAMC,GAAG,GAAG,GAAG,GAAGrD,GAAG,CAACc,IAAI,CAACC,GAAG,CAACuC,GAAG,IAAIA,GAAG,CAACvC,GAAG,CAACwC,GAAG,IAAI,IAAI,CAACrD,UAAU,CAACqD,GAAG,EAAEtD,OAAO,CAAC,CAAC,CAACiB,IAAI,CAAC,IAAI,CAACvB,MAAM,CAAC6D,oBAAoB,CAAC,CAAC,CAACtC,IAAI,CAAC,IAAI,CAACvB,MAAM,CAAC8D,iBAAiB,CAAC,GAAGnE,mBAAmB,CAAC,GAAG,EAAEU,GAAG,CAACyB,kBAAkB,CAAC;UAClN,OAAOnC,mBAAmB,CAAC+D,GAAG,EAAErD,GAAG,CAACO,iBAAiB,CAAC;QACxD;MACF;QACE;UACE,MAAMmD,IAAI,GAAG,IAAI,CAACxD,UAAU,CAACF,GAAG,CAAC0D,IAAI,EAAEzD,OAAO,CAAC;UAC/C,MAAM0D,KAAK,GAAG,IAAI,CAACzD,UAAU,CAACF,GAAG,CAAC2D,KAAK,EAAE1D,OAAO,CAAC;UACjD,OAAOyD,IAAI,GAAGpE,mBAAmB,CAACE,gBAAgB,CAACQ,GAAG,CAACK,IAAI,CAAC,EAAEL,GAAG,CAACO,iBAAiB,CAAC,GAAGoD,KAAK;QAC9F;IACJ;EACF;EACAxB,gBAAgBA,CAACyB,OAAO,EAAE;IACxB,MAAMC,SAAS,GAAGzE,kBAAkB,CAACwE,OAAO,EAAE,IAAI,CAAC/D,cAAc,CAAC;IAClE,IAAIgE,SAAS,KAAK5C,SAAS,EAAE;MAC3B,MAAM,IAAI9B,kBAAkB,CAACyE,OAAO,CAAC;IACvC;IACA,OAAOC,SAAS;EAClB;EACApB,WAAWA,CAACzC,GAAG,EAAE8D,WAAW,EAAE;IAC5B,IAAIC,WAAW,GAAG,EAAE;IACpB,IAAIC,QAAQ,GAAG,EAAE;IACjB,IAAIhE,GAAG,CAACiE,KAAK,CAACnC,KAAK,KAAKb,SAAS,IAAIjB,GAAG,CAACkE,kBAAkB,KAAK3E,uBAAuB,CAAC4E,QAAQ,EAAE;MAChGJ,WAAW,GAAG,IAAI,CAAC5B,gBAAgB,CAACnC,GAAG,CAACiE,KAAK,CAACnC,KAAK,CAAC,GAAG,GAAG;IAC5D;IACA,IAAI9B,GAAG,CAACoE,GAAG,CAACtC,KAAK,KAAKb,SAAS,IAAIjB,GAAG,CAACkE,kBAAkB,KAAK3E,uBAAuB,CAAC8E,aAAa,EAAE;MACnGL,QAAQ,GAAG,IAAI,CAAC7B,gBAAgB,CAACnC,GAAG,CAACoE,GAAG,CAACtC,KAAK,CAAC,GAAG,GAAG;IACvD;IACA,MAAMwC,aAAa,GAAGtE,GAAG,CAACiE,KAAK,CAAClE,OAAO,CAAC+D,WAAW,CAAC;IACpD,MAAMS,WAAW,GAAGvE,GAAG,CAACoE,GAAG,CAACrE,OAAO,CAAC+D,WAAW,CAAC;IAChD,IAAIQ,aAAa,KAAKrD,SAAS,IAAIsD,WAAW,KAAKtD,SAAS,EAAE;MAC5D,OAAO,IAAI,CAACtB,MAAM,CAAC0B,kBAAkB,CAACe,mBAAmB,CAAClD,SAAS,CAACmD,GAAG,CAAC;IAC1E;IACA,OAAO,GAAG0B,WAAW,GAAGO,aAAa,IAAIN,QAAQ,GAAGO,WAAW,EAAE;EACnE;AACF;AACA,OAAO,SAAS9D,YAAYA,CAAC+D,MAAM,EAAE7D,gBAAgB,EAAE;EACrD,MAAM8D,aAAa,GAAGD,MAAM,CAACE,QAAQ,CAAC,CAAC;EACvC,OAAOD,aAAa,CAACE,OAAO,CAAC,GAAG,EAAEhE,gBAAgB,CAAC;AACrD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}