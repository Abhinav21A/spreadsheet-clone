{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AddressDependency, AstNodeType, CellRangeDependency, ColumnRangeDependency, NamedExpressionDependency, RowRangeDependency } from \".//index.mjs\";\nconst collectDependenciesFn = (ast, functionRegistry, dependenciesSet, needArgument) => {\n  switch (ast.type) {\n    case AstNodeType.EMPTY:\n    case AstNodeType.NUMBER:\n    case AstNodeType.STRING:\n    case AstNodeType.ERROR:\n      return;\n    case AstNodeType.NAMED_EXPRESSION:\n      {\n        if (needArgument) {\n          dependenciesSet.push(new NamedExpressionDependency(ast.expressionName));\n        }\n        return;\n      }\n    case AstNodeType.CELL_REFERENCE:\n      {\n        if (needArgument) {\n          dependenciesSet.push(new AddressDependency(ast.reference));\n        }\n        return;\n      }\n    case AstNodeType.CELL_RANGE:\n      {\n        if (needArgument && ast.start.sheet === ast.end.sheet) {\n          dependenciesSet.push(new CellRangeDependency(ast.start, ast.end));\n        }\n        return;\n      }\n    case AstNodeType.COLUMN_RANGE:\n      {\n        if (needArgument && ast.start.sheet === ast.end.sheet) {\n          dependenciesSet.push(new ColumnRangeDependency(ast.start, ast.end));\n        }\n        return;\n      }\n    case AstNodeType.ROW_RANGE:\n      {\n        if (needArgument && ast.start.sheet === ast.end.sheet) {\n          dependenciesSet.push(new RowRangeDependency(ast.start, ast.end));\n        }\n        return;\n      }\n    case AstNodeType.PERCENT_OP:\n    case AstNodeType.PLUS_UNARY_OP:\n    case AstNodeType.MINUS_UNARY_OP:\n      {\n        collectDependenciesFn(ast.value, functionRegistry, dependenciesSet, true);\n        return;\n      }\n    case AstNodeType.CONCATENATE_OP:\n    case AstNodeType.EQUALS_OP:\n    case AstNodeType.NOT_EQUAL_OP:\n    case AstNodeType.LESS_THAN_OP:\n    case AstNodeType.GREATER_THAN_OP:\n    case AstNodeType.LESS_THAN_OR_EQUAL_OP:\n    case AstNodeType.GREATER_THAN_OR_EQUAL_OP:\n    case AstNodeType.MINUS_OP:\n    case AstNodeType.PLUS_OP:\n    case AstNodeType.TIMES_OP:\n    case AstNodeType.DIV_OP:\n    case AstNodeType.POWER_OP:\n      collectDependenciesFn(ast.left, functionRegistry, dependenciesSet, true);\n      collectDependenciesFn(ast.right, functionRegistry, dependenciesSet, true);\n      return;\n    case AstNodeType.PARENTHESIS:\n      collectDependenciesFn(ast.expression, functionRegistry, dependenciesSet, needArgument);\n      return;\n    case AstNodeType.FUNCTION_CALL:\n      {\n        const functionNeedArgument = !functionRegistry.doesFunctionNeedArgumentToBeComputed(ast.procedureName);\n        ast.args.forEach(argAst => collectDependenciesFn(argAst, functionRegistry, dependenciesSet, functionNeedArgument));\n        return;\n      }\n  }\n};\nexport const collectDependencies = (ast, functionRegistry) => {\n  const result = new Array();\n  collectDependenciesFn(ast, functionRegistry, result, true);\n  return result;\n};","map":{"version":3,"names":["AddressDependency","AstNodeType","CellRangeDependency","ColumnRangeDependency","NamedExpressionDependency","RowRangeDependency","collectDependenciesFn","ast","functionRegistry","dependenciesSet","needArgument","type","EMPTY","NUMBER","STRING","ERROR","NAMED_EXPRESSION","push","expressionName","CELL_REFERENCE","reference","CELL_RANGE","start","sheet","end","COLUMN_RANGE","ROW_RANGE","PERCENT_OP","PLUS_UNARY_OP","MINUS_UNARY_OP","value","CONCATENATE_OP","EQUALS_OP","NOT_EQUAL_OP","LESS_THAN_OP","GREATER_THAN_OP","LESS_THAN_OR_EQUAL_OP","GREATER_THAN_OR_EQUAL_OP","MINUS_OP","PLUS_OP","TIMES_OP","DIV_OP","POWER_OP","left","right","PARENTHESIS","expression","FUNCTION_CALL","functionNeedArgument","doesFunctionNeedArgumentToBeComputed","procedureName","args","forEach","argAst","collectDependencies","result","Array"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/parser/collectDependencies.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AddressDependency, AstNodeType, CellRangeDependency, ColumnRangeDependency, NamedExpressionDependency, RowRangeDependency } from \".//index.mjs\";\nconst collectDependenciesFn = (ast, functionRegistry, dependenciesSet, needArgument) => {\n  switch (ast.type) {\n    case AstNodeType.EMPTY:\n    case AstNodeType.NUMBER:\n    case AstNodeType.STRING:\n    case AstNodeType.ERROR:\n      return;\n    case AstNodeType.NAMED_EXPRESSION:\n      {\n        if (needArgument) {\n          dependenciesSet.push(new NamedExpressionDependency(ast.expressionName));\n        }\n        return;\n      }\n    case AstNodeType.CELL_REFERENCE:\n      {\n        if (needArgument) {\n          dependenciesSet.push(new AddressDependency(ast.reference));\n        }\n        return;\n      }\n    case AstNodeType.CELL_RANGE:\n      {\n        if (needArgument && ast.start.sheet === ast.end.sheet) {\n          dependenciesSet.push(new CellRangeDependency(ast.start, ast.end));\n        }\n        return;\n      }\n    case AstNodeType.COLUMN_RANGE:\n      {\n        if (needArgument && ast.start.sheet === ast.end.sheet) {\n          dependenciesSet.push(new ColumnRangeDependency(ast.start, ast.end));\n        }\n        return;\n      }\n    case AstNodeType.ROW_RANGE:\n      {\n        if (needArgument && ast.start.sheet === ast.end.sheet) {\n          dependenciesSet.push(new RowRangeDependency(ast.start, ast.end));\n        }\n        return;\n      }\n    case AstNodeType.PERCENT_OP:\n    case AstNodeType.PLUS_UNARY_OP:\n    case AstNodeType.MINUS_UNARY_OP:\n      {\n        collectDependenciesFn(ast.value, functionRegistry, dependenciesSet, true);\n        return;\n      }\n    case AstNodeType.CONCATENATE_OP:\n    case AstNodeType.EQUALS_OP:\n    case AstNodeType.NOT_EQUAL_OP:\n    case AstNodeType.LESS_THAN_OP:\n    case AstNodeType.GREATER_THAN_OP:\n    case AstNodeType.LESS_THAN_OR_EQUAL_OP:\n    case AstNodeType.GREATER_THAN_OR_EQUAL_OP:\n    case AstNodeType.MINUS_OP:\n    case AstNodeType.PLUS_OP:\n    case AstNodeType.TIMES_OP:\n    case AstNodeType.DIV_OP:\n    case AstNodeType.POWER_OP:\n      collectDependenciesFn(ast.left, functionRegistry, dependenciesSet, true);\n      collectDependenciesFn(ast.right, functionRegistry, dependenciesSet, true);\n      return;\n    case AstNodeType.PARENTHESIS:\n      collectDependenciesFn(ast.expression, functionRegistry, dependenciesSet, needArgument);\n      return;\n    case AstNodeType.FUNCTION_CALL:\n      {\n        const functionNeedArgument = !functionRegistry.doesFunctionNeedArgumentToBeComputed(ast.procedureName);\n        ast.args.forEach(argAst => collectDependenciesFn(argAst, functionRegistry, dependenciesSet, functionNeedArgument));\n        return;\n      }\n  }\n};\nexport const collectDependencies = (ast, functionRegistry) => {\n  const result = new Array();\n  collectDependenciesFn(ast, functionRegistry, result, true);\n  return result;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}