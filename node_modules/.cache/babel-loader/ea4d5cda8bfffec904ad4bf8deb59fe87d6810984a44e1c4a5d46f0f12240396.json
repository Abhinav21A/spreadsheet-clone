{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from \"./AbsoluteCellRange.mjs\";\nimport { InterpreterState } from \"./interpreter/InterpreterState.mjs\";\nimport { FunctionArgumentType } from \"./interpreter/index.mjs\";\nimport { AstNodeType } from \"./parser/index.mjs\";\nexport class ArraySize {\n  constructor(width, height, isRef = false) {\n    this.width = width;\n    this.height = height;\n    this.isRef = isRef;\n  }\n  static error() {\n    return new ArraySize(1, 1, true);\n  }\n  static scalar() {\n    return new ArraySize(1, 1, false);\n  }\n  isScalar() {\n    return this.width === 1 && this.height === 1 || this.isRef;\n  }\n}\nfunction arraySizeForBinaryOp(leftArraySize, rightArraySize) {\n  return new ArraySize(Math.max(leftArraySize.width, rightArraySize.width), Math.max(leftArraySize.height, rightArraySize.height));\n}\nfunction arraySizeForUnaryOp(arraySize) {\n  return new ArraySize(arraySize.width, arraySize.height);\n}\nexport class ArraySizePredictor {\n  constructor(config, functionRegistry) {\n    this.config = config;\n    this.functionRegistry = functionRegistry;\n  }\n  checkArraySize(ast, formulaAddress) {\n    return this.checkArraySizeForAst(ast, {\n      formulaAddress,\n      arraysFlag: this.config.useArrayArithmetic\n    });\n  }\n  checkArraySizeForAst(ast, state) {\n    switch (ast.type) {\n      case AstNodeType.FUNCTION_CALL:\n        {\n          return this.checkArraySizeForFunction(ast, state);\n        }\n      case AstNodeType.COLUMN_RANGE:\n      case AstNodeType.ROW_RANGE:\n      case AstNodeType.CELL_RANGE:\n        {\n          const range = AbsoluteCellRange.fromAstOrUndef(ast, state.formulaAddress);\n          if (range === undefined) {\n            return ArraySize.error();\n          } else {\n            return new ArraySize(range.width(), range.height(), true);\n          }\n        }\n      case AstNodeType.ARRAY:\n        {\n          const heights = [];\n          const widths = [];\n          for (const row of ast.args) {\n            const sizes = row.map(ast => this.checkArraySizeForAst(ast, state));\n            const h = Math.min(...sizes.map(size => size.height));\n            const w = sizes.reduce((total, size) => total + size.width, 0);\n            heights.push(h);\n            widths.push(w);\n          }\n          const height = heights.reduce((total, h) => total + h, 0);\n          const width = Math.min(...widths);\n          return new ArraySize(width, height);\n        }\n      case AstNodeType.STRING:\n      case AstNodeType.NUMBER:\n        return ArraySize.scalar();\n      case AstNodeType.CELL_REFERENCE:\n        return new ArraySize(1, 1, true);\n      case AstNodeType.DIV_OP:\n      case AstNodeType.CONCATENATE_OP:\n      case AstNodeType.EQUALS_OP:\n      case AstNodeType.GREATER_THAN_OP:\n      case AstNodeType.GREATER_THAN_OR_EQUAL_OP:\n      case AstNodeType.LESS_THAN_OP:\n      case AstNodeType.LESS_THAN_OR_EQUAL_OP:\n      case AstNodeType.MINUS_OP:\n      case AstNodeType.NOT_EQUAL_OP:\n      case AstNodeType.PLUS_OP:\n      case AstNodeType.POWER_OP:\n      case AstNodeType.TIMES_OP:\n        {\n          const left = this.checkArraySizeForAst(ast.left, state);\n          const right = this.checkArraySizeForAst(ast.right, state);\n          if (!state.arraysFlag && (left.height > 1 || left.width > 1 || right.height > 1 || right.width > 1)) {\n            return ArraySize.error();\n          }\n          return arraySizeForBinaryOp(left, right);\n        }\n      case AstNodeType.MINUS_UNARY_OP:\n      case AstNodeType.PLUS_UNARY_OP:\n      case AstNodeType.PERCENT_OP:\n        {\n          const val = this.checkArraySizeForAst(ast.value, state);\n          if (!state.arraysFlag && (val.height > 1 || val.width > 1)) {\n            return ArraySize.error();\n          }\n          return arraySizeForUnaryOp(val);\n        }\n      case AstNodeType.PARENTHESIS:\n        {\n          return this.checkArraySizeForAst(ast.expression, state);\n        }\n      case AstNodeType.EMPTY:\n        return ArraySize.error();\n      default:\n        return ArraySize.error();\n    }\n  }\n  checkArraySizeForFunction(ast, state) {\n    const pluginArraySizeFunction = this.functionRegistry.getArraySizeFunction(ast.procedureName);\n    if (pluginArraySizeFunction !== undefined) {\n      return pluginArraySizeFunction(ast, state);\n    }\n    const metadata = this.functionRegistry.getMetadata(ast.procedureName);\n    if (metadata === undefined || metadata.expandRanges || !state.arraysFlag || metadata.vectorizationForbidden || metadata.parameters === undefined) {\n      return new ArraySize(1, 1);\n    }\n    const subChecks = ast.args.map(arg => {\n      var _a;\n      return this.checkArraySizeForAst(arg, new InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));\n    });\n    const argumentDefinitions = [...metadata.parameters];\n    if (metadata.repeatLastArgs !== undefined && argumentDefinitions.length < subChecks.length && (subChecks.length - argumentDefinitions.length) % metadata.repeatLastArgs !== 0) {\n      return ArraySize.error();\n    }\n    while (argumentDefinitions.length < subChecks.length) {\n      if (metadata.repeatLastArgs === undefined) {\n        return ArraySize.error();\n      }\n      argumentDefinitions.push(...argumentDefinitions.slice(argumentDefinitions.length - metadata.repeatLastArgs));\n    }\n    let maxWidth = 1;\n    let maxHeight = 1;\n    for (let i = 0; i < subChecks.length; i++) {\n      if (argumentDefinitions[i].argumentType !== FunctionArgumentType.RANGE && argumentDefinitions[i].argumentType !== FunctionArgumentType.ANY) {\n        maxHeight = Math.max(maxHeight, subChecks[i].height);\n        maxWidth = Math.max(maxWidth, subChecks[i].width);\n      }\n    }\n    return new ArraySize(maxWidth, maxHeight);\n  }\n}","map":{"version":3,"names":["AbsoluteCellRange","InterpreterState","FunctionArgumentType","AstNodeType","ArraySize","constructor","width","height","isRef","error","scalar","isScalar","arraySizeForBinaryOp","leftArraySize","rightArraySize","Math","max","arraySizeForUnaryOp","arraySize","ArraySizePredictor","config","functionRegistry","checkArraySize","ast","formulaAddress","checkArraySizeForAst","arraysFlag","useArrayArithmetic","state","type","FUNCTION_CALL","checkArraySizeForFunction","COLUMN_RANGE","ROW_RANGE","CELL_RANGE","range","fromAstOrUndef","undefined","ARRAY","heights","widths","row","args","sizes","map","h","min","size","w","reduce","total","push","STRING","NUMBER","CELL_REFERENCE","DIV_OP","CONCATENATE_OP","EQUALS_OP","GREATER_THAN_OP","GREATER_THAN_OR_EQUAL_OP","LESS_THAN_OP","LESS_THAN_OR_EQUAL_OP","MINUS_OP","NOT_EQUAL_OP","PLUS_OP","POWER_OP","TIMES_OP","left","right","MINUS_UNARY_OP","PLUS_UNARY_OP","PERCENT_OP","val","value","PARENTHESIS","expression","EMPTY","pluginArraySizeFunction","getArraySizeFunction","procedureName","metadata","getMetadata","expandRanges","vectorizationForbidden","parameters","subChecks","arg","_a","arrayFunction","argumentDefinitions","repeatLastArgs","length","slice","maxWidth","maxHeight","i","argumentType","RANGE","ANY"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/ArraySize.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from \"./AbsoluteCellRange.mjs\";\nimport { InterpreterState } from \"./interpreter/InterpreterState.mjs\";\nimport { FunctionArgumentType } from \"./interpreter/index.mjs\";\nimport { AstNodeType } from \"./parser/index.mjs\";\nexport class ArraySize {\n  constructor(width, height, isRef = false) {\n    this.width = width;\n    this.height = height;\n    this.isRef = isRef;\n  }\n  static error() {\n    return new ArraySize(1, 1, true);\n  }\n  static scalar() {\n    return new ArraySize(1, 1, false);\n  }\n  isScalar() {\n    return this.width === 1 && this.height === 1 || this.isRef;\n  }\n}\nfunction arraySizeForBinaryOp(leftArraySize, rightArraySize) {\n  return new ArraySize(Math.max(leftArraySize.width, rightArraySize.width), Math.max(leftArraySize.height, rightArraySize.height));\n}\nfunction arraySizeForUnaryOp(arraySize) {\n  return new ArraySize(arraySize.width, arraySize.height);\n}\nexport class ArraySizePredictor {\n  constructor(config, functionRegistry) {\n    this.config = config;\n    this.functionRegistry = functionRegistry;\n  }\n  checkArraySize(ast, formulaAddress) {\n    return this.checkArraySizeForAst(ast, {\n      formulaAddress,\n      arraysFlag: this.config.useArrayArithmetic\n    });\n  }\n  checkArraySizeForAst(ast, state) {\n    switch (ast.type) {\n      case AstNodeType.FUNCTION_CALL:\n        {\n          return this.checkArraySizeForFunction(ast, state);\n        }\n      case AstNodeType.COLUMN_RANGE:\n      case AstNodeType.ROW_RANGE:\n      case AstNodeType.CELL_RANGE:\n        {\n          const range = AbsoluteCellRange.fromAstOrUndef(ast, state.formulaAddress);\n          if (range === undefined) {\n            return ArraySize.error();\n          } else {\n            return new ArraySize(range.width(), range.height(), true);\n          }\n        }\n      case AstNodeType.ARRAY:\n        {\n          const heights = [];\n          const widths = [];\n          for (const row of ast.args) {\n            const sizes = row.map(ast => this.checkArraySizeForAst(ast, state));\n            const h = Math.min(...sizes.map(size => size.height));\n            const w = sizes.reduce((total, size) => total + size.width, 0);\n            heights.push(h);\n            widths.push(w);\n          }\n          const height = heights.reduce((total, h) => total + h, 0);\n          const width = Math.min(...widths);\n          return new ArraySize(width, height);\n        }\n      case AstNodeType.STRING:\n      case AstNodeType.NUMBER:\n        return ArraySize.scalar();\n      case AstNodeType.CELL_REFERENCE:\n        return new ArraySize(1, 1, true);\n      case AstNodeType.DIV_OP:\n      case AstNodeType.CONCATENATE_OP:\n      case AstNodeType.EQUALS_OP:\n      case AstNodeType.GREATER_THAN_OP:\n      case AstNodeType.GREATER_THAN_OR_EQUAL_OP:\n      case AstNodeType.LESS_THAN_OP:\n      case AstNodeType.LESS_THAN_OR_EQUAL_OP:\n      case AstNodeType.MINUS_OP:\n      case AstNodeType.NOT_EQUAL_OP:\n      case AstNodeType.PLUS_OP:\n      case AstNodeType.POWER_OP:\n      case AstNodeType.TIMES_OP:\n        {\n          const left = this.checkArraySizeForAst(ast.left, state);\n          const right = this.checkArraySizeForAst(ast.right, state);\n          if (!state.arraysFlag && (left.height > 1 || left.width > 1 || right.height > 1 || right.width > 1)) {\n            return ArraySize.error();\n          }\n          return arraySizeForBinaryOp(left, right);\n        }\n      case AstNodeType.MINUS_UNARY_OP:\n      case AstNodeType.PLUS_UNARY_OP:\n      case AstNodeType.PERCENT_OP:\n        {\n          const val = this.checkArraySizeForAst(ast.value, state);\n          if (!state.arraysFlag && (val.height > 1 || val.width > 1)) {\n            return ArraySize.error();\n          }\n          return arraySizeForUnaryOp(val);\n        }\n      case AstNodeType.PARENTHESIS:\n        {\n          return this.checkArraySizeForAst(ast.expression, state);\n        }\n      case AstNodeType.EMPTY:\n        return ArraySize.error();\n      default:\n        return ArraySize.error();\n    }\n  }\n  checkArraySizeForFunction(ast, state) {\n    const pluginArraySizeFunction = this.functionRegistry.getArraySizeFunction(ast.procedureName);\n    if (pluginArraySizeFunction !== undefined) {\n      return pluginArraySizeFunction(ast, state);\n    }\n    const metadata = this.functionRegistry.getMetadata(ast.procedureName);\n    if (metadata === undefined || metadata.expandRanges || !state.arraysFlag || metadata.vectorizationForbidden || metadata.parameters === undefined) {\n      return new ArraySize(1, 1);\n    }\n    const subChecks = ast.args.map(arg => {\n      var _a;\n      return this.checkArraySizeForAst(arg, new InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));\n    });\n    const argumentDefinitions = [...metadata.parameters];\n    if (metadata.repeatLastArgs !== undefined && argumentDefinitions.length < subChecks.length && (subChecks.length - argumentDefinitions.length) % metadata.repeatLastArgs !== 0) {\n      return ArraySize.error();\n    }\n    while (argumentDefinitions.length < subChecks.length) {\n      if (metadata.repeatLastArgs === undefined) {\n        return ArraySize.error();\n      }\n      argumentDefinitions.push(...argumentDefinitions.slice(argumentDefinitions.length - metadata.repeatLastArgs));\n    }\n    let maxWidth = 1;\n    let maxHeight = 1;\n    for (let i = 0; i < subChecks.length; i++) {\n      if (argumentDefinitions[i].argumentType !== FunctionArgumentType.RANGE && argumentDefinitions[i].argumentType !== FunctionArgumentType.ANY) {\n        maxHeight = Math.max(maxHeight, subChecks[i].height);\n        maxWidth = Math.max(maxWidth, subChecks[i].width);\n      }\n    }\n    return new ArraySize(maxWidth, maxHeight);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}