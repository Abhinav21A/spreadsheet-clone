{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { CellError, ErrorType } from \"../../Cell.mjs\";\nimport { ErrorMessage } from \"../../error-message.mjs\";\nimport { Condition, CriterionFunctionCompute } from \"../CriterionFunctionCompute.mjs\";\nimport { getRawValue, isExtendedNumber } from \"../InterpreterValue.mjs\";\nimport { FunctionArgumentType, FunctionPlugin } from \"./FunctionPlugin.mjs\";\nclass AverageResult {\n  constructor(sum, count) {\n    this.sum = sum;\n    this.count = count;\n  }\n  static single(arg) {\n    return new AverageResult(arg, 1);\n  }\n  compose(other) {\n    return new AverageResult(this.sum + other.sum, this.count + other.count);\n  }\n  averageValue() {\n    if (this.count > 0) {\n      return this.sum / this.count;\n    } else {\n      return undefined;\n    }\n  }\n}\nAverageResult.empty = new AverageResult(0, 0);\n/** Computes key for criterion function cache */\nfunction conditionalAggregationFunctionCacheKey(functionName) {\n  return conditions => {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const conditionsStrings = conditions.map(c => `${c.conditionRange.range.sheet},${c.conditionRange.range.start.col},${c.conditionRange.range.start.row}`);\n    return [functionName, ...conditionsStrings].join(',');\n  };\n}\nfunction zeroForInfinite(value) {\n  if (isExtendedNumber(value) && !Number.isFinite(getRawValue(value))) {\n    return 0;\n  } else {\n    return value;\n  }\n}\nfunction mapToRawScalarValue(arg) {\n  if (arg instanceof CellError) {\n    return arg;\n  }\n  if (isExtendedNumber(arg)) {\n    return getRawValue(arg);\n  }\n  return undefined;\n}\nexport class ConditionalAggregationPlugin extends FunctionPlugin {\n  /**\r\n   * Corresponds to SUMIF(Range, Criterion, SumRange)\r\n   *\r\n   * Range is the range to which criterion is to be applied.\r\n   * Criterion is the criteria used to choose which cells will be included in sum.\r\n   * SumRange is the range on which adding will be performed.\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  sumif(ast, state) {\n    const functionName = 'SUMIF';\n    const computeFn = (conditionRange, criterion, values) => this.computeConditionalAggregationFunction(values !== null && values !== void 0 ? values : conditionRange, [conditionRange, criterion], functionName, 0, (left, right) => this.arithmeticHelper.nonstrictadd(left, right), mapToRawScalarValue);\n    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);\n  }\n  sumifs(ast, state) {\n    const functionName = 'SUMIFS';\n    const computeFn = (values, ...args) => this.computeConditionalAggregationFunction(values, args, functionName, 0, (left, right) => this.arithmeticHelper.nonstrictadd(left, right), mapToRawScalarValue);\n    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);\n  }\n  averageif(ast, state) {\n    const functionName = 'AVERAGEIF';\n    const computeFn = (conditionRange, criterion, values) => {\n      const averageResult = this.computeConditionalAggregationFunction(values !== null && values !== void 0 ? values : conditionRange, [conditionRange, criterion], functionName, AverageResult.empty, (left, right) => left.compose(right), arg => isExtendedNumber(arg) ? AverageResult.single(getRawValue(arg)) : AverageResult.empty);\n      if (averageResult instanceof CellError) {\n        return averageResult;\n      } else {\n        return averageResult.averageValue() || new CellError(ErrorType.DIV_BY_ZERO);\n      }\n    };\n    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);\n  }\n  /**\r\n   * Corresponds to COUNTIF(Range, Criterion)\r\n   *\r\n   * Range is the range to which criterion is to be applied.\r\n   * Criterion is the criteria used to choose which cells will be included in sum.\r\n   *\r\n   * Returns number of cells on which criteria evaluate to true.\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  countif(ast, state) {\n    const functionName = 'COUNTIF';\n    const computeFn = (conditionRange, criterion) => this.computeConditionalAggregationFunction(conditionRange, [conditionRange, criterion], functionName, 0, (left, right) => left + right, () => 1);\n    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);\n  }\n  countifs(ast, state) {\n    const functionName = 'COUNTIFS';\n    const computeFn = (...args) => this.computeConditionalAggregationFunction(args[0], args, functionName, 0, (left, right) => left + right, () => 1);\n    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);\n  }\n  minifs(ast, state) {\n    const functionName = 'MINIFS';\n    const composeFunction = (left, right) => {\n      if (right === undefined || left === undefined) {\n        return right === undefined ? left : right;\n      }\n      return Math.min(left, right);\n    };\n    const computeFn = (values, ...args) => {\n      const minResult = this.computeConditionalAggregationFunction(values, args, functionName, Number.POSITIVE_INFINITY, composeFunction, mapToRawScalarValue);\n      return zeroForInfinite(minResult);\n    };\n    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);\n  }\n  maxifs(ast, state) {\n    const functionName = 'MAXIFS';\n    const composeFunction = (left, right) => {\n      if (right === undefined || left === undefined) {\n        return right === undefined ? left : right;\n      }\n      return Math.max(left, right);\n    };\n    const computeFn = (values, ...args) => {\n      const maxResult = this.computeConditionalAggregationFunction(values, args, functionName, Number.NEGATIVE_INFINITY, composeFunction, mapToRawScalarValue);\n      return zeroForInfinite(maxResult);\n    };\n    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);\n  }\n  computeConditionalAggregationFunction(valuesRange, conditionArgs, functionName, reduceInitialValue, composeFunction, mapFunction) {\n    const conditions = [];\n    for (let i = 0; i < conditionArgs.length; i += 2) {\n      const conditionArg = conditionArgs[i];\n      const criterionPackage = this.interpreter.criterionBuilder.fromCellValue(conditionArgs[i + 1], this.arithmeticHelper);\n      if (criterionPackage === undefined) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.BadCriterion);\n      }\n      conditions.push(new Condition(conditionArg, criterionPackage));\n    }\n    return new CriterionFunctionCompute(this.interpreter, conditionalAggregationFunctionCacheKey(functionName), reduceInitialValue, composeFunction, mapFunction).compute(valuesRange, conditions);\n  }\n}\nConditionalAggregationPlugin.implementedFunctions = {\n  SUMIF: {\n    method: 'sumif',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NOERROR\n    }, {\n      argumentType: FunctionArgumentType.RANGE,\n      optionalArg: true\n    }]\n  },\n  COUNTIF: {\n    method: 'countif',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NOERROR\n    }]\n  },\n  AVERAGEIF: {\n    method: 'averageif',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NOERROR\n    }, {\n      argumentType: FunctionArgumentType.RANGE,\n      optionalArg: true\n    }]\n  },\n  SUMIFS: {\n    method: 'sumifs',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NOERROR\n    }],\n    repeatLastArgs: 2\n  },\n  COUNTIFS: {\n    method: 'countifs',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NOERROR\n    }],\n    repeatLastArgs: 2\n  },\n  MINIFS: {\n    method: 'minifs',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NOERROR\n    }],\n    repeatLastArgs: 2\n  },\n  MAXIFS: {\n    method: 'maxifs',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NOERROR\n    }],\n    repeatLastArgs: 2\n  }\n};","map":{"version":3,"names":["CellError","ErrorType","ErrorMessage","Condition","CriterionFunctionCompute","getRawValue","isExtendedNumber","FunctionArgumentType","FunctionPlugin","AverageResult","constructor","sum","count","single","arg","compose","other","averageValue","undefined","empty","conditionalAggregationFunctionCacheKey","functionName","conditions","conditionsStrings","map","c","conditionRange","range","sheet","start","col","row","join","zeroForInfinite","value","Number","isFinite","mapToRawScalarValue","ConditionalAggregationPlugin","sumif","ast","state","computeFn","criterion","values","computeConditionalAggregationFunction","left","right","arithmeticHelper","nonstrictadd","runFunction","args","metadata","sumifs","averageif","averageResult","DIV_BY_ZERO","countif","countifs","minifs","composeFunction","Math","min","minResult","POSITIVE_INFINITY","maxifs","max","maxResult","NEGATIVE_INFINITY","valuesRange","conditionArgs","reduceInitialValue","mapFunction","i","length","conditionArg","criterionPackage","interpreter","criterionBuilder","fromCellValue","VALUE","BadCriterion","push","compute","implementedFunctions","SUMIF","method","parameters","argumentType","RANGE","NOERROR","optionalArg","COUNTIF","AVERAGEIF","SUMIFS","repeatLastArgs","COUNTIFS","MINIFS","MAXIFS"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/interpreter/plugin/ConditionalAggregationPlugin.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { CellError, ErrorType } from \"../../Cell.mjs\";\nimport { ErrorMessage } from \"../../error-message.mjs\";\nimport { Condition, CriterionFunctionCompute } from \"../CriterionFunctionCompute.mjs\";\nimport { getRawValue, isExtendedNumber } from \"../InterpreterValue.mjs\";\nimport { FunctionArgumentType, FunctionPlugin } from \"./FunctionPlugin.mjs\";\nclass AverageResult {\n  constructor(sum, count) {\n    this.sum = sum;\n    this.count = count;\n  }\n  static single(arg) {\n    return new AverageResult(arg, 1);\n  }\n  compose(other) {\n    return new AverageResult(this.sum + other.sum, this.count + other.count);\n  }\n  averageValue() {\n    if (this.count > 0) {\n      return this.sum / this.count;\n    } else {\n      return undefined;\n    }\n  }\n}\nAverageResult.empty = new AverageResult(0, 0);\n/** Computes key for criterion function cache */\nfunction conditionalAggregationFunctionCacheKey(functionName) {\n  return conditions => {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const conditionsStrings = conditions.map(c => `${c.conditionRange.range.sheet},${c.conditionRange.range.start.col},${c.conditionRange.range.start.row}`);\n    return [functionName, ...conditionsStrings].join(',');\n  };\n}\nfunction zeroForInfinite(value) {\n  if (isExtendedNumber(value) && !Number.isFinite(getRawValue(value))) {\n    return 0;\n  } else {\n    return value;\n  }\n}\nfunction mapToRawScalarValue(arg) {\n  if (arg instanceof CellError) {\n    return arg;\n  }\n  if (isExtendedNumber(arg)) {\n    return getRawValue(arg);\n  }\n  return undefined;\n}\nexport class ConditionalAggregationPlugin extends FunctionPlugin {\n  /**\r\n   * Corresponds to SUMIF(Range, Criterion, SumRange)\r\n   *\r\n   * Range is the range to which criterion is to be applied.\r\n   * Criterion is the criteria used to choose which cells will be included in sum.\r\n   * SumRange is the range on which adding will be performed.\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  sumif(ast, state) {\n    const functionName = 'SUMIF';\n    const computeFn = (conditionRange, criterion, values) => this.computeConditionalAggregationFunction(values !== null && values !== void 0 ? values : conditionRange, [conditionRange, criterion], functionName, 0, (left, right) => this.arithmeticHelper.nonstrictadd(left, right), mapToRawScalarValue);\n    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);\n  }\n  sumifs(ast, state) {\n    const functionName = 'SUMIFS';\n    const computeFn = (values, ...args) => this.computeConditionalAggregationFunction(values, args, functionName, 0, (left, right) => this.arithmeticHelper.nonstrictadd(left, right), mapToRawScalarValue);\n    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);\n  }\n  averageif(ast, state) {\n    const functionName = 'AVERAGEIF';\n    const computeFn = (conditionRange, criterion, values) => {\n      const averageResult = this.computeConditionalAggregationFunction(values !== null && values !== void 0 ? values : conditionRange, [conditionRange, criterion], functionName, AverageResult.empty, (left, right) => left.compose(right), arg => isExtendedNumber(arg) ? AverageResult.single(getRawValue(arg)) : AverageResult.empty);\n      if (averageResult instanceof CellError) {\n        return averageResult;\n      } else {\n        return averageResult.averageValue() || new CellError(ErrorType.DIV_BY_ZERO);\n      }\n    };\n    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);\n  }\n  /**\r\n   * Corresponds to COUNTIF(Range, Criterion)\r\n   *\r\n   * Range is the range to which criterion is to be applied.\r\n   * Criterion is the criteria used to choose which cells will be included in sum.\r\n   *\r\n   * Returns number of cells on which criteria evaluate to true.\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  countif(ast, state) {\n    const functionName = 'COUNTIF';\n    const computeFn = (conditionRange, criterion) => this.computeConditionalAggregationFunction(conditionRange, [conditionRange, criterion], functionName, 0, (left, right) => left + right, () => 1);\n    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);\n  }\n  countifs(ast, state) {\n    const functionName = 'COUNTIFS';\n    const computeFn = (...args) => this.computeConditionalAggregationFunction(args[0], args, functionName, 0, (left, right) => left + right, () => 1);\n    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);\n  }\n  minifs(ast, state) {\n    const functionName = 'MINIFS';\n    const composeFunction = (left, right) => {\n      if (right === undefined || left === undefined) {\n        return right === undefined ? left : right;\n      }\n      return Math.min(left, right);\n    };\n    const computeFn = (values, ...args) => {\n      const minResult = this.computeConditionalAggregationFunction(values, args, functionName, Number.POSITIVE_INFINITY, composeFunction, mapToRawScalarValue);\n      return zeroForInfinite(minResult);\n    };\n    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);\n  }\n  maxifs(ast, state) {\n    const functionName = 'MAXIFS';\n    const composeFunction = (left, right) => {\n      if (right === undefined || left === undefined) {\n        return right === undefined ? left : right;\n      }\n      return Math.max(left, right);\n    };\n    const computeFn = (values, ...args) => {\n      const maxResult = this.computeConditionalAggregationFunction(values, args, functionName, Number.NEGATIVE_INFINITY, composeFunction, mapToRawScalarValue);\n      return zeroForInfinite(maxResult);\n    };\n    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);\n  }\n  computeConditionalAggregationFunction(valuesRange, conditionArgs, functionName, reduceInitialValue, composeFunction, mapFunction) {\n    const conditions = [];\n    for (let i = 0; i < conditionArgs.length; i += 2) {\n      const conditionArg = conditionArgs[i];\n      const criterionPackage = this.interpreter.criterionBuilder.fromCellValue(conditionArgs[i + 1], this.arithmeticHelper);\n      if (criterionPackage === undefined) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.BadCriterion);\n      }\n      conditions.push(new Condition(conditionArg, criterionPackage));\n    }\n    return new CriterionFunctionCompute(this.interpreter, conditionalAggregationFunctionCacheKey(functionName), reduceInitialValue, composeFunction, mapFunction).compute(valuesRange, conditions);\n  }\n}\nConditionalAggregationPlugin.implementedFunctions = {\n  SUMIF: {\n    method: 'sumif',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NOERROR\n    }, {\n      argumentType: FunctionArgumentType.RANGE,\n      optionalArg: true\n    }]\n  },\n  COUNTIF: {\n    method: 'countif',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NOERROR\n    }]\n  },\n  AVERAGEIF: {\n    method: 'averageif',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NOERROR\n    }, {\n      argumentType: FunctionArgumentType.RANGE,\n      optionalArg: true\n    }]\n  },\n  SUMIFS: {\n    method: 'sumifs',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NOERROR\n    }],\n    repeatLastArgs: 2\n  },\n  COUNTIFS: {\n    method: 'countifs',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NOERROR\n    }],\n    repeatLastArgs: 2\n  },\n  MINIFS: {\n    method: 'minifs',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NOERROR\n    }],\n    repeatLastArgs: 2\n  },\n  MAXIFS: {\n    method: 'maxifs',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NOERROR\n    }],\n    repeatLastArgs: 2\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}