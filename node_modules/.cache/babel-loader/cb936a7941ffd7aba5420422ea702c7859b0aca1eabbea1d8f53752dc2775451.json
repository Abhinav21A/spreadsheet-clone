{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { addressKey } from \"../Cell.mjs\";\nexport class ArrayMapping {\n  constructor() {\n    this.arrayMapping = new Map();\n  }\n  getArray(range) {\n    const array = this.getArrayByCorner(range.start);\n    if (array === null || array === void 0 ? void 0 : array.getRange().sameAs(range)) {\n      return array;\n    }\n    return;\n  }\n  getArrayByCorner(address) {\n    return this.arrayMapping.get(addressKey(address));\n  }\n  setArray(range, vertex) {\n    this.arrayMapping.set(addressKey(range.start), vertex);\n  }\n  removeArray(range) {\n    if (typeof range === 'string') {\n      this.arrayMapping.delete(range);\n    } else {\n      this.arrayMapping.delete(addressKey(range.start));\n    }\n  }\n  count() {\n    return this.arrayMapping.size;\n  }\n  *arraysInRows(rowsSpan) {\n    for (const [mtxKey, mtx] of this.arrayMapping.entries()) {\n      if (mtx.spansThroughSheetRows(rowsSpan.sheet, rowsSpan.rowStart, rowsSpan.rowEnd)) {\n        yield [mtxKey, mtx];\n      }\n    }\n  }\n  *arraysInCols(col) {\n    for (const [mtxKey, mtx] of this.arrayMapping.entries()) {\n      if (mtx.spansThroughSheetColumn(col.sheet, col.columnStart, col.columnEnd)) {\n        yield [mtxKey, mtx];\n      }\n    }\n  }\n  isFormulaArrayInRow(sheet, row) {\n    for (const mtx of this.arrayMapping.values()) {\n      if (mtx.spansThroughSheetRows(sheet, row)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  isFormulaArrayInAllRows(span) {\n    let result = true;\n    for (const row of span.rows()) {\n      if (!this.isFormulaArrayInRow(span.sheet, row)) {\n        result = false;\n      }\n    }\n    return result;\n  }\n  isFormulaArrayInColumn(sheet, column) {\n    for (const mtx of this.arrayMapping.values()) {\n      if (mtx.spansThroughSheetColumn(sheet, column)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  isFormulaArrayInAllColumns(span) {\n    let result = true;\n    for (const col of span.columns()) {\n      if (!this.isFormulaArrayInColumn(span.sheet, col)) {\n        result = false;\n      }\n    }\n    return result;\n  }\n  isFormulaArrayInRange(range) {\n    for (const mtx of this.arrayMapping.values()) {\n      if (mtx.getRange().doesOverlap(range)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  isFormulaArrayAtAddress(address) {\n    for (const mtx of this.arrayMapping.values()) {\n      if (mtx.getRange().addressInRange(address)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  moveArrayVerticesAfterRowByRows(sheet, row, numberOfRows) {\n    this.updateArrayVerticesInSheet(sheet, (key, vertex) => {\n      const range = vertex.getRange();\n      return row <= range.start.row ? [range.shifted(0, numberOfRows), vertex] : undefined;\n    });\n  }\n  moveArrayVerticesAfterColumnByColumns(sheet, column, numberOfColumns) {\n    this.updateArrayVerticesInSheet(sheet, (key, vertex) => {\n      const range = vertex.getRange();\n      return column <= range.start.col ? [range.shifted(numberOfColumns, 0), vertex] : undefined;\n    });\n  }\n  updateArrayVerticesInSheet(sheet, fn) {\n    const updated = Array();\n    for (const [key, vertex] of this.arrayMapping.entries()) {\n      if (vertex.sheet !== sheet) {\n        continue;\n      }\n      const result = fn(key, vertex);\n      if (result !== undefined) {\n        this.removeArray(key);\n        updated.push(result);\n      }\n    }\n    updated.forEach(([range, array]) => {\n      this.setArray(range, array);\n    });\n  }\n}","map":{"version":3,"names":["addressKey","ArrayMapping","constructor","arrayMapping","Map","getArray","range","array","getArrayByCorner","start","getRange","sameAs","address","get","setArray","vertex","set","removeArray","delete","count","size","arraysInRows","rowsSpan","mtxKey","mtx","entries","spansThroughSheetRows","sheet","rowStart","rowEnd","arraysInCols","col","spansThroughSheetColumn","columnStart","columnEnd","isFormulaArrayInRow","row","values","isFormulaArrayInAllRows","span","result","rows","isFormulaArrayInColumn","column","isFormulaArrayInAllColumns","columns","isFormulaArrayInRange","doesOverlap","isFormulaArrayAtAddress","addressInRange","moveArrayVerticesAfterRowByRows","numberOfRows","updateArrayVerticesInSheet","key","shifted","undefined","moveArrayVerticesAfterColumnByColumns","numberOfColumns","fn","updated","Array","push","forEach"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/DependencyGraph/ArrayMapping.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { addressKey } from \"../Cell.mjs\";\nexport class ArrayMapping {\n  constructor() {\n    this.arrayMapping = new Map();\n  }\n  getArray(range) {\n    const array = this.getArrayByCorner(range.start);\n    if (array === null || array === void 0 ? void 0 : array.getRange().sameAs(range)) {\n      return array;\n    }\n    return;\n  }\n  getArrayByCorner(address) {\n    return this.arrayMapping.get(addressKey(address));\n  }\n  setArray(range, vertex) {\n    this.arrayMapping.set(addressKey(range.start), vertex);\n  }\n  removeArray(range) {\n    if (typeof range === 'string') {\n      this.arrayMapping.delete(range);\n    } else {\n      this.arrayMapping.delete(addressKey(range.start));\n    }\n  }\n  count() {\n    return this.arrayMapping.size;\n  }\n  *arraysInRows(rowsSpan) {\n    for (const [mtxKey, mtx] of this.arrayMapping.entries()) {\n      if (mtx.spansThroughSheetRows(rowsSpan.sheet, rowsSpan.rowStart, rowsSpan.rowEnd)) {\n        yield [mtxKey, mtx];\n      }\n    }\n  }\n  *arraysInCols(col) {\n    for (const [mtxKey, mtx] of this.arrayMapping.entries()) {\n      if (mtx.spansThroughSheetColumn(col.sheet, col.columnStart, col.columnEnd)) {\n        yield [mtxKey, mtx];\n      }\n    }\n  }\n  isFormulaArrayInRow(sheet, row) {\n    for (const mtx of this.arrayMapping.values()) {\n      if (mtx.spansThroughSheetRows(sheet, row)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  isFormulaArrayInAllRows(span) {\n    let result = true;\n    for (const row of span.rows()) {\n      if (!this.isFormulaArrayInRow(span.sheet, row)) {\n        result = false;\n      }\n    }\n    return result;\n  }\n  isFormulaArrayInColumn(sheet, column) {\n    for (const mtx of this.arrayMapping.values()) {\n      if (mtx.spansThroughSheetColumn(sheet, column)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  isFormulaArrayInAllColumns(span) {\n    let result = true;\n    for (const col of span.columns()) {\n      if (!this.isFormulaArrayInColumn(span.sheet, col)) {\n        result = false;\n      }\n    }\n    return result;\n  }\n  isFormulaArrayInRange(range) {\n    for (const mtx of this.arrayMapping.values()) {\n      if (mtx.getRange().doesOverlap(range)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  isFormulaArrayAtAddress(address) {\n    for (const mtx of this.arrayMapping.values()) {\n      if (mtx.getRange().addressInRange(address)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  moveArrayVerticesAfterRowByRows(sheet, row, numberOfRows) {\n    this.updateArrayVerticesInSheet(sheet, (key, vertex) => {\n      const range = vertex.getRange();\n      return row <= range.start.row ? [range.shifted(0, numberOfRows), vertex] : undefined;\n    });\n  }\n  moveArrayVerticesAfterColumnByColumns(sheet, column, numberOfColumns) {\n    this.updateArrayVerticesInSheet(sheet, (key, vertex) => {\n      const range = vertex.getRange();\n      return column <= range.start.col ? [range.shifted(numberOfColumns, 0), vertex] : undefined;\n    });\n  }\n  updateArrayVerticesInSheet(sheet, fn) {\n    const updated = Array();\n    for (const [key, vertex] of this.arrayMapping.entries()) {\n      if (vertex.sheet !== sheet) {\n        continue;\n      }\n      const result = fn(key, vertex);\n      if (result !== undefined) {\n        this.removeArray(key);\n        updated.push(result);\n      }\n    }\n    updated.forEach(([range, array]) => {\n      this.setArray(range, array);\n    });\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}