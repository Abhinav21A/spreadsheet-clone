{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from \"../../AbsoluteCellRange.mjs\";\nimport { CellError, ErrorType } from \"../../Cell.mjs\";\nimport { ErrorMessage } from \"../../error-message.mjs\";\nimport { SheetsNotEqual } from \"../../errors.mjs\";\nimport { AstNodeType } from \"../../parser/index.mjs\";\nimport { coerceBooleanToNumber } from \"../ArithmeticHelper.mjs\";\nimport { EmptyValue, getRawValue, isExtendedNumber } from \"../InterpreterValue.mjs\";\nimport { SimpleRangeValue } from \"../../SimpleRangeValue.mjs\";\nimport { FunctionArgumentType, FunctionPlugin } from \"./FunctionPlugin.mjs\";\nfunction zeroForInfinite(value) {\n  if (isExtendedNumber(value) && !Number.isFinite(getRawValue(value))) {\n    return 0;\n  } else {\n    return value;\n  }\n}\nclass MomentsAggregate {\n  constructor(sumsq, sum, count) {\n    this.sumsq = sumsq;\n    this.sum = sum;\n    this.count = count;\n  }\n  static single(arg) {\n    return new MomentsAggregate(arg * arg, arg, 1);\n  }\n  compose(other) {\n    return new MomentsAggregate(this.sumsq + other.sumsq, this.sum + other.sum, this.count + other.count);\n  }\n  averageValue() {\n    if (this.count > 0) {\n      return this.sum / this.count;\n    } else {\n      return undefined;\n    }\n  }\n  varSValue() {\n    if (this.count > 1) {\n      return (this.sumsq - this.sum * this.sum / this.count) / (this.count - 1);\n    } else {\n      return undefined;\n    }\n  }\n  varPValue() {\n    if (this.count > 0) {\n      return (this.sumsq - this.sum * this.sum / this.count) / this.count;\n    } else {\n      return undefined;\n    }\n  }\n}\nMomentsAggregate.empty = new MomentsAggregate(0, 0, 0);\nexport class NumericAggregationPlugin extends FunctionPlugin {\n  constructor() {\n    super(...arguments);\n    this.addWithEpsilonRaw = (left, right) => this.arithmeticHelper.addWithEpsilonRaw(left, right);\n  }\n  /**\r\n   * Corresponds to SUM(Number1, Number2, ...).\r\n   *\r\n   * Returns a sum of given numbers.\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  sum(ast, state) {\n    return this.doSum(ast.args, state);\n  }\n  sumsq(ast, state) {\n    return this.reduce(ast.args, state, 0, 'SUMSQ', this.addWithEpsilonRaw, arg => Math.pow(getRawValue(arg), 2), strictlyNumbers);\n  }\n  /**\r\n   * Corresponds to MAX(Number1, Number2, ...).\r\n   *\r\n   * Returns a max of given numbers.\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  max(ast, state) {\n    return this.doMax(ast.args, state);\n  }\n  maxa(ast, state) {\n    const value = this.reduce(ast.args, state, Number.NEGATIVE_INFINITY, 'MAXA', (left, right) => Math.max(left, right), getRawValue, numbersBooleans);\n    return zeroForInfinite(value);\n  }\n  /**\r\n   * Corresponds to MIN(Number1, Number2, ...).\r\n   *\r\n   * Returns a min of given numbers.\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  min(ast, state) {\n    return this.doMin(ast.args, state);\n  }\n  mina(ast, state) {\n    const value = this.reduce(ast.args, state, Number.POSITIVE_INFINITY, 'MINA', (left, right) => Math.min(left, right), getRawValue, numbersBooleans);\n    return zeroForInfinite(value);\n  }\n  count(ast, state) {\n    return this.doCount(ast.args, state);\n  }\n  counta(ast, state) {\n    return this.doCounta(ast.args, state);\n  }\n  average(ast, state) {\n    return this.doAverage(ast.args, state);\n  }\n  averagea(ast, state) {\n    var _a;\n    const result = this.reduce(ast.args, state, MomentsAggregate.empty, '_AGGREGATE_A', (left, right) => left.compose(right), arg => MomentsAggregate.single(getRawValue(arg)), numbersBooleans);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      return (_a = result.averageValue()) !== null && _a !== void 0 ? _a : new CellError(ErrorType.DIV_BY_ZERO);\n    }\n  }\n  vars(ast, state) {\n    return this.doVarS(ast.args, state);\n  }\n  varp(ast, state) {\n    return this.doVarP(ast.args, state);\n  }\n  vara(ast, state) {\n    var _a;\n    const result = this.reduceAggregateA(ast.args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      return (_a = result.varSValue()) !== null && _a !== void 0 ? _a : new CellError(ErrorType.DIV_BY_ZERO);\n    }\n  }\n  varpa(ast, state) {\n    var _a;\n    const result = this.reduceAggregateA(ast.args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      return (_a = result.varPValue()) !== null && _a !== void 0 ? _a : new CellError(ErrorType.DIV_BY_ZERO);\n    }\n  }\n  stdevs(ast, state) {\n    return this.doStdevS(ast.args, state);\n  }\n  stdevp(ast, state) {\n    return this.doStdevP(ast.args, state);\n  }\n  stdeva(ast, state) {\n    const result = this.reduceAggregateA(ast.args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      const val = result.varSValue();\n      return val === undefined ? new CellError(ErrorType.DIV_BY_ZERO) : Math.sqrt(val);\n    }\n  }\n  stdevpa(ast, state) {\n    const result = this.reduceAggregateA(ast.args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      const val = result.varPValue();\n      return val === undefined ? new CellError(ErrorType.DIV_BY_ZERO) : Math.sqrt(val);\n    }\n  }\n  product(ast, state) {\n    return this.doProduct(ast.args, state);\n  }\n  subtotal(ast, state) {\n    if (ast.args.length < 2) {\n      return new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);\n    }\n    const functionType = this.coerceToType(this.evaluateAst(ast.args[0], state), {\n      argumentType: FunctionArgumentType.NUMBER\n    }, state);\n    const args = ast.args.slice(1);\n    switch (functionType) {\n      case 1:\n      case 101:\n        return this.doAverage(args, state);\n      case 2:\n      case 102:\n        return this.doCount(args, state);\n      case 3:\n      case 103:\n        return this.doCounta(args, state);\n      case 4:\n      case 104:\n        return this.doMax(args, state);\n      case 5:\n      case 105:\n        return this.doMin(args, state);\n      case 6:\n      case 106:\n        return this.doProduct(args, state);\n      case 7:\n      case 107:\n        return this.doStdevS(args, state);\n      case 8:\n      case 108:\n        return this.doStdevP(args, state);\n      case 9:\n      case 109:\n        return this.doSum(args, state);\n      case 10:\n      case 110:\n        return this.doVarS(args, state);\n      case 11:\n      case 111:\n        return this.doVarP(args, state);\n      default:\n        return new CellError(ErrorType.VALUE, ErrorMessage.BadMode);\n    }\n  }\n  reduceAggregate(args, state) {\n    return this.reduce(args, state, MomentsAggregate.empty, '_AGGREGATE', (left, right) => {\n      return left.compose(right);\n    }, arg => {\n      return MomentsAggregate.single(getRawValue(arg));\n    }, strictlyNumbers);\n  }\n  reduceAggregateA(args, state) {\n    return this.reduce(args, state, MomentsAggregate.empty, '_AGGREGATE_A', (left, right) => {\n      return left.compose(right);\n    }, arg => {\n      return MomentsAggregate.single(getRawValue(arg));\n    }, numbersBooleans);\n  }\n  doAverage(args, state) {\n    var _a;\n    const result = this.reduceAggregate(args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      return (_a = result.averageValue()) !== null && _a !== void 0 ? _a : new CellError(ErrorType.DIV_BY_ZERO);\n    }\n  }\n  doVarS(args, state) {\n    var _a;\n    const result = this.reduceAggregate(args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      return (_a = result.varSValue()) !== null && _a !== void 0 ? _a : new CellError(ErrorType.DIV_BY_ZERO);\n    }\n  }\n  doVarP(args, state) {\n    var _a;\n    const result = this.reduceAggregate(args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      return (_a = result.varPValue()) !== null && _a !== void 0 ? _a : new CellError(ErrorType.DIV_BY_ZERO);\n    }\n  }\n  doStdevS(args, state) {\n    const result = this.reduceAggregate(args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      const val = result.varSValue();\n      return val === undefined ? new CellError(ErrorType.DIV_BY_ZERO) : Math.sqrt(val);\n    }\n  }\n  doStdevP(args, state) {\n    const result = this.reduceAggregate(args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      const val = result.varPValue();\n      return val === undefined ? new CellError(ErrorType.DIV_BY_ZERO) : Math.sqrt(val);\n    }\n  }\n  doCount(args, state) {\n    return this.reduce(args, state, 0, 'COUNT', (left, right) => left + right, getRawValue, arg => isExtendedNumber(arg) ? 1 : 0);\n  }\n  doCounta(args, state) {\n    return this.reduce(args, state, 0, 'COUNTA', (left, right) => left + right, getRawValue, arg => arg === EmptyValue ? 0 : 1);\n  }\n  doMax(args, state) {\n    const value = this.reduce(args, state, Number.NEGATIVE_INFINITY, 'MAX', (left, right) => Math.max(left, right), getRawValue, strictlyNumbers);\n    return zeroForInfinite(value);\n  }\n  doMin(args, state) {\n    const value = this.reduce(args, state, Number.POSITIVE_INFINITY, 'MIN', (left, right) => Math.min(left, right), getRawValue, strictlyNumbers);\n    return zeroForInfinite(value);\n  }\n  doSum(args, state) {\n    return this.reduce(args, state, 0, 'SUM', this.addWithEpsilonRaw, getRawValue, strictlyNumbers);\n  }\n  doProduct(args, state) {\n    return this.reduce(args, state, 1, 'PRODUCT', (left, right) => left * right, getRawValue, strictlyNumbers);\n  }\n  /**\r\n   * Reduces procedure arguments with given reducing function\r\n   *\r\n   * @param args\r\n   * @param state\r\n   * @param initialAccValue - \"neutral\" value (equivalent of 0)\r\n   * @param functionName - function name to use as cache key\r\n   * @param reducingFunction - reducing function\r\n   * @param mapFunction\r\n   * @param coercionFunction\r\n   */\n  reduce(args, state, initialAccValue, functionName, reducingFunction, mapFunction, coercionFunction) {\n    if (args.length < 1) {\n      return new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);\n    }\n    return args.reduce((acc, arg) => {\n      if (acc instanceof CellError) {\n        return acc;\n      }\n      if (arg.type === AstNodeType.CELL_RANGE || arg.type === AstNodeType.COLUMN_RANGE || arg.type === AstNodeType.ROW_RANGE) {\n        const val = this.evaluateRange(arg, state, initialAccValue, functionName, reducingFunction, mapFunction, coercionFunction);\n        if (val instanceof CellError) {\n          return val;\n        }\n        return reducingFunction(val, acc);\n      }\n      let value;\n      value = this.evaluateAst(arg, state);\n      if (value instanceof SimpleRangeValue) {\n        const coercedRangeValues = Array.from(value.valuesFromTopLeftCorner()).map(coercionFunction).filter(arg => arg !== undefined);\n        return coercedRangeValues.map(arg => {\n          if (arg instanceof CellError) {\n            return arg;\n          } else {\n            return mapFunction(arg);\n          }\n        }).reduce((left, right) => {\n          if (left instanceof CellError) {\n            return left;\n          } else if (right instanceof CellError) {\n            return right;\n          } else {\n            return reducingFunction(left, right);\n          }\n        }, acc);\n      } else if (arg.type === AstNodeType.CELL_REFERENCE) {\n        value = coercionFunction(value);\n        if (value === undefined) {\n          return acc;\n        }\n      } else {\n        value = this.coerceScalarToNumberOrError(value);\n        value = coercionFunction(value);\n        if (value === undefined) {\n          return acc;\n        }\n      }\n      if (value instanceof CellError) {\n        return value;\n      }\n      return reducingFunction(acc, mapFunction(value));\n    }, initialAccValue);\n  }\n  /**\r\n   * Performs range operation on given range\r\n   *\r\n   * @param ast - cell range ast\r\n   * @param state\r\n   * @param initialAccValue - initial accumulator value for reducing function\r\n   * @param functionName - function name to use as cache key\r\n   * @param reducingFunction - reducing function\r\n   * @param mapFunction\r\n   * @param coercionFunction\r\n   */\n  evaluateRange(ast, state, initialAccValue, functionName, reducingFunction, mapFunction, coercionFunction) {\n    let range;\n    try {\n      range = AbsoluteCellRange.fromAst(ast, state.formulaAddress);\n    } catch (err) {\n      if (err instanceof SheetsNotEqual) {\n        return new CellError(ErrorType.REF, ErrorMessage.RangeManySheets);\n      } else {\n        throw err;\n      }\n    }\n    const rangeVertex = this.dependencyGraph.getRange(range.start, range.end);\n    if (rangeVertex === undefined) {\n      throw new Error('Range does not exists in graph');\n    }\n    let value = rangeVertex.getFunctionValue(functionName);\n    if (value === undefined) {\n      const rangeValues = this.getRangeValues(functionName, range, rangeVertex, mapFunction, coercionFunction);\n      value = rangeValues.reduce((arg1, arg2) => {\n        if (arg1 instanceof CellError) {\n          return arg1;\n        } else if (arg2 instanceof CellError) {\n          return arg2;\n        } else {\n          return reducingFunction(arg1, arg2);\n        }\n      }, initialAccValue);\n      rangeVertex.setFunctionValue(functionName, value);\n    }\n    return value;\n  }\n  /**\r\n   * Returns list of values for given range and function name\r\n   *\r\n   * If range is dependent on smaller range, list will contain value of smaller range for this function\r\n   * and values of cells that are not present in smaller range\r\n   *\r\n   * @param functionName - function name (e.g., SUM)\r\n   * @param range - cell range\r\n   * @param rangeVertex\r\n   * @param mapFunction\r\n   * @param coercionFunction\r\n   */\n  getRangeValues(functionName, range, rangeVertex, mapFunction, coercionFunction) {\n    const rangeResult = [];\n    const {\n      smallerRangeVertex,\n      restRange\n    } = this.dependencyGraph.rangeMapping.findSmallerRange(range);\n    let actualRange;\n    if (smallerRangeVertex !== undefined && this.dependencyGraph.existsEdge(smallerRangeVertex, rangeVertex)) {\n      const cachedValue = smallerRangeVertex.getFunctionValue(functionName);\n      if (cachedValue !== undefined) {\n        rangeResult.push(cachedValue);\n      } else {\n        for (const cellFromRange of smallerRangeVertex.range.addresses(this.dependencyGraph)) {\n          const val = coercionFunction(this.dependencyGraph.getScalarValue(cellFromRange));\n          if (val instanceof CellError) {\n            rangeResult.push(val);\n          } else if (val !== undefined) {\n            rangeResult.push(mapFunction(val));\n          }\n        }\n      }\n      actualRange = restRange;\n    } else {\n      actualRange = range;\n    }\n    for (const cellFromRange of actualRange.addresses(this.dependencyGraph)) {\n      const val = coercionFunction(this.dependencyGraph.getScalarValue(cellFromRange));\n      if (val instanceof CellError) {\n        rangeResult.push(val);\n      } else if (val !== undefined) {\n        rangeResult.push(mapFunction(val));\n      }\n    }\n    return rangeResult;\n  }\n}\nNumericAggregationPlugin.implementedFunctions = {\n  'SUM': {\n    method: 'sum',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'SUMSQ': {\n    method: 'sumsq',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'MAX': {\n    method: 'max',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'MIN': {\n    method: 'min',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'MAXA': {\n    method: 'maxa',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'MINA': {\n    method: 'mina',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'COUNT': {\n    method: 'count',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'COUNTA': {\n    method: 'counta',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'AVERAGE': {\n    method: 'average',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'AVERAGEA': {\n    method: 'averagea',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'PRODUCT': {\n    method: 'product',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'VAR.S': {\n    method: 'vars',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'VAR.P': {\n    method: 'varp',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'VARA': {\n    method: 'vara',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'VARPA': {\n    method: 'varpa',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'STDEV.S': {\n    method: 'stdevs',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'STDEV.P': {\n    method: 'stdevp',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'STDEVA': {\n    method: 'stdeva',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'STDEVPA': {\n    method: 'stdevpa',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'SUBTOTAL': {\n    method: 'subtotal',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  }\n};\nNumericAggregationPlugin.aliases = {\n  VAR: 'VAR.S',\n  VARP: 'VAR.P',\n  STDEV: 'STDEV.S',\n  STDEVP: 'STDEV.P',\n  VARS: 'VAR.S',\n  STDEVS: 'STDEV.S'\n};\nfunction strictlyNumbers(arg) {\n  if (isExtendedNumber(arg) || arg instanceof CellError) {\n    return arg;\n  } else {\n    return undefined;\n  }\n}\nfunction numbersBooleans(arg) {\n  if (typeof arg === 'boolean') {\n    return coerceBooleanToNumber(arg);\n  } else if (isExtendedNumber(arg) || arg instanceof CellError) {\n    return arg;\n  } else if (typeof arg === 'string') {\n    return 0;\n  } else {\n    return undefined;\n  }\n}","map":{"version":3,"names":["AbsoluteCellRange","CellError","ErrorType","ErrorMessage","SheetsNotEqual","AstNodeType","coerceBooleanToNumber","EmptyValue","getRawValue","isExtendedNumber","SimpleRangeValue","FunctionArgumentType","FunctionPlugin","zeroForInfinite","value","Number","isFinite","MomentsAggregate","constructor","sumsq","sum","count","single","arg","compose","other","averageValue","undefined","varSValue","varPValue","empty","NumericAggregationPlugin","arguments","addWithEpsilonRaw","left","right","arithmeticHelper","ast","state","doSum","args","reduce","Math","pow","strictlyNumbers","max","doMax","maxa","NEGATIVE_INFINITY","numbersBooleans","min","doMin","mina","POSITIVE_INFINITY","doCount","counta","doCounta","average","doAverage","averagea","_a","result","DIV_BY_ZERO","vars","doVarS","varp","doVarP","vara","reduceAggregateA","varpa","stdevs","doStdevS","stdevp","doStdevP","stdeva","val","sqrt","stdevpa","product","doProduct","subtotal","length","NA","WrongArgNumber","functionType","coerceToType","evaluateAst","argumentType","NUMBER","slice","VALUE","BadMode","reduceAggregate","initialAccValue","functionName","reducingFunction","mapFunction","coercionFunction","acc","type","CELL_RANGE","COLUMN_RANGE","ROW_RANGE","evaluateRange","coercedRangeValues","Array","from","valuesFromTopLeftCorner","map","filter","CELL_REFERENCE","coerceScalarToNumberOrError","range","fromAst","formulaAddress","err","REF","RangeManySheets","rangeVertex","dependencyGraph","getRange","start","end","Error","getFunctionValue","rangeValues","getRangeValues","arg1","arg2","setFunctionValue","rangeResult","smallerRangeVertex","restRange","rangeMapping","findSmallerRange","actualRange","existsEdge","cachedValue","push","cellFromRange","addresses","getScalarValue","implementedFunctions","method","parameters","ANY","repeatLastArgs","aliases","VAR","VARP","STDEV","STDEVP","VARS","STDEVS"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/interpreter/plugin/NumericAggregationPlugin.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from \"../../AbsoluteCellRange.mjs\";\nimport { CellError, ErrorType } from \"../../Cell.mjs\";\nimport { ErrorMessage } from \"../../error-message.mjs\";\nimport { SheetsNotEqual } from \"../../errors.mjs\";\nimport { AstNodeType } from \"../../parser/index.mjs\";\nimport { coerceBooleanToNumber } from \"../ArithmeticHelper.mjs\";\nimport { EmptyValue, getRawValue, isExtendedNumber } from \"../InterpreterValue.mjs\";\nimport { SimpleRangeValue } from \"../../SimpleRangeValue.mjs\";\nimport { FunctionArgumentType, FunctionPlugin } from \"./FunctionPlugin.mjs\";\nfunction zeroForInfinite(value) {\n  if (isExtendedNumber(value) && !Number.isFinite(getRawValue(value))) {\n    return 0;\n  } else {\n    return value;\n  }\n}\nclass MomentsAggregate {\n  constructor(sumsq, sum, count) {\n    this.sumsq = sumsq;\n    this.sum = sum;\n    this.count = count;\n  }\n  static single(arg) {\n    return new MomentsAggregate(arg * arg, arg, 1);\n  }\n  compose(other) {\n    return new MomentsAggregate(this.sumsq + other.sumsq, this.sum + other.sum, this.count + other.count);\n  }\n  averageValue() {\n    if (this.count > 0) {\n      return this.sum / this.count;\n    } else {\n      return undefined;\n    }\n  }\n  varSValue() {\n    if (this.count > 1) {\n      return (this.sumsq - this.sum * this.sum / this.count) / (this.count - 1);\n    } else {\n      return undefined;\n    }\n  }\n  varPValue() {\n    if (this.count > 0) {\n      return (this.sumsq - this.sum * this.sum / this.count) / this.count;\n    } else {\n      return undefined;\n    }\n  }\n}\nMomentsAggregate.empty = new MomentsAggregate(0, 0, 0);\nexport class NumericAggregationPlugin extends FunctionPlugin {\n  constructor() {\n    super(...arguments);\n    this.addWithEpsilonRaw = (left, right) => this.arithmeticHelper.addWithEpsilonRaw(left, right);\n  }\n  /**\r\n   * Corresponds to SUM(Number1, Number2, ...).\r\n   *\r\n   * Returns a sum of given numbers.\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  sum(ast, state) {\n    return this.doSum(ast.args, state);\n  }\n  sumsq(ast, state) {\n    return this.reduce(ast.args, state, 0, 'SUMSQ', this.addWithEpsilonRaw, arg => Math.pow(getRawValue(arg), 2), strictlyNumbers);\n  }\n  /**\r\n   * Corresponds to MAX(Number1, Number2, ...).\r\n   *\r\n   * Returns a max of given numbers.\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  max(ast, state) {\n    return this.doMax(ast.args, state);\n  }\n  maxa(ast, state) {\n    const value = this.reduce(ast.args, state, Number.NEGATIVE_INFINITY, 'MAXA', (left, right) => Math.max(left, right), getRawValue, numbersBooleans);\n    return zeroForInfinite(value);\n  }\n  /**\r\n   * Corresponds to MIN(Number1, Number2, ...).\r\n   *\r\n   * Returns a min of given numbers.\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  min(ast, state) {\n    return this.doMin(ast.args, state);\n  }\n  mina(ast, state) {\n    const value = this.reduce(ast.args, state, Number.POSITIVE_INFINITY, 'MINA', (left, right) => Math.min(left, right), getRawValue, numbersBooleans);\n    return zeroForInfinite(value);\n  }\n  count(ast, state) {\n    return this.doCount(ast.args, state);\n  }\n  counta(ast, state) {\n    return this.doCounta(ast.args, state);\n  }\n  average(ast, state) {\n    return this.doAverage(ast.args, state);\n  }\n  averagea(ast, state) {\n    var _a;\n    const result = this.reduce(ast.args, state, MomentsAggregate.empty, '_AGGREGATE_A', (left, right) => left.compose(right), arg => MomentsAggregate.single(getRawValue(arg)), numbersBooleans);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      return (_a = result.averageValue()) !== null && _a !== void 0 ? _a : new CellError(ErrorType.DIV_BY_ZERO);\n    }\n  }\n  vars(ast, state) {\n    return this.doVarS(ast.args, state);\n  }\n  varp(ast, state) {\n    return this.doVarP(ast.args, state);\n  }\n  vara(ast, state) {\n    var _a;\n    const result = this.reduceAggregateA(ast.args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      return (_a = result.varSValue()) !== null && _a !== void 0 ? _a : new CellError(ErrorType.DIV_BY_ZERO);\n    }\n  }\n  varpa(ast, state) {\n    var _a;\n    const result = this.reduceAggregateA(ast.args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      return (_a = result.varPValue()) !== null && _a !== void 0 ? _a : new CellError(ErrorType.DIV_BY_ZERO);\n    }\n  }\n  stdevs(ast, state) {\n    return this.doStdevS(ast.args, state);\n  }\n  stdevp(ast, state) {\n    return this.doStdevP(ast.args, state);\n  }\n  stdeva(ast, state) {\n    const result = this.reduceAggregateA(ast.args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      const val = result.varSValue();\n      return val === undefined ? new CellError(ErrorType.DIV_BY_ZERO) : Math.sqrt(val);\n    }\n  }\n  stdevpa(ast, state) {\n    const result = this.reduceAggregateA(ast.args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      const val = result.varPValue();\n      return val === undefined ? new CellError(ErrorType.DIV_BY_ZERO) : Math.sqrt(val);\n    }\n  }\n  product(ast, state) {\n    return this.doProduct(ast.args, state);\n  }\n  subtotal(ast, state) {\n    if (ast.args.length < 2) {\n      return new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);\n    }\n    const functionType = this.coerceToType(this.evaluateAst(ast.args[0], state), {\n      argumentType: FunctionArgumentType.NUMBER\n    }, state);\n    const args = ast.args.slice(1);\n    switch (functionType) {\n      case 1:\n      case 101:\n        return this.doAverage(args, state);\n      case 2:\n      case 102:\n        return this.doCount(args, state);\n      case 3:\n      case 103:\n        return this.doCounta(args, state);\n      case 4:\n      case 104:\n        return this.doMax(args, state);\n      case 5:\n      case 105:\n        return this.doMin(args, state);\n      case 6:\n      case 106:\n        return this.doProduct(args, state);\n      case 7:\n      case 107:\n        return this.doStdevS(args, state);\n      case 8:\n      case 108:\n        return this.doStdevP(args, state);\n      case 9:\n      case 109:\n        return this.doSum(args, state);\n      case 10:\n      case 110:\n        return this.doVarS(args, state);\n      case 11:\n      case 111:\n        return this.doVarP(args, state);\n      default:\n        return new CellError(ErrorType.VALUE, ErrorMessage.BadMode);\n    }\n  }\n  reduceAggregate(args, state) {\n    return this.reduce(args, state, MomentsAggregate.empty, '_AGGREGATE', (left, right) => {\n      return left.compose(right);\n    }, arg => {\n      return MomentsAggregate.single(getRawValue(arg));\n    }, strictlyNumbers);\n  }\n  reduceAggregateA(args, state) {\n    return this.reduce(args, state, MomentsAggregate.empty, '_AGGREGATE_A', (left, right) => {\n      return left.compose(right);\n    }, arg => {\n      return MomentsAggregate.single(getRawValue(arg));\n    }, numbersBooleans);\n  }\n  doAverage(args, state) {\n    var _a;\n    const result = this.reduceAggregate(args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      return (_a = result.averageValue()) !== null && _a !== void 0 ? _a : new CellError(ErrorType.DIV_BY_ZERO);\n    }\n  }\n  doVarS(args, state) {\n    var _a;\n    const result = this.reduceAggregate(args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      return (_a = result.varSValue()) !== null && _a !== void 0 ? _a : new CellError(ErrorType.DIV_BY_ZERO);\n    }\n  }\n  doVarP(args, state) {\n    var _a;\n    const result = this.reduceAggregate(args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      return (_a = result.varPValue()) !== null && _a !== void 0 ? _a : new CellError(ErrorType.DIV_BY_ZERO);\n    }\n  }\n  doStdevS(args, state) {\n    const result = this.reduceAggregate(args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      const val = result.varSValue();\n      return val === undefined ? new CellError(ErrorType.DIV_BY_ZERO) : Math.sqrt(val);\n    }\n  }\n  doStdevP(args, state) {\n    const result = this.reduceAggregate(args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      const val = result.varPValue();\n      return val === undefined ? new CellError(ErrorType.DIV_BY_ZERO) : Math.sqrt(val);\n    }\n  }\n  doCount(args, state) {\n    return this.reduce(args, state, 0, 'COUNT', (left, right) => left + right, getRawValue, arg => isExtendedNumber(arg) ? 1 : 0);\n  }\n  doCounta(args, state) {\n    return this.reduce(args, state, 0, 'COUNTA', (left, right) => left + right, getRawValue, arg => arg === EmptyValue ? 0 : 1);\n  }\n  doMax(args, state) {\n    const value = this.reduce(args, state, Number.NEGATIVE_INFINITY, 'MAX', (left, right) => Math.max(left, right), getRawValue, strictlyNumbers);\n    return zeroForInfinite(value);\n  }\n  doMin(args, state) {\n    const value = this.reduce(args, state, Number.POSITIVE_INFINITY, 'MIN', (left, right) => Math.min(left, right), getRawValue, strictlyNumbers);\n    return zeroForInfinite(value);\n  }\n  doSum(args, state) {\n    return this.reduce(args, state, 0, 'SUM', this.addWithEpsilonRaw, getRawValue, strictlyNumbers);\n  }\n  doProduct(args, state) {\n    return this.reduce(args, state, 1, 'PRODUCT', (left, right) => left * right, getRawValue, strictlyNumbers);\n  }\n  /**\r\n   * Reduces procedure arguments with given reducing function\r\n   *\r\n   * @param args\r\n   * @param state\r\n   * @param initialAccValue - \"neutral\" value (equivalent of 0)\r\n   * @param functionName - function name to use as cache key\r\n   * @param reducingFunction - reducing function\r\n   * @param mapFunction\r\n   * @param coercionFunction\r\n   */\n  reduce(args, state, initialAccValue, functionName, reducingFunction, mapFunction, coercionFunction) {\n    if (args.length < 1) {\n      return new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);\n    }\n    return args.reduce((acc, arg) => {\n      if (acc instanceof CellError) {\n        return acc;\n      }\n      if (arg.type === AstNodeType.CELL_RANGE || arg.type === AstNodeType.COLUMN_RANGE || arg.type === AstNodeType.ROW_RANGE) {\n        const val = this.evaluateRange(arg, state, initialAccValue, functionName, reducingFunction, mapFunction, coercionFunction);\n        if (val instanceof CellError) {\n          return val;\n        }\n        return reducingFunction(val, acc);\n      }\n      let value;\n      value = this.evaluateAst(arg, state);\n      if (value instanceof SimpleRangeValue) {\n        const coercedRangeValues = Array.from(value.valuesFromTopLeftCorner()).map(coercionFunction).filter(arg => arg !== undefined);\n        return coercedRangeValues.map(arg => {\n          if (arg instanceof CellError) {\n            return arg;\n          } else {\n            return mapFunction(arg);\n          }\n        }).reduce((left, right) => {\n          if (left instanceof CellError) {\n            return left;\n          } else if (right instanceof CellError) {\n            return right;\n          } else {\n            return reducingFunction(left, right);\n          }\n        }, acc);\n      } else if (arg.type === AstNodeType.CELL_REFERENCE) {\n        value = coercionFunction(value);\n        if (value === undefined) {\n          return acc;\n        }\n      } else {\n        value = this.coerceScalarToNumberOrError(value);\n        value = coercionFunction(value);\n        if (value === undefined) {\n          return acc;\n        }\n      }\n      if (value instanceof CellError) {\n        return value;\n      }\n      return reducingFunction(acc, mapFunction(value));\n    }, initialAccValue);\n  }\n  /**\r\n   * Performs range operation on given range\r\n   *\r\n   * @param ast - cell range ast\r\n   * @param state\r\n   * @param initialAccValue - initial accumulator value for reducing function\r\n   * @param functionName - function name to use as cache key\r\n   * @param reducingFunction - reducing function\r\n   * @param mapFunction\r\n   * @param coercionFunction\r\n   */\n  evaluateRange(ast, state, initialAccValue, functionName, reducingFunction, mapFunction, coercionFunction) {\n    let range;\n    try {\n      range = AbsoluteCellRange.fromAst(ast, state.formulaAddress);\n    } catch (err) {\n      if (err instanceof SheetsNotEqual) {\n        return new CellError(ErrorType.REF, ErrorMessage.RangeManySheets);\n      } else {\n        throw err;\n      }\n    }\n    const rangeVertex = this.dependencyGraph.getRange(range.start, range.end);\n    if (rangeVertex === undefined) {\n      throw new Error('Range does not exists in graph');\n    }\n    let value = rangeVertex.getFunctionValue(functionName);\n    if (value === undefined) {\n      const rangeValues = this.getRangeValues(functionName, range, rangeVertex, mapFunction, coercionFunction);\n      value = rangeValues.reduce((arg1, arg2) => {\n        if (arg1 instanceof CellError) {\n          return arg1;\n        } else if (arg2 instanceof CellError) {\n          return arg2;\n        } else {\n          return reducingFunction(arg1, arg2);\n        }\n      }, initialAccValue);\n      rangeVertex.setFunctionValue(functionName, value);\n    }\n    return value;\n  }\n  /**\r\n   * Returns list of values for given range and function name\r\n   *\r\n   * If range is dependent on smaller range, list will contain value of smaller range for this function\r\n   * and values of cells that are not present in smaller range\r\n   *\r\n   * @param functionName - function name (e.g., SUM)\r\n   * @param range - cell range\r\n   * @param rangeVertex\r\n   * @param mapFunction\r\n   * @param coercionFunction\r\n   */\n  getRangeValues(functionName, range, rangeVertex, mapFunction, coercionFunction) {\n    const rangeResult = [];\n    const {\n      smallerRangeVertex,\n      restRange\n    } = this.dependencyGraph.rangeMapping.findSmallerRange(range);\n    let actualRange;\n    if (smallerRangeVertex !== undefined && this.dependencyGraph.existsEdge(smallerRangeVertex, rangeVertex)) {\n      const cachedValue = smallerRangeVertex.getFunctionValue(functionName);\n      if (cachedValue !== undefined) {\n        rangeResult.push(cachedValue);\n      } else {\n        for (const cellFromRange of smallerRangeVertex.range.addresses(this.dependencyGraph)) {\n          const val = coercionFunction(this.dependencyGraph.getScalarValue(cellFromRange));\n          if (val instanceof CellError) {\n            rangeResult.push(val);\n          } else if (val !== undefined) {\n            rangeResult.push(mapFunction(val));\n          }\n        }\n      }\n      actualRange = restRange;\n    } else {\n      actualRange = range;\n    }\n    for (const cellFromRange of actualRange.addresses(this.dependencyGraph)) {\n      const val = coercionFunction(this.dependencyGraph.getScalarValue(cellFromRange));\n      if (val instanceof CellError) {\n        rangeResult.push(val);\n      } else if (val !== undefined) {\n        rangeResult.push(mapFunction(val));\n      }\n    }\n    return rangeResult;\n  }\n}\nNumericAggregationPlugin.implementedFunctions = {\n  'SUM': {\n    method: 'sum',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'SUMSQ': {\n    method: 'sumsq',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'MAX': {\n    method: 'max',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'MIN': {\n    method: 'min',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'MAXA': {\n    method: 'maxa',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'MINA': {\n    method: 'mina',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'COUNT': {\n    method: 'count',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'COUNTA': {\n    method: 'counta',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'AVERAGE': {\n    method: 'average',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'AVERAGEA': {\n    method: 'averagea',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'PRODUCT': {\n    method: 'product',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'VAR.S': {\n    method: 'vars',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'VAR.P': {\n    method: 'varp',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'VARA': {\n    method: 'vara',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'VARPA': {\n    method: 'varpa',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'STDEV.S': {\n    method: 'stdevs',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'STDEV.P': {\n    method: 'stdevp',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'STDEVA': {\n    method: 'stdeva',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'STDEVPA': {\n    method: 'stdevpa',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'SUBTOTAL': {\n    method: 'subtotal',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  }\n};\nNumericAggregationPlugin.aliases = {\n  VAR: 'VAR.S',\n  VARP: 'VAR.P',\n  STDEV: 'STDEV.S',\n  STDEVP: 'STDEV.P',\n  VARS: 'VAR.S',\n  STDEVS: 'STDEV.S'\n};\nfunction strictlyNumbers(arg) {\n  if (isExtendedNumber(arg) || arg instanceof CellError) {\n    return arg;\n  } else {\n    return undefined;\n  }\n}\nfunction numbersBooleans(arg) {\n  if (typeof arg === 'boolean') {\n    return coerceBooleanToNumber(arg);\n  } else if (isExtendedNumber(arg) || arg instanceof CellError) {\n    return arg;\n  } else if (typeof arg === 'string') {\n    return 0;\n  } else {\n    return undefined;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}