{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { CellError, ErrorType, simpleCellAddress } from \"../Cell.mjs\";\nimport { ErrorMessage } from \"../error-message.mjs\";\nimport { split } from \"../generatorUtils.mjs\";\nimport { getRawValue } from \"./InterpreterValue.mjs\";\nconst findSmallerRangeForMany = (dependencyGraph, conditionRanges, valuesRange) => {\n  if (valuesRange.end.row > valuesRange.start.row) {\n    const valuesRangeEndRowLess = simpleCellAddress(valuesRange.end.sheet, valuesRange.end.col, valuesRange.end.row - 1);\n    const rowLessVertex = dependencyGraph.getRange(valuesRange.start, valuesRangeEndRowLess);\n    if (rowLessVertex !== undefined) {\n      return {\n        smallerRangeVertex: rowLessVertex,\n        restValuesRange: valuesRange.withStart(simpleCellAddress(valuesRange.start.sheet, valuesRange.start.col, valuesRange.end.row)),\n        restConditionRanges: conditionRanges.map(conditionRange => conditionRange.withStart(simpleCellAddress(conditionRange.start.sheet, conditionRange.start.col, conditionRange.end.row)))\n      };\n    }\n  }\n  return {\n    restValuesRange: valuesRange,\n    restConditionRanges: conditionRanges\n  };\n};\nexport class CriterionFunctionCompute {\n  constructor(interpreter, cacheKey, reduceInitialValue, composeFunction, mapFunction) {\n    this.interpreter = interpreter;\n    this.cacheKey = cacheKey;\n    this.reduceInitialValue = reduceInitialValue;\n    this.composeFunction = composeFunction;\n    this.mapFunction = mapFunction;\n    this.dependencyGraph = this.interpreter.dependencyGraph;\n  }\n  compute(simpleValuesRange, conditions) {\n    for (const condition of conditions) {\n      if (!condition.conditionRange.sameDimensionsAs(simpleValuesRange)) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.EqualLength);\n      }\n    }\n    const valuesRangeVertex = this.tryToGetRangeVertexForRangeValue(simpleValuesRange);\n    const conditionsVertices = conditions.map(c => this.tryToGetRangeVertexForRangeValue(c.conditionRange));\n    if (valuesRangeVertex && conditionsVertices.every(e => e !== undefined)) {\n      const fullCriterionString = conditions.map(c => c.criterionPackage.raw).join(',');\n      const cachedResult = this.findAlreadyComputedValueInCache(valuesRangeVertex, this.cacheKey(conditions), fullCriterionString);\n      if (cachedResult !== undefined) {\n        this.interpreter.stats.incrementCriterionFunctionFullCacheUsed();\n        return cachedResult;\n      }\n      const cache = this.buildNewCriterionCache(this.cacheKey(conditions), conditions.map(c => c.conditionRange.range), simpleValuesRange.range);\n      if (!cache.has(fullCriterionString)) {\n        cache.set(fullCriterionString, [this.evaluateRangeValue(simpleValuesRange, conditions), conditions.map(condition => condition.criterionPackage.lambda)]);\n      }\n      valuesRangeVertex.setCriterionFunctionValues(this.cacheKey(conditions), cache);\n      conditionsVertices.forEach(range => {\n        if (range !== undefined) {\n          range.addDependentCacheRange(valuesRangeVertex);\n        }\n      });\n      return cache.get(fullCriterionString)[0];\n    } else {\n      return this.evaluateRangeValue(simpleValuesRange, conditions);\n    }\n  }\n  tryToGetRangeVertexForRangeValue(rangeValue) {\n    const maybeRange = rangeValue.range;\n    if (maybeRange === undefined) {\n      return undefined;\n    } else {\n      return this.dependencyGraph.getRange(maybeRange.start, maybeRange.end);\n    }\n  }\n  reduceFunction(iterable) {\n    let acc = this.reduceInitialValue;\n    for (const val of iterable) {\n      acc = this.composeFunction(acc, val);\n    }\n    return acc;\n  }\n  findAlreadyComputedValueInCache(rangeVertex, cacheKey, criterionString) {\n    return rangeVertex.getCriterionFunctionValue(cacheKey, criterionString);\n  }\n  evaluateRangeValue(simpleValuesRange, conditions) {\n    const criterionLambdas = conditions.map(condition => condition.criterionPackage.lambda);\n    const values = Array.from(simpleValuesRange.valuesFromTopLeftCorner()).map(this.mapFunction)[Symbol.iterator]();\n    const conditionsIterators = conditions.map(condition => condition.conditionRange.iterateValuesFromTopLeftCorner());\n    const filteredValues = ifFilter(criterionLambdas, conditionsIterators, values);\n    return this.reduceFunction(filteredValues);\n  }\n  buildNewCriterionCache(cacheKey, simpleConditionRanges, simpleValuesRange) {\n    const currentRangeVertex = this.dependencyGraph.getRange(simpleValuesRange.start, simpleValuesRange.end);\n    const {\n      smallerRangeVertex,\n      restConditionRanges,\n      restValuesRange\n    } = findSmallerRangeForMany(this.dependencyGraph, simpleConditionRanges, simpleValuesRange);\n    let smallerCache;\n    if (smallerRangeVertex !== undefined && this.dependencyGraph.existsEdge(smallerRangeVertex, currentRangeVertex)) {\n      smallerCache = smallerRangeVertex.getCriterionFunctionValues(cacheKey);\n    } else {\n      smallerCache = new Map();\n    }\n    const newCache = new Map();\n    smallerCache.forEach(([value, criterionLambdas], key) => {\n      const filteredValues = ifFilter(criterionLambdas, restConditionRanges.map(rcr => getRangeValues(this.dependencyGraph, rcr)), Array.from(getRangeValues(this.dependencyGraph, restValuesRange)).map(this.mapFunction)[Symbol.iterator]());\n      const newCacheValue = this.composeFunction(value, this.reduceFunction(filteredValues));\n      this.interpreter.stats.incrementCriterionFunctionPartialCacheUsed();\n      newCache.set(key, [newCacheValue, criterionLambdas]);\n    });\n    return newCache;\n  }\n}\nexport class Condition {\n  constructor(conditionRange, criterionPackage) {\n    this.conditionRange = conditionRange;\n    this.criterionPackage = criterionPackage;\n  }\n}\nfunction* getRangeValues(dependencyGraph, cellRange) {\n  for (const cellFromRange of cellRange.addresses(dependencyGraph)) {\n    yield getRawValue(dependencyGraph.getScalarValue(cellFromRange));\n  }\n}\nfunction* ifFilter(criterionLambdas, conditionalIterables, computableIterable) {\n  for (const computable of computableIterable) {\n    const conditionalSplits = conditionalIterables.map(conditionalIterable => split(conditionalIterable));\n    if (!conditionalSplits.every(cs => Object.prototype.hasOwnProperty.call(cs, 'value'))) {\n      return;\n    }\n    const conditionalFirsts = conditionalSplits.map(cs => getRawValue(cs.value));\n    if (zip(conditionalFirsts, criterionLambdas).every(([conditionalFirst, criterionLambda]) => criterionLambda(conditionalFirst))) {\n      yield computable;\n    }\n    conditionalIterables = conditionalSplits.map(cs => cs.rest);\n  }\n}\nfunction zip(arr1, arr2) {\n  const result = [];\n  for (let i = 0; i < Math.min(arr1.length, arr2.length); i++) {\n    result.push([arr1[i], arr2[i]]);\n  }\n  return result;\n}","map":{"version":3,"names":["CellError","ErrorType","simpleCellAddress","ErrorMessage","split","getRawValue","findSmallerRangeForMany","dependencyGraph","conditionRanges","valuesRange","end","row","start","valuesRangeEndRowLess","sheet","col","rowLessVertex","getRange","undefined","smallerRangeVertex","restValuesRange","withStart","restConditionRanges","map","conditionRange","CriterionFunctionCompute","constructor","interpreter","cacheKey","reduceInitialValue","composeFunction","mapFunction","compute","simpleValuesRange","conditions","condition","sameDimensionsAs","VALUE","EqualLength","valuesRangeVertex","tryToGetRangeVertexForRangeValue","conditionsVertices","c","every","e","fullCriterionString","criterionPackage","raw","join","cachedResult","findAlreadyComputedValueInCache","stats","incrementCriterionFunctionFullCacheUsed","cache","buildNewCriterionCache","range","has","set","evaluateRangeValue","lambda","setCriterionFunctionValues","forEach","addDependentCacheRange","get","rangeValue","maybeRange","reduceFunction","iterable","acc","val","rangeVertex","criterionString","getCriterionFunctionValue","criterionLambdas","values","Array","from","valuesFromTopLeftCorner","Symbol","iterator","conditionsIterators","iterateValuesFromTopLeftCorner","filteredValues","ifFilter","simpleConditionRanges","currentRangeVertex","smallerCache","existsEdge","getCriterionFunctionValues","Map","newCache","value","key","rcr","getRangeValues","newCacheValue","incrementCriterionFunctionPartialCacheUsed","Condition","cellRange","cellFromRange","addresses","getScalarValue","conditionalIterables","computableIterable","computable","conditionalSplits","conditionalIterable","cs","Object","prototype","hasOwnProperty","call","conditionalFirsts","zip","conditionalFirst","criterionLambda","rest","arr1","arr2","result","i","Math","min","length","push"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/interpreter/CriterionFunctionCompute.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { CellError, ErrorType, simpleCellAddress } from \"../Cell.mjs\";\nimport { ErrorMessage } from \"../error-message.mjs\";\nimport { split } from \"../generatorUtils.mjs\";\nimport { getRawValue } from \"./InterpreterValue.mjs\";\nconst findSmallerRangeForMany = (dependencyGraph, conditionRanges, valuesRange) => {\n  if (valuesRange.end.row > valuesRange.start.row) {\n    const valuesRangeEndRowLess = simpleCellAddress(valuesRange.end.sheet, valuesRange.end.col, valuesRange.end.row - 1);\n    const rowLessVertex = dependencyGraph.getRange(valuesRange.start, valuesRangeEndRowLess);\n    if (rowLessVertex !== undefined) {\n      return {\n        smallerRangeVertex: rowLessVertex,\n        restValuesRange: valuesRange.withStart(simpleCellAddress(valuesRange.start.sheet, valuesRange.start.col, valuesRange.end.row)),\n        restConditionRanges: conditionRanges.map(conditionRange => conditionRange.withStart(simpleCellAddress(conditionRange.start.sheet, conditionRange.start.col, conditionRange.end.row)))\n      };\n    }\n  }\n  return {\n    restValuesRange: valuesRange,\n    restConditionRanges: conditionRanges\n  };\n};\nexport class CriterionFunctionCompute {\n  constructor(interpreter, cacheKey, reduceInitialValue, composeFunction, mapFunction) {\n    this.interpreter = interpreter;\n    this.cacheKey = cacheKey;\n    this.reduceInitialValue = reduceInitialValue;\n    this.composeFunction = composeFunction;\n    this.mapFunction = mapFunction;\n    this.dependencyGraph = this.interpreter.dependencyGraph;\n  }\n  compute(simpleValuesRange, conditions) {\n    for (const condition of conditions) {\n      if (!condition.conditionRange.sameDimensionsAs(simpleValuesRange)) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.EqualLength);\n      }\n    }\n    const valuesRangeVertex = this.tryToGetRangeVertexForRangeValue(simpleValuesRange);\n    const conditionsVertices = conditions.map(c => this.tryToGetRangeVertexForRangeValue(c.conditionRange));\n    if (valuesRangeVertex && conditionsVertices.every(e => e !== undefined)) {\n      const fullCriterionString = conditions.map(c => c.criterionPackage.raw).join(',');\n      const cachedResult = this.findAlreadyComputedValueInCache(valuesRangeVertex, this.cacheKey(conditions), fullCriterionString);\n      if (cachedResult !== undefined) {\n        this.interpreter.stats.incrementCriterionFunctionFullCacheUsed();\n        return cachedResult;\n      }\n      const cache = this.buildNewCriterionCache(this.cacheKey(conditions), conditions.map(c => c.conditionRange.range), simpleValuesRange.range);\n      if (!cache.has(fullCriterionString)) {\n        cache.set(fullCriterionString, [this.evaluateRangeValue(simpleValuesRange, conditions), conditions.map(condition => condition.criterionPackage.lambda)]);\n      }\n      valuesRangeVertex.setCriterionFunctionValues(this.cacheKey(conditions), cache);\n      conditionsVertices.forEach(range => {\n        if (range !== undefined) {\n          range.addDependentCacheRange(valuesRangeVertex);\n        }\n      });\n      return cache.get(fullCriterionString)[0];\n    } else {\n      return this.evaluateRangeValue(simpleValuesRange, conditions);\n    }\n  }\n  tryToGetRangeVertexForRangeValue(rangeValue) {\n    const maybeRange = rangeValue.range;\n    if (maybeRange === undefined) {\n      return undefined;\n    } else {\n      return this.dependencyGraph.getRange(maybeRange.start, maybeRange.end);\n    }\n  }\n  reduceFunction(iterable) {\n    let acc = this.reduceInitialValue;\n    for (const val of iterable) {\n      acc = this.composeFunction(acc, val);\n    }\n    return acc;\n  }\n  findAlreadyComputedValueInCache(rangeVertex, cacheKey, criterionString) {\n    return rangeVertex.getCriterionFunctionValue(cacheKey, criterionString);\n  }\n  evaluateRangeValue(simpleValuesRange, conditions) {\n    const criterionLambdas = conditions.map(condition => condition.criterionPackage.lambda);\n    const values = Array.from(simpleValuesRange.valuesFromTopLeftCorner()).map(this.mapFunction)[Symbol.iterator]();\n    const conditionsIterators = conditions.map(condition => condition.conditionRange.iterateValuesFromTopLeftCorner());\n    const filteredValues = ifFilter(criterionLambdas, conditionsIterators, values);\n    return this.reduceFunction(filteredValues);\n  }\n  buildNewCriterionCache(cacheKey, simpleConditionRanges, simpleValuesRange) {\n    const currentRangeVertex = this.dependencyGraph.getRange(simpleValuesRange.start, simpleValuesRange.end);\n    const {\n      smallerRangeVertex,\n      restConditionRanges,\n      restValuesRange\n    } = findSmallerRangeForMany(this.dependencyGraph, simpleConditionRanges, simpleValuesRange);\n    let smallerCache;\n    if (smallerRangeVertex !== undefined && this.dependencyGraph.existsEdge(smallerRangeVertex, currentRangeVertex)) {\n      smallerCache = smallerRangeVertex.getCriterionFunctionValues(cacheKey);\n    } else {\n      smallerCache = new Map();\n    }\n    const newCache = new Map();\n    smallerCache.forEach(([value, criterionLambdas], key) => {\n      const filteredValues = ifFilter(criterionLambdas, restConditionRanges.map(rcr => getRangeValues(this.dependencyGraph, rcr)), Array.from(getRangeValues(this.dependencyGraph, restValuesRange)).map(this.mapFunction)[Symbol.iterator]());\n      const newCacheValue = this.composeFunction(value, this.reduceFunction(filteredValues));\n      this.interpreter.stats.incrementCriterionFunctionPartialCacheUsed();\n      newCache.set(key, [newCacheValue, criterionLambdas]);\n    });\n    return newCache;\n  }\n}\nexport class Condition {\n  constructor(conditionRange, criterionPackage) {\n    this.conditionRange = conditionRange;\n    this.criterionPackage = criterionPackage;\n  }\n}\nfunction* getRangeValues(dependencyGraph, cellRange) {\n  for (const cellFromRange of cellRange.addresses(dependencyGraph)) {\n    yield getRawValue(dependencyGraph.getScalarValue(cellFromRange));\n  }\n}\nfunction* ifFilter(criterionLambdas, conditionalIterables, computableIterable) {\n  for (const computable of computableIterable) {\n    const conditionalSplits = conditionalIterables.map(conditionalIterable => split(conditionalIterable));\n    if (!conditionalSplits.every(cs => Object.prototype.hasOwnProperty.call(cs, 'value'))) {\n      return;\n    }\n    const conditionalFirsts = conditionalSplits.map(cs => getRawValue(cs.value));\n    if (zip(conditionalFirsts, criterionLambdas).every(([conditionalFirst, criterionLambda]) => criterionLambda(conditionalFirst))) {\n      yield computable;\n    }\n    conditionalIterables = conditionalSplits.map(cs => cs.rest);\n  }\n}\nfunction zip(arr1, arr2) {\n  const result = [];\n  for (let i = 0; i < Math.min(arr1.length, arr2.length); i++) {\n    result.push([arr1[i], arr2[i]]);\n  }\n  return result;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}