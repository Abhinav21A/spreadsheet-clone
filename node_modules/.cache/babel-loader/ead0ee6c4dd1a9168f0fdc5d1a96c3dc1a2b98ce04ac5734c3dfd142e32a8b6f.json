{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { simpleCellAddress } from \"../../Cell.mjs\";\n/**\r\n * Mapping from cell addresses to vertices\r\n *\r\n * Uses Map to store addresses, having minimal memory usage for sparse sheets but not necessarily constant set/lookup.\r\n */\nexport class SparseStrategy {\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n    /**\r\n     * Map of Maps in which actual data is stored.\r\n     *\r\n     * Key of map in first level is column number.\r\n     * Key of map in second level is row number.\r\n     */\n    this.mapping = new Map();\n  }\n  /** @inheritDoc */\n  getCell(address) {\n    var _a;\n    return (_a = this.mapping.get(address.col)) === null || _a === void 0 ? void 0 : _a.get(address.row);\n  }\n  /** @inheritDoc */\n  setCell(address, newVertex) {\n    this.width = Math.max(this.width, address.col + 1);\n    this.height = Math.max(this.height, address.row + 1);\n    let colMapping = this.mapping.get(address.col);\n    if (!colMapping) {\n      colMapping = new Map();\n      this.mapping.set(address.col, colMapping);\n    }\n    colMapping.set(address.row, newVertex);\n  }\n  /** @inheritDoc */\n  has(address) {\n    var _a;\n    return !!((_a = this.mapping.get(address.col)) === null || _a === void 0 ? void 0 : _a.get(address.row));\n  }\n  /** @inheritDoc */\n  getHeight() {\n    return this.height;\n  }\n  /** @inheritDoc */\n  getWidth() {\n    return this.width;\n  }\n  removeCell(address) {\n    var _a;\n    (_a = this.mapping.get(address.col)) === null || _a === void 0 ? void 0 : _a.delete(address.row);\n  }\n  addRows(row, numberOfRows) {\n    this.mapping.forEach(rowMapping => {\n      const tmpMapping = new Map();\n      rowMapping.forEach((vertex, rowNumber) => {\n        if (rowNumber >= row) {\n          tmpMapping.set(rowNumber + numberOfRows, vertex);\n          rowMapping.delete(rowNumber);\n        }\n      });\n      tmpMapping.forEach((vertex, rowNumber) => {\n        rowMapping.set(rowNumber, vertex);\n      });\n    });\n    this.height += numberOfRows;\n  }\n  addColumns(column, numberOfColumns) {\n    const tmpMapping = new Map();\n    this.mapping.forEach((rowMapping, colNumber) => {\n      if (colNumber >= column) {\n        tmpMapping.set(colNumber + numberOfColumns, rowMapping);\n        this.mapping.delete(colNumber);\n      }\n    });\n    tmpMapping.forEach((rowMapping, colNumber) => {\n      this.mapping.set(colNumber, rowMapping);\n    });\n    this.width += numberOfColumns;\n  }\n  removeRows(removedRows) {\n    this.mapping.forEach(rowMapping => {\n      const tmpMapping = new Map();\n      rowMapping.forEach((vertex, rowNumber) => {\n        if (rowNumber >= removedRows.rowStart) {\n          rowMapping.delete(rowNumber);\n          if (rowNumber > removedRows.rowEnd) {\n            tmpMapping.set(rowNumber - removedRows.numberOfRows, vertex);\n          }\n        }\n      });\n      tmpMapping.forEach((vertex, rowNumber) => {\n        rowMapping.set(rowNumber, vertex);\n      });\n    });\n    const rightmostRowRemoved = Math.min(this.height - 1, removedRows.rowEnd);\n    const numberOfRowsRemoved = Math.max(0, rightmostRowRemoved - removedRows.rowStart + 1);\n    this.height = Math.max(0, this.height - numberOfRowsRemoved);\n  }\n  removeColumns(removedColumns) {\n    const tmpMapping = new Map();\n    this.mapping.forEach((rowMapping, colNumber) => {\n      if (colNumber >= removedColumns.columnStart) {\n        this.mapping.delete(colNumber);\n        if (colNumber > removedColumns.columnEnd) {\n          tmpMapping.set(colNumber - removedColumns.numberOfColumns, rowMapping);\n        }\n      }\n    });\n    tmpMapping.forEach((rowMapping, colNumber) => {\n      this.mapping.set(colNumber, rowMapping);\n    });\n    const rightmostColumnRemoved = Math.min(this.width - 1, removedColumns.columnEnd);\n    const numberOfColumnsRemoved = Math.max(0, rightmostColumnRemoved - removedColumns.columnStart + 1);\n    this.width = Math.max(0, this.width - numberOfColumnsRemoved);\n  }\n  *getEntries(sheet) {\n    for (const [colNumber, col] of this.mapping) {\n      for (const [rowNumber, value] of col) {\n        yield [simpleCellAddress(sheet, colNumber, rowNumber), value];\n      }\n    }\n  }\n  *verticesFromColumn(column) {\n    const colMapping = this.mapping.get(column);\n    if (colMapping === undefined) {\n      return;\n    }\n    for (const [_, vertex] of colMapping) {\n      yield vertex;\n    }\n  }\n  *verticesFromRow(row) {\n    for (const colMapping of this.mapping.values()) {\n      const rowVertex = colMapping.get(row);\n      if (rowVertex !== undefined) {\n        yield rowVertex;\n      }\n    }\n  }\n  *verticesFromColumnsSpan(columnsSpan) {\n    for (const column of columnsSpan.columns()) {\n      const colMapping = this.mapping.get(column);\n      if (colMapping === undefined) {\n        continue;\n      }\n      for (const [_, vertex] of colMapping) {\n        yield vertex;\n      }\n    }\n  }\n  *verticesFromRowsSpan(rowsSpan) {\n    for (const colMapping of this.mapping.values()) {\n      for (const row of rowsSpan.rows()) {\n        const rowVertex = colMapping.get(row);\n        if (rowVertex !== undefined) {\n          yield rowVertex;\n        }\n      }\n    }\n  }\n  *entriesFromRowsSpan(rowsSpan) {\n    for (const [col, colMapping] of this.mapping.entries()) {\n      for (const row of rowsSpan.rows()) {\n        const rowVertex = colMapping.get(row);\n        if (rowVertex !== undefined) {\n          yield [simpleCellAddress(rowsSpan.sheet, col, row), rowVertex];\n        }\n      }\n    }\n  }\n  *entriesFromColumnsSpan(columnsSpan) {\n    for (const col of columnsSpan.columns()) {\n      const colMapping = this.mapping.get(col);\n      if (colMapping !== undefined) {\n        for (const [row, vertex] of colMapping.entries()) {\n          yield [simpleCellAddress(columnsSpan.sheet, col, row), vertex];\n        }\n      }\n    }\n  }\n  *vertices() {\n    for (const [_, col] of this.mapping) {\n      for (const [_, value] of col) {\n        if (value !== undefined) {\n          yield value;\n        }\n      }\n    }\n  }\n}","map":{"version":3,"names":["simpleCellAddress","SparseStrategy","constructor","width","height","mapping","Map","getCell","address","_a","get","col","row","setCell","newVertex","Math","max","colMapping","set","has","getHeight","getWidth","removeCell","delete","addRows","numberOfRows","forEach","rowMapping","tmpMapping","vertex","rowNumber","addColumns","column","numberOfColumns","colNumber","removeRows","removedRows","rowStart","rowEnd","rightmostRowRemoved","min","numberOfRowsRemoved","removeColumns","removedColumns","columnStart","columnEnd","rightmostColumnRemoved","numberOfColumnsRemoved","getEntries","sheet","value","verticesFromColumn","undefined","_","verticesFromRow","values","rowVertex","verticesFromColumnsSpan","columnsSpan","columns","verticesFromRowsSpan","rowsSpan","rows","entriesFromRowsSpan","entries","entriesFromColumnsSpan","vertices"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/DependencyGraph/AddressMapping/SparseStrategy.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { simpleCellAddress } from \"../../Cell.mjs\";\n/**\r\n * Mapping from cell addresses to vertices\r\n *\r\n * Uses Map to store addresses, having minimal memory usage for sparse sheets but not necessarily constant set/lookup.\r\n */\nexport class SparseStrategy {\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n    /**\r\n     * Map of Maps in which actual data is stored.\r\n     *\r\n     * Key of map in first level is column number.\r\n     * Key of map in second level is row number.\r\n     */\n    this.mapping = new Map();\n  }\n  /** @inheritDoc */\n  getCell(address) {\n    var _a;\n    return (_a = this.mapping.get(address.col)) === null || _a === void 0 ? void 0 : _a.get(address.row);\n  }\n  /** @inheritDoc */\n  setCell(address, newVertex) {\n    this.width = Math.max(this.width, address.col + 1);\n    this.height = Math.max(this.height, address.row + 1);\n    let colMapping = this.mapping.get(address.col);\n    if (!colMapping) {\n      colMapping = new Map();\n      this.mapping.set(address.col, colMapping);\n    }\n    colMapping.set(address.row, newVertex);\n  }\n  /** @inheritDoc */\n  has(address) {\n    var _a;\n    return !!((_a = this.mapping.get(address.col)) === null || _a === void 0 ? void 0 : _a.get(address.row));\n  }\n  /** @inheritDoc */\n  getHeight() {\n    return this.height;\n  }\n  /** @inheritDoc */\n  getWidth() {\n    return this.width;\n  }\n  removeCell(address) {\n    var _a;\n    (_a = this.mapping.get(address.col)) === null || _a === void 0 ? void 0 : _a.delete(address.row);\n  }\n  addRows(row, numberOfRows) {\n    this.mapping.forEach(rowMapping => {\n      const tmpMapping = new Map();\n      rowMapping.forEach((vertex, rowNumber) => {\n        if (rowNumber >= row) {\n          tmpMapping.set(rowNumber + numberOfRows, vertex);\n          rowMapping.delete(rowNumber);\n        }\n      });\n      tmpMapping.forEach((vertex, rowNumber) => {\n        rowMapping.set(rowNumber, vertex);\n      });\n    });\n    this.height += numberOfRows;\n  }\n  addColumns(column, numberOfColumns) {\n    const tmpMapping = new Map();\n    this.mapping.forEach((rowMapping, colNumber) => {\n      if (colNumber >= column) {\n        tmpMapping.set(colNumber + numberOfColumns, rowMapping);\n        this.mapping.delete(colNumber);\n      }\n    });\n    tmpMapping.forEach((rowMapping, colNumber) => {\n      this.mapping.set(colNumber, rowMapping);\n    });\n    this.width += numberOfColumns;\n  }\n  removeRows(removedRows) {\n    this.mapping.forEach(rowMapping => {\n      const tmpMapping = new Map();\n      rowMapping.forEach((vertex, rowNumber) => {\n        if (rowNumber >= removedRows.rowStart) {\n          rowMapping.delete(rowNumber);\n          if (rowNumber > removedRows.rowEnd) {\n            tmpMapping.set(rowNumber - removedRows.numberOfRows, vertex);\n          }\n        }\n      });\n      tmpMapping.forEach((vertex, rowNumber) => {\n        rowMapping.set(rowNumber, vertex);\n      });\n    });\n    const rightmostRowRemoved = Math.min(this.height - 1, removedRows.rowEnd);\n    const numberOfRowsRemoved = Math.max(0, rightmostRowRemoved - removedRows.rowStart + 1);\n    this.height = Math.max(0, this.height - numberOfRowsRemoved);\n  }\n  removeColumns(removedColumns) {\n    const tmpMapping = new Map();\n    this.mapping.forEach((rowMapping, colNumber) => {\n      if (colNumber >= removedColumns.columnStart) {\n        this.mapping.delete(colNumber);\n        if (colNumber > removedColumns.columnEnd) {\n          tmpMapping.set(colNumber - removedColumns.numberOfColumns, rowMapping);\n        }\n      }\n    });\n    tmpMapping.forEach((rowMapping, colNumber) => {\n      this.mapping.set(colNumber, rowMapping);\n    });\n    const rightmostColumnRemoved = Math.min(this.width - 1, removedColumns.columnEnd);\n    const numberOfColumnsRemoved = Math.max(0, rightmostColumnRemoved - removedColumns.columnStart + 1);\n    this.width = Math.max(0, this.width - numberOfColumnsRemoved);\n  }\n  *getEntries(sheet) {\n    for (const [colNumber, col] of this.mapping) {\n      for (const [rowNumber, value] of col) {\n        yield [simpleCellAddress(sheet, colNumber, rowNumber), value];\n      }\n    }\n  }\n  *verticesFromColumn(column) {\n    const colMapping = this.mapping.get(column);\n    if (colMapping === undefined) {\n      return;\n    }\n    for (const [_, vertex] of colMapping) {\n      yield vertex;\n    }\n  }\n  *verticesFromRow(row) {\n    for (const colMapping of this.mapping.values()) {\n      const rowVertex = colMapping.get(row);\n      if (rowVertex !== undefined) {\n        yield rowVertex;\n      }\n    }\n  }\n  *verticesFromColumnsSpan(columnsSpan) {\n    for (const column of columnsSpan.columns()) {\n      const colMapping = this.mapping.get(column);\n      if (colMapping === undefined) {\n        continue;\n      }\n      for (const [_, vertex] of colMapping) {\n        yield vertex;\n      }\n    }\n  }\n  *verticesFromRowsSpan(rowsSpan) {\n    for (const colMapping of this.mapping.values()) {\n      for (const row of rowsSpan.rows()) {\n        const rowVertex = colMapping.get(row);\n        if (rowVertex !== undefined) {\n          yield rowVertex;\n        }\n      }\n    }\n  }\n  *entriesFromRowsSpan(rowsSpan) {\n    for (const [col, colMapping] of this.mapping.entries()) {\n      for (const row of rowsSpan.rows()) {\n        const rowVertex = colMapping.get(row);\n        if (rowVertex !== undefined) {\n          yield [simpleCellAddress(rowsSpan.sheet, col, row), rowVertex];\n        }\n      }\n    }\n  }\n  *entriesFromColumnsSpan(columnsSpan) {\n    for (const col of columnsSpan.columns()) {\n      const colMapping = this.mapping.get(col);\n      if (colMapping !== undefined) {\n        for (const [row, vertex] of colMapping.entries()) {\n          yield [simpleCellAddress(columnsSpan.sheet, col, row), vertex];\n        }\n      }\n    }\n  }\n  *vertices() {\n    for (const [_, col] of this.mapping) {\n      for (const [_, value] of col) {\n        if (value !== undefined) {\n          yield value;\n        }\n      }\n    }\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}