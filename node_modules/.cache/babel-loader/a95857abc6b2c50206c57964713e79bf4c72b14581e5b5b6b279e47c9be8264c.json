{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\n// node status life cycle: undefined -> ON_STACK -> PROCESSED -> POPPED\nvar NodeVisitStatus;\n(function (NodeVisitStatus) {\n  NodeVisitStatus[NodeVisitStatus[\"ON_STACK\"] = 0] = \"ON_STACK\";\n  NodeVisitStatus[NodeVisitStatus[\"PROCESSED\"] = 1] = \"PROCESSED\";\n  NodeVisitStatus[NodeVisitStatus[\"POPPED\"] = 2] = \"POPPED\";\n})(NodeVisitStatus || (NodeVisitStatus = {}));\n/**\r\n * An algorithm class. Provides an iterative implementation of Tarjan's algorithm for finding strongly connected components\r\n */\nexport class TopSort {\n  constructor(nodesSparseArray = [], edgesSparseArray = []) {\n    this.nodesSparseArray = nodesSparseArray;\n    this.edgesSparseArray = edgesSparseArray;\n    this.entranceTime = [];\n    this.low = [];\n    this.parent = [];\n    this.inSCC = [];\n    this.nodeStatus = [];\n    this.order = [];\n    this.sccNonSingletons = [];\n    this.timeCounter = 0;\n  }\n  /**\r\n   * An iterative implementation of Tarjan's algorithm for finding strongly connected components.\r\n   * Returns vertices in order of topological sort, but vertices that are on cycles are kept separate.\r\n   *\r\n   * @param modifiedNodes - seed for computation. During engine init run, all of the vertices of grap. In recomputation run, changed vertices.\r\n   * @param operatingFunction - recomputes value of a node, and returns whether a change occurred\r\n   * @param onCycle - action to be performed when node is on cycle\r\n   */\n  getTopSortedWithSccSubgraphFrom(modifiedNodeIds, operatingFunction, onCycle) {\n    const modifiedNodeIdsReversed = modifiedNodeIds.reverse();\n    modifiedNodeIdsReversed.forEach(id => this.runDFS(id));\n    return this.postprocess(modifiedNodeIdsReversed, onCycle, operatingFunction);\n  }\n  /**\r\n   * Returns adjacent nodes of a given node.\r\n   */\n  getAdjacentNodeIds(id) {\n    return this.edgesSparseArray[id].filter(adjacentId => adjacentId !== undefined && this.nodesSparseArray[adjacentId]);\n  }\n  /**\r\n   * Runs DFS starting from a given node.\r\n   */\n  runDFS(v) {\n    if (this.nodeStatus[v] !== undefined) {\n      return;\n    }\n    this.nodeStatus[v] = NodeVisitStatus.ON_STACK;\n    const DFSstack = [v];\n    const SCCstack = [];\n    while (DFSstack.length > 0) {\n      const u = DFSstack[DFSstack.length - 1];\n      switch (this.nodeStatus[u]) {\n        case NodeVisitStatus.ON_STACK:\n          {\n            this.handleOnStack(u, SCCstack, DFSstack);\n            break;\n          }\n        case NodeVisitStatus.PROCESSED:\n          {\n            // leaving this DFS subtree\n            this.handleProcessed(u, SCCstack, DFSstack);\n            break;\n          }\n        case NodeVisitStatus.POPPED:\n          {\n            // it's a 'shadow' copy, we already processed this vertex and can ignore it\n            DFSstack.pop();\n            break;\n          }\n      }\n    }\n  }\n  /**\r\n   * Handles a node that is on stack.\r\n   */\n  handleOnStack(u, SCCstack, DFSstack) {\n    this.entranceTime[u] = this.timeCounter;\n    this.low[u] = this.timeCounter;\n    this.timeCounter++;\n    SCCstack.push(u);\n    this.getAdjacentNodeIds(u).forEach(t => {\n      if (this.entranceTime[t] === undefined) {\n        DFSstack.push(t);\n        this.parent[t] = u;\n        this.nodeStatus[t] = NodeVisitStatus.ON_STACK;\n      }\n    });\n    this.nodeStatus[u] = NodeVisitStatus.PROCESSED;\n  }\n  /**\r\n   * Handles a node that is already processed.\r\n   */\n  handleProcessed(u, SCCstack, DFSstack) {\n    let uLow = this.entranceTime[u];\n    this.getAdjacentNodeIds(u).forEach(t => {\n      if (this.inSCC[t]) {\n        return;\n      }\n      uLow = this.parent[t] === u ? Math.min(uLow, this.low[t]) : Math.min(uLow, this.entranceTime[t]);\n    });\n    this.low[u] = uLow;\n    if (uLow === this.entranceTime[u]) {\n      const currentSCC = [];\n      do {\n        currentSCC.push(SCCstack[SCCstack.length - 1]);\n        SCCstack.pop();\n      } while (currentSCC[currentSCC.length - 1] !== u);\n      currentSCC.forEach(t => {\n        this.inSCC[t] = true;\n      });\n      this.order.push(...currentSCC);\n      if (currentSCC.length > 1) {\n        currentSCC.forEach(t => {\n          this.sccNonSingletons[t] = true;\n        });\n      }\n    }\n    DFSstack.pop();\n    this.nodeStatus[u] = NodeVisitStatus.POPPED;\n  }\n  /**\r\n   * Postprocesses the result of Tarjan's algorithm.\r\n   */\n  postprocess(modifiedNodeIds, onCycle, operatingFunction) {\n    const shouldBeUpdatedMapping = [];\n    modifiedNodeIds.forEach(t => {\n      shouldBeUpdatedMapping[t] = true;\n    });\n    const sorted = [];\n    const cycled = [];\n    this.order.reverse();\n    this.order.forEach(t => {\n      const adjacentNodes = this.getAdjacentNodeIds(t);\n      // The following line is a potential performance bottleneck.\n      // Array.includes() is O(n) operation, which makes the whole algorithm O(n^2).\n      // Idea for improvement: use Set<T>[] instead of number[][] for edgesSparseArray.\n      if (this.sccNonSingletons[t] || adjacentNodes.includes(t)) {\n        cycled.push(this.nodesSparseArray[t]);\n        onCycle(this.nodesSparseArray[t]);\n        adjacentNodes.forEach(s => shouldBeUpdatedMapping[s] = true);\n      } else {\n        sorted.push(this.nodesSparseArray[t]);\n        if (shouldBeUpdatedMapping[t] && operatingFunction(this.nodesSparseArray[t])) {\n          adjacentNodes.forEach(s => shouldBeUpdatedMapping[s] = true);\n        }\n      }\n    });\n    return {\n      sorted,\n      cycled\n    };\n  }\n}","map":{"version":3,"names":["NodeVisitStatus","TopSort","constructor","nodesSparseArray","edgesSparseArray","entranceTime","low","parent","inSCC","nodeStatus","order","sccNonSingletons","timeCounter","getTopSortedWithSccSubgraphFrom","modifiedNodeIds","operatingFunction","onCycle","modifiedNodeIdsReversed","reverse","forEach","id","runDFS","postprocess","getAdjacentNodeIds","filter","adjacentId","undefined","v","ON_STACK","DFSstack","SCCstack","length","u","handleOnStack","PROCESSED","handleProcessed","POPPED","pop","push","t","uLow","Math","min","currentSCC","shouldBeUpdatedMapping","sorted","cycled","adjacentNodes","includes","s"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/DependencyGraph/TopSort.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\n// node status life cycle: undefined -> ON_STACK -> PROCESSED -> POPPED\nvar NodeVisitStatus;\n(function (NodeVisitStatus) {\n  NodeVisitStatus[NodeVisitStatus[\"ON_STACK\"] = 0] = \"ON_STACK\";\n  NodeVisitStatus[NodeVisitStatus[\"PROCESSED\"] = 1] = \"PROCESSED\";\n  NodeVisitStatus[NodeVisitStatus[\"POPPED\"] = 2] = \"POPPED\";\n})(NodeVisitStatus || (NodeVisitStatus = {}));\n/**\r\n * An algorithm class. Provides an iterative implementation of Tarjan's algorithm for finding strongly connected components\r\n */\nexport class TopSort {\n  constructor(nodesSparseArray = [], edgesSparseArray = []) {\n    this.nodesSparseArray = nodesSparseArray;\n    this.edgesSparseArray = edgesSparseArray;\n    this.entranceTime = [];\n    this.low = [];\n    this.parent = [];\n    this.inSCC = [];\n    this.nodeStatus = [];\n    this.order = [];\n    this.sccNonSingletons = [];\n    this.timeCounter = 0;\n  }\n  /**\r\n   * An iterative implementation of Tarjan's algorithm for finding strongly connected components.\r\n   * Returns vertices in order of topological sort, but vertices that are on cycles are kept separate.\r\n   *\r\n   * @param modifiedNodes - seed for computation. During engine init run, all of the vertices of grap. In recomputation run, changed vertices.\r\n   * @param operatingFunction - recomputes value of a node, and returns whether a change occurred\r\n   * @param onCycle - action to be performed when node is on cycle\r\n   */\n  getTopSortedWithSccSubgraphFrom(modifiedNodeIds, operatingFunction, onCycle) {\n    const modifiedNodeIdsReversed = modifiedNodeIds.reverse();\n    modifiedNodeIdsReversed.forEach(id => this.runDFS(id));\n    return this.postprocess(modifiedNodeIdsReversed, onCycle, operatingFunction);\n  }\n  /**\r\n   * Returns adjacent nodes of a given node.\r\n   */\n  getAdjacentNodeIds(id) {\n    return this.edgesSparseArray[id].filter(adjacentId => adjacentId !== undefined && this.nodesSparseArray[adjacentId]);\n  }\n  /**\r\n   * Runs DFS starting from a given node.\r\n   */\n  runDFS(v) {\n    if (this.nodeStatus[v] !== undefined) {\n      return;\n    }\n    this.nodeStatus[v] = NodeVisitStatus.ON_STACK;\n    const DFSstack = [v];\n    const SCCstack = [];\n    while (DFSstack.length > 0) {\n      const u = DFSstack[DFSstack.length - 1];\n      switch (this.nodeStatus[u]) {\n        case NodeVisitStatus.ON_STACK:\n          {\n            this.handleOnStack(u, SCCstack, DFSstack);\n            break;\n          }\n        case NodeVisitStatus.PROCESSED:\n          {\n            // leaving this DFS subtree\n            this.handleProcessed(u, SCCstack, DFSstack);\n            break;\n          }\n        case NodeVisitStatus.POPPED:\n          {\n            // it's a 'shadow' copy, we already processed this vertex and can ignore it\n            DFSstack.pop();\n            break;\n          }\n      }\n    }\n  }\n  /**\r\n   * Handles a node that is on stack.\r\n   */\n  handleOnStack(u, SCCstack, DFSstack) {\n    this.entranceTime[u] = this.timeCounter;\n    this.low[u] = this.timeCounter;\n    this.timeCounter++;\n    SCCstack.push(u);\n    this.getAdjacentNodeIds(u).forEach(t => {\n      if (this.entranceTime[t] === undefined) {\n        DFSstack.push(t);\n        this.parent[t] = u;\n        this.nodeStatus[t] = NodeVisitStatus.ON_STACK;\n      }\n    });\n    this.nodeStatus[u] = NodeVisitStatus.PROCESSED;\n  }\n  /**\r\n   * Handles a node that is already processed.\r\n   */\n  handleProcessed(u, SCCstack, DFSstack) {\n    let uLow = this.entranceTime[u];\n    this.getAdjacentNodeIds(u).forEach(t => {\n      if (this.inSCC[t]) {\n        return;\n      }\n      uLow = this.parent[t] === u ? Math.min(uLow, this.low[t]) : Math.min(uLow, this.entranceTime[t]);\n    });\n    this.low[u] = uLow;\n    if (uLow === this.entranceTime[u]) {\n      const currentSCC = [];\n      do {\n        currentSCC.push(SCCstack[SCCstack.length - 1]);\n        SCCstack.pop();\n      } while (currentSCC[currentSCC.length - 1] !== u);\n      currentSCC.forEach(t => {\n        this.inSCC[t] = true;\n      });\n      this.order.push(...currentSCC);\n      if (currentSCC.length > 1) {\n        currentSCC.forEach(t => {\n          this.sccNonSingletons[t] = true;\n        });\n      }\n    }\n    DFSstack.pop();\n    this.nodeStatus[u] = NodeVisitStatus.POPPED;\n  }\n  /**\r\n   * Postprocesses the result of Tarjan's algorithm.\r\n   */\n  postprocess(modifiedNodeIds, onCycle, operatingFunction) {\n    const shouldBeUpdatedMapping = [];\n    modifiedNodeIds.forEach(t => {\n      shouldBeUpdatedMapping[t] = true;\n    });\n    const sorted = [];\n    const cycled = [];\n    this.order.reverse();\n    this.order.forEach(t => {\n      const adjacentNodes = this.getAdjacentNodeIds(t);\n      // The following line is a potential performance bottleneck.\n      // Array.includes() is O(n) operation, which makes the whole algorithm O(n^2).\n      // Idea for improvement: use Set<T>[] instead of number[][] for edgesSparseArray.\n      if (this.sccNonSingletons[t] || adjacentNodes.includes(t)) {\n        cycled.push(this.nodesSparseArray[t]);\n        onCycle(this.nodesSparseArray[t]);\n        adjacentNodes.forEach(s => shouldBeUpdatedMapping[s] = true);\n      } else {\n        sorted.push(this.nodesSparseArray[t]);\n        if (shouldBeUpdatedMapping[t] && operatingFunction(this.nodesSparseArray[t])) {\n          adjacentNodes.forEach(s => shouldBeUpdatedMapping[s] = true);\n        }\n      }\n    });\n    return {\n      sorted,\n      cycled\n    };\n  }\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,IAAIA,eAAe;AACnB,CAAC,UAAUA,eAAe,EAAE;EAC1BA,eAAe,CAACA,eAAe,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;EAC7DA,eAAe,CAACA,eAAe,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;EAC/DA,eAAe,CAACA,eAAe,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;AAC3D,CAAC,EAAEA,eAAe,KAAKA,eAAe,GAAG,CAAC,CAAC,CAAC,CAAC;AAC7C;AACA;AACA;AACA,OAAO,MAAMC,OAAO,CAAC;EACnBC,WAAWA,CAACC,gBAAgB,GAAG,EAAE,EAAEC,gBAAgB,GAAG,EAAE,EAAE;IACxD,IAAI,CAACD,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACC,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACC,YAAY,GAAG,EAAE;IACtB,IAAI,CAACC,GAAG,GAAG,EAAE;IACb,IAAI,CAACC,MAAM,GAAG,EAAE;IAChB,IAAI,CAACC,KAAK,GAAG,EAAE;IACf,IAAI,CAACC,UAAU,GAAG,EAAE;IACpB,IAAI,CAACC,KAAK,GAAG,EAAE;IACf,IAAI,CAACC,gBAAgB,GAAG,EAAE;IAC1B,IAAI,CAACC,WAAW,GAAG,CAAC;EACtB;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,+BAA+BA,CAACC,eAAe,EAAEC,iBAAiB,EAAEC,OAAO,EAAE;IAC3E,MAAMC,uBAAuB,GAAGH,eAAe,CAACI,OAAO,CAAC,CAAC;IACzDD,uBAAuB,CAACE,OAAO,CAACC,EAAE,IAAI,IAAI,CAACC,MAAM,CAACD,EAAE,CAAC,CAAC;IACtD,OAAO,IAAI,CAACE,WAAW,CAACL,uBAAuB,EAAED,OAAO,EAAED,iBAAiB,CAAC;EAC9E;EACA;AACF;AACA;EACEQ,kBAAkBA,CAACH,EAAE,EAAE;IACrB,OAAO,IAAI,CAAChB,gBAAgB,CAACgB,EAAE,CAAC,CAACI,MAAM,CAACC,UAAU,IAAIA,UAAU,KAAKC,SAAS,IAAI,IAAI,CAACvB,gBAAgB,CAACsB,UAAU,CAAC,CAAC;EACtH;EACA;AACF;AACA;EACEJ,MAAMA,CAACM,CAAC,EAAE;IACR,IAAI,IAAI,CAAClB,UAAU,CAACkB,CAAC,CAAC,KAAKD,SAAS,EAAE;MACpC;IACF;IACA,IAAI,CAACjB,UAAU,CAACkB,CAAC,CAAC,GAAG3B,eAAe,CAAC4B,QAAQ;IAC7C,MAAMC,QAAQ,GAAG,CAACF,CAAC,CAAC;IACpB,MAAMG,QAAQ,GAAG,EAAE;IACnB,OAAOD,QAAQ,CAACE,MAAM,GAAG,CAAC,EAAE;MAC1B,MAAMC,CAAC,GAAGH,QAAQ,CAACA,QAAQ,CAACE,MAAM,GAAG,CAAC,CAAC;MACvC,QAAQ,IAAI,CAACtB,UAAU,CAACuB,CAAC,CAAC;QACxB,KAAKhC,eAAe,CAAC4B,QAAQ;UAC3B;YACE,IAAI,CAACK,aAAa,CAACD,CAAC,EAAEF,QAAQ,EAAED,QAAQ,CAAC;YACzC;UACF;QACF,KAAK7B,eAAe,CAACkC,SAAS;UAC5B;YACE;YACA,IAAI,CAACC,eAAe,CAACH,CAAC,EAAEF,QAAQ,EAAED,QAAQ,CAAC;YAC3C;UACF;QACF,KAAK7B,eAAe,CAACoC,MAAM;UACzB;YACE;YACAP,QAAQ,CAACQ,GAAG,CAAC,CAAC;YACd;UACF;MACJ;IACF;EACF;EACA;AACF;AACA;EACEJ,aAAaA,CAACD,CAAC,EAAEF,QAAQ,EAAED,QAAQ,EAAE;IACnC,IAAI,CAACxB,YAAY,CAAC2B,CAAC,CAAC,GAAG,IAAI,CAACpB,WAAW;IACvC,IAAI,CAACN,GAAG,CAAC0B,CAAC,CAAC,GAAG,IAAI,CAACpB,WAAW;IAC9B,IAAI,CAACA,WAAW,EAAE;IAClBkB,QAAQ,CAACQ,IAAI,CAACN,CAAC,CAAC;IAChB,IAAI,CAACT,kBAAkB,CAACS,CAAC,CAAC,CAACb,OAAO,CAACoB,CAAC,IAAI;MACtC,IAAI,IAAI,CAAClC,YAAY,CAACkC,CAAC,CAAC,KAAKb,SAAS,EAAE;QACtCG,QAAQ,CAACS,IAAI,CAACC,CAAC,CAAC;QAChB,IAAI,CAAChC,MAAM,CAACgC,CAAC,CAAC,GAAGP,CAAC;QAClB,IAAI,CAACvB,UAAU,CAAC8B,CAAC,CAAC,GAAGvC,eAAe,CAAC4B,QAAQ;MAC/C;IACF,CAAC,CAAC;IACF,IAAI,CAACnB,UAAU,CAACuB,CAAC,CAAC,GAAGhC,eAAe,CAACkC,SAAS;EAChD;EACA;AACF;AACA;EACEC,eAAeA,CAACH,CAAC,EAAEF,QAAQ,EAAED,QAAQ,EAAE;IACrC,IAAIW,IAAI,GAAG,IAAI,CAACnC,YAAY,CAAC2B,CAAC,CAAC;IAC/B,IAAI,CAACT,kBAAkB,CAACS,CAAC,CAAC,CAACb,OAAO,CAACoB,CAAC,IAAI;MACtC,IAAI,IAAI,CAAC/B,KAAK,CAAC+B,CAAC,CAAC,EAAE;QACjB;MACF;MACAC,IAAI,GAAG,IAAI,CAACjC,MAAM,CAACgC,CAAC,CAAC,KAAKP,CAAC,GAAGS,IAAI,CAACC,GAAG,CAACF,IAAI,EAAE,IAAI,CAAClC,GAAG,CAACiC,CAAC,CAAC,CAAC,GAAGE,IAAI,CAACC,GAAG,CAACF,IAAI,EAAE,IAAI,CAACnC,YAAY,CAACkC,CAAC,CAAC,CAAC;IAClG,CAAC,CAAC;IACF,IAAI,CAACjC,GAAG,CAAC0B,CAAC,CAAC,GAAGQ,IAAI;IAClB,IAAIA,IAAI,KAAK,IAAI,CAACnC,YAAY,CAAC2B,CAAC,CAAC,EAAE;MACjC,MAAMW,UAAU,GAAG,EAAE;MACrB,GAAG;QACDA,UAAU,CAACL,IAAI,CAACR,QAAQ,CAACA,QAAQ,CAACC,MAAM,GAAG,CAAC,CAAC,CAAC;QAC9CD,QAAQ,CAACO,GAAG,CAAC,CAAC;MAChB,CAAC,QAAQM,UAAU,CAACA,UAAU,CAACZ,MAAM,GAAG,CAAC,CAAC,KAAKC,CAAC;MAChDW,UAAU,CAACxB,OAAO,CAACoB,CAAC,IAAI;QACtB,IAAI,CAAC/B,KAAK,CAAC+B,CAAC,CAAC,GAAG,IAAI;MACtB,CAAC,CAAC;MACF,IAAI,CAAC7B,KAAK,CAAC4B,IAAI,CAAC,GAAGK,UAAU,CAAC;MAC9B,IAAIA,UAAU,CAACZ,MAAM,GAAG,CAAC,EAAE;QACzBY,UAAU,CAACxB,OAAO,CAACoB,CAAC,IAAI;UACtB,IAAI,CAAC5B,gBAAgB,CAAC4B,CAAC,CAAC,GAAG,IAAI;QACjC,CAAC,CAAC;MACJ;IACF;IACAV,QAAQ,CAACQ,GAAG,CAAC,CAAC;IACd,IAAI,CAAC5B,UAAU,CAACuB,CAAC,CAAC,GAAGhC,eAAe,CAACoC,MAAM;EAC7C;EACA;AACF;AACA;EACEd,WAAWA,CAACR,eAAe,EAAEE,OAAO,EAAED,iBAAiB,EAAE;IACvD,MAAM6B,sBAAsB,GAAG,EAAE;IACjC9B,eAAe,CAACK,OAAO,CAACoB,CAAC,IAAI;MAC3BK,sBAAsB,CAACL,CAAC,CAAC,GAAG,IAAI;IAClC,CAAC,CAAC;IACF,MAAMM,MAAM,GAAG,EAAE;IACjB,MAAMC,MAAM,GAAG,EAAE;IACjB,IAAI,CAACpC,KAAK,CAACQ,OAAO,CAAC,CAAC;IACpB,IAAI,CAACR,KAAK,CAACS,OAAO,CAACoB,CAAC,IAAI;MACtB,MAAMQ,aAAa,GAAG,IAAI,CAACxB,kBAAkB,CAACgB,CAAC,CAAC;MAChD;MACA;MACA;MACA,IAAI,IAAI,CAAC5B,gBAAgB,CAAC4B,CAAC,CAAC,IAAIQ,aAAa,CAACC,QAAQ,CAACT,CAAC,CAAC,EAAE;QACzDO,MAAM,CAACR,IAAI,CAAC,IAAI,CAACnC,gBAAgB,CAACoC,CAAC,CAAC,CAAC;QACrCvB,OAAO,CAAC,IAAI,CAACb,gBAAgB,CAACoC,CAAC,CAAC,CAAC;QACjCQ,aAAa,CAAC5B,OAAO,CAAC8B,CAAC,IAAIL,sBAAsB,CAACK,CAAC,CAAC,GAAG,IAAI,CAAC;MAC9D,CAAC,MAAM;QACLJ,MAAM,CAACP,IAAI,CAAC,IAAI,CAACnC,gBAAgB,CAACoC,CAAC,CAAC,CAAC;QACrC,IAAIK,sBAAsB,CAACL,CAAC,CAAC,IAAIxB,iBAAiB,CAAC,IAAI,CAACZ,gBAAgB,CAACoC,CAAC,CAAC,CAAC,EAAE;UAC5EQ,aAAa,CAAC5B,OAAO,CAAC8B,CAAC,IAAIL,sBAAsB,CAACK,CAAC,CAAC,GAAG,IAAI,CAAC;QAC9D;MACF;IACF,CAAC,CAAC;IACF,OAAO;MACLJ,MAAM;MACNC;IACF,CAAC;EACH;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}