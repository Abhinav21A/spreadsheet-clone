{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { simpleCellAddress } from \"./Cell.mjs\";\nimport { AstNodeType } from \"./parser/index.mjs\";\nimport { CELL_REFERENCE_PATTERN, NAMED_EXPRESSION_PATTERN, R1C1_CELL_REFERENCE_PATTERN } from \"./parser/parser-consts.mjs\";\nexport class InternalNamedExpression {\n  constructor(displayName, address, added, options) {\n    this.displayName = displayName;\n    this.address = address;\n    this.added = added;\n    this.options = options;\n  }\n  normalizeExpressionName() {\n    return this.displayName.toLowerCase();\n  }\n  copy() {\n    return new InternalNamedExpression(this.displayName, this.address, this.added, this.options);\n  }\n}\nclass WorkbookStore {\n  constructor() {\n    this.mapping = new Map();\n  }\n  has(expressionName) {\n    return this.mapping.has(this.normalizeExpressionName(expressionName));\n  }\n  isNameAvailable(expressionName) {\n    const normalizedExpressionName = this.normalizeExpressionName(expressionName);\n    const namedExpression = this.mapping.get(normalizedExpressionName);\n    return !(namedExpression && namedExpression.added);\n  }\n  add(namedExpression) {\n    this.mapping.set(namedExpression.normalizeExpressionName(), namedExpression);\n  }\n  get(expressionName) {\n    return this.mapping.get(this.normalizeExpressionName(expressionName));\n  }\n  getExisting(expressionName) {\n    const namedExpression = this.mapping.get(this.normalizeExpressionName(expressionName));\n    if (namedExpression && namedExpression.added) {\n      return namedExpression;\n    } else {\n      return undefined;\n    }\n  }\n  remove(expressionName) {\n    const normalizedExpressionName = this.normalizeExpressionName(expressionName);\n    const namedExpression = this.mapping.get(normalizedExpressionName);\n    if (namedExpression) {\n      namedExpression.added = false;\n    }\n  }\n  getAllNamedExpressions() {\n    return Array.from(this.mapping.values()).filter(ne => ne.added);\n  }\n  normalizeExpressionName(expressionName) {\n    return expressionName.toLowerCase();\n  }\n}\nclass WorksheetStore {\n  constructor() {\n    this.mapping = new Map();\n  }\n  add(namedExpression) {\n    this.mapping.set(this.normalizeExpressionName(namedExpression.displayName), namedExpression);\n  }\n  get(expressionName) {\n    return this.mapping.get(this.normalizeExpressionName(expressionName));\n  }\n  has(expressionName) {\n    return this.mapping.has(this.normalizeExpressionName(expressionName));\n  }\n  getAllNamedExpressions() {\n    return Array.from(this.mapping.values()).filter(ne => ne.added);\n  }\n  isNameAvailable(expressionName) {\n    const normalizedExpressionName = this.normalizeExpressionName(expressionName);\n    return !this.mapping.has(normalizedExpressionName);\n  }\n  remove(expressionName) {\n    const normalizedExpressionName = this.normalizeExpressionName(expressionName);\n    const namedExpression = this.mapping.get(normalizedExpressionName);\n    if (namedExpression) {\n      this.mapping.delete(normalizedExpressionName);\n    }\n  }\n  normalizeExpressionName(expressionName) {\n    return expressionName.toLowerCase();\n  }\n}\nexport class NamedExpressions {\n  constructor() {\n    this.nextNamedExpressionRow = 0;\n    this.workbookStore = new WorkbookStore();\n    this.worksheetStores = new Map();\n    this.addressCache = new Map();\n  }\n  isNameAvailable(expressionName, sheetId) {\n    var _a, _b;\n    if (sheetId === undefined) {\n      return this.workbookStore.isNameAvailable(expressionName);\n    } else {\n      return (_b = (_a = this.worksheetStore(sheetId)) === null || _a === void 0 ? void 0 : _a.isNameAvailable(expressionName)) !== null && _b !== void 0 ? _b : true;\n    }\n  }\n  namedExpressionInAddress(row) {\n    const namedExpression = this.addressCache.get(row);\n    if (namedExpression && namedExpression.added) {\n      return namedExpression;\n    } else {\n      return undefined;\n    }\n  }\n  namedExpressionForScope(expressionName, sheetId) {\n    var _a;\n    if (sheetId === undefined) {\n      return this.workbookStore.getExisting(expressionName);\n    } else {\n      return (_a = this.worksheetStore(sheetId)) === null || _a === void 0 ? void 0 : _a.get(expressionName);\n    }\n  }\n  nearestNamedExpression(expressionName, sheetId) {\n    var _a, _b;\n    return (_b = (_a = this.worksheetStore(sheetId)) === null || _a === void 0 ? void 0 : _a.get(expressionName)) !== null && _b !== void 0 ? _b : this.workbookStore.getExisting(expressionName);\n  }\n  isExpressionInScope(expressionName, sheetId) {\n    var _a, _b;\n    return (_b = (_a = this.worksheetStore(sheetId)) === null || _a === void 0 ? void 0 : _a.has(expressionName)) !== null && _b !== void 0 ? _b : false;\n  }\n  /**\r\n   * Checks the validity of a named-expression's name.\r\n   *\r\n   * The name:\r\n   * - Must start with a Unicode letter or with an underscore (`_`).\r\n   * - Can contain only Unicode letters, numbers, underscores, and periods (`.`).\r\n   * - Can't be the same as any possible reference in the A1 notation (`[A-Za-z]+[0-9]+`).\r\n   * - Can't be the same as any possible reference in the R1C1 notation (`[rR][0-9]*[cC][0-9]*`).\r\n   *\r\n   * The naming rules follow the [OpenDocument](https://docs.oasis-open.org/office/OpenDocument/v1.3/os/part4-formula/OpenDocument-v1.3-os-part4-formula.html#__RefHeading__1017964_715980110) standard.\r\n   */\n  isNameValid(expressionName) {\n    const a1CellRefRegexp = new RegExp(`^${CELL_REFERENCE_PATTERN}$`);\n    const r1c1CellRefRegexp = new RegExp(`^${R1C1_CELL_REFERENCE_PATTERN}$`);\n    const namedExpRegexp = new RegExp(`^${NAMED_EXPRESSION_PATTERN}$`);\n    if (a1CellRefRegexp.test(expressionName) || r1c1CellRefRegexp.test(expressionName)) {\n      return false;\n    }\n    return namedExpRegexp.test(expressionName);\n  }\n  addNamedExpression(expressionName, sheetId, options) {\n    const store = sheetId === undefined ? this.workbookStore : this.worksheetStoreOrCreate(sheetId);\n    let namedExpression = store.get(expressionName);\n    if (namedExpression !== undefined) {\n      namedExpression.added = true;\n      namedExpression.displayName = expressionName;\n      namedExpression.options = options;\n    } else {\n      namedExpression = new InternalNamedExpression(expressionName, this.nextAddress(), true, options);\n      store.add(namedExpression);\n    }\n    this.addressCache.set(namedExpression.address.row, namedExpression);\n    return namedExpression;\n  }\n  restoreNamedExpression(namedExpression, sheetId) {\n    const store = sheetId === undefined ? this.workbookStore : this.worksheetStoreOrCreate(sheetId);\n    namedExpression.added = true;\n    store.add(namedExpression);\n    this.addressCache.set(namedExpression.address.row, namedExpression);\n    return namedExpression;\n  }\n  namedExpressionOrPlaceholder(expressionName, sheetId) {\n    var _a;\n    return (_a = this.worksheetStoreOrCreate(sheetId).get(expressionName)) !== null && _a !== void 0 ? _a : this.workbookNamedExpressionOrPlaceholder(expressionName);\n  }\n  workbookNamedExpressionOrPlaceholder(expressionName) {\n    let namedExpression = this.workbookStore.get(expressionName);\n    if (namedExpression === undefined) {\n      namedExpression = new InternalNamedExpression(expressionName, this.nextAddress(), false);\n      this.workbookStore.add(namedExpression);\n    }\n    return namedExpression;\n  }\n  remove(expressionName, sheetId) {\n    let store;\n    if (sheetId === undefined) {\n      store = this.workbookStore;\n    } else {\n      store = this.worksheetStore(sheetId);\n    }\n    const namedExpression = store === null || store === void 0 ? void 0 : store.get(expressionName);\n    if (store === undefined || namedExpression === undefined || !namedExpression.added) {\n      throw Error('Named expression does not exist');\n    }\n    store.remove(expressionName);\n    if (store instanceof WorksheetStore && store.mapping.size === 0) {\n      this.worksheetStores.delete(sheetId);\n    }\n    this.addressCache.delete(namedExpression.address.row);\n  }\n  getAllNamedExpressionsNamesInScope(sheetId) {\n    return this.getAllNamedExpressions().filter(({\n      scope\n    }) => scope === sheetId).map(ne => ne.expression.displayName);\n  }\n  getAllNamedExpressionsNames() {\n    return this.getAllNamedExpressions().map(ne => ne.expression.displayName);\n  }\n  getAllNamedExpressions() {\n    const storedNamedExpressions = [];\n    this.workbookStore.getAllNamedExpressions().forEach(expr => {\n      storedNamedExpressions.push({\n        expression: expr,\n        scope: undefined\n      });\n    });\n    this.worksheetStores.forEach((store, sheetNum) => {\n      store.getAllNamedExpressions().forEach(expr => {\n        storedNamedExpressions.push({\n          expression: expr,\n          scope: sheetNum\n        });\n      });\n    });\n    return storedNamedExpressions;\n  }\n  getAllNamedExpressionsForScope(scope) {\n    var _a, _b;\n    if (scope === undefined) {\n      return this.workbookStore.getAllNamedExpressions();\n    } else {\n      return (_b = (_a = this.worksheetStores.get(scope)) === null || _a === void 0 ? void 0 : _a.getAllNamedExpressions()) !== null && _b !== void 0 ? _b : [];\n    }\n  }\n  worksheetStoreOrCreate(sheetId) {\n    let store = this.worksheetStores.get(sheetId);\n    if (!store) {\n      store = new WorksheetStore();\n      this.worksheetStores.set(sheetId, store);\n    }\n    return store;\n  }\n  worksheetStore(sheetId) {\n    return this.worksheetStores.get(sheetId);\n  }\n  nextAddress() {\n    return simpleCellAddress(NamedExpressions.SHEET_FOR_WORKBOOK_EXPRESSIONS, 0, this.nextNamedExpressionRow++);\n  }\n}\nNamedExpressions.SHEET_FOR_WORKBOOK_EXPRESSIONS = -1;\nexport const doesContainRelativeReferences = ast => {\n  switch (ast.type) {\n    case AstNodeType.EMPTY:\n    case AstNodeType.NUMBER:\n    case AstNodeType.STRING:\n    case AstNodeType.ERROR:\n    case AstNodeType.ERROR_WITH_RAW_INPUT:\n      return false;\n    case AstNodeType.CELL_REFERENCE:\n      return !ast.reference.isAbsolute();\n    case AstNodeType.CELL_RANGE:\n    case AstNodeType.COLUMN_RANGE:\n    case AstNodeType.ROW_RANGE:\n      return !ast.start.isAbsolute();\n    case AstNodeType.NAMED_EXPRESSION:\n      return false;\n    case AstNodeType.PERCENT_OP:\n    case AstNodeType.PLUS_UNARY_OP:\n    case AstNodeType.MINUS_UNARY_OP:\n      {\n        return doesContainRelativeReferences(ast.value);\n      }\n    case AstNodeType.CONCATENATE_OP:\n    case AstNodeType.EQUALS_OP:\n    case AstNodeType.NOT_EQUAL_OP:\n    case AstNodeType.LESS_THAN_OP:\n    case AstNodeType.GREATER_THAN_OP:\n    case AstNodeType.LESS_THAN_OR_EQUAL_OP:\n    case AstNodeType.GREATER_THAN_OR_EQUAL_OP:\n    case AstNodeType.MINUS_OP:\n    case AstNodeType.PLUS_OP:\n    case AstNodeType.TIMES_OP:\n    case AstNodeType.DIV_OP:\n    case AstNodeType.POWER_OP:\n      return doesContainRelativeReferences(ast.left) || doesContainRelativeReferences(ast.right);\n    case AstNodeType.PARENTHESIS:\n      return doesContainRelativeReferences(ast.expression);\n    case AstNodeType.FUNCTION_CALL:\n      {\n        return ast.args.some(arg => doesContainRelativeReferences(arg));\n      }\n    case AstNodeType.ARRAY:\n      {\n        return ast.args.some(row => row.some(arg => doesContainRelativeReferences(arg)));\n      }\n  }\n};","map":{"version":3,"names":["simpleCellAddress","AstNodeType","CELL_REFERENCE_PATTERN","NAMED_EXPRESSION_PATTERN","R1C1_CELL_REFERENCE_PATTERN","InternalNamedExpression","constructor","displayName","address","added","options","normalizeExpressionName","toLowerCase","copy","WorkbookStore","mapping","Map","has","expressionName","isNameAvailable","normalizedExpressionName","namedExpression","get","add","set","getExisting","undefined","remove","getAllNamedExpressions","Array","from","values","filter","ne","WorksheetStore","delete","NamedExpressions","nextNamedExpressionRow","workbookStore","worksheetStores","addressCache","sheetId","_a","_b","worksheetStore","namedExpressionInAddress","row","namedExpressionForScope","nearestNamedExpression","isExpressionInScope","isNameValid","a1CellRefRegexp","RegExp","r1c1CellRefRegexp","namedExpRegexp","test","addNamedExpression","store","worksheetStoreOrCreate","nextAddress","restoreNamedExpression","namedExpressionOrPlaceholder","workbookNamedExpressionOrPlaceholder","Error","size","getAllNamedExpressionsNamesInScope","scope","map","expression","getAllNamedExpressionsNames","storedNamedExpressions","forEach","expr","push","sheetNum","getAllNamedExpressionsForScope","SHEET_FOR_WORKBOOK_EXPRESSIONS","doesContainRelativeReferences","ast","type","EMPTY","NUMBER","STRING","ERROR","ERROR_WITH_RAW_INPUT","CELL_REFERENCE","reference","isAbsolute","CELL_RANGE","COLUMN_RANGE","ROW_RANGE","start","NAMED_EXPRESSION","PERCENT_OP","PLUS_UNARY_OP","MINUS_UNARY_OP","value","CONCATENATE_OP","EQUALS_OP","NOT_EQUAL_OP","LESS_THAN_OP","GREATER_THAN_OP","LESS_THAN_OR_EQUAL_OP","GREATER_THAN_OR_EQUAL_OP","MINUS_OP","PLUS_OP","TIMES_OP","DIV_OP","POWER_OP","left","right","PARENTHESIS","FUNCTION_CALL","args","some","arg","ARRAY"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/NamedExpressions.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { simpleCellAddress } from \"./Cell.mjs\";\nimport { AstNodeType } from \"./parser/index.mjs\";\nimport { CELL_REFERENCE_PATTERN, NAMED_EXPRESSION_PATTERN, R1C1_CELL_REFERENCE_PATTERN } from \"./parser/parser-consts.mjs\";\nexport class InternalNamedExpression {\n  constructor(displayName, address, added, options) {\n    this.displayName = displayName;\n    this.address = address;\n    this.added = added;\n    this.options = options;\n  }\n  normalizeExpressionName() {\n    return this.displayName.toLowerCase();\n  }\n  copy() {\n    return new InternalNamedExpression(this.displayName, this.address, this.added, this.options);\n  }\n}\nclass WorkbookStore {\n  constructor() {\n    this.mapping = new Map();\n  }\n  has(expressionName) {\n    return this.mapping.has(this.normalizeExpressionName(expressionName));\n  }\n  isNameAvailable(expressionName) {\n    const normalizedExpressionName = this.normalizeExpressionName(expressionName);\n    const namedExpression = this.mapping.get(normalizedExpressionName);\n    return !(namedExpression && namedExpression.added);\n  }\n  add(namedExpression) {\n    this.mapping.set(namedExpression.normalizeExpressionName(), namedExpression);\n  }\n  get(expressionName) {\n    return this.mapping.get(this.normalizeExpressionName(expressionName));\n  }\n  getExisting(expressionName) {\n    const namedExpression = this.mapping.get(this.normalizeExpressionName(expressionName));\n    if (namedExpression && namedExpression.added) {\n      return namedExpression;\n    } else {\n      return undefined;\n    }\n  }\n  remove(expressionName) {\n    const normalizedExpressionName = this.normalizeExpressionName(expressionName);\n    const namedExpression = this.mapping.get(normalizedExpressionName);\n    if (namedExpression) {\n      namedExpression.added = false;\n    }\n  }\n  getAllNamedExpressions() {\n    return Array.from(this.mapping.values()).filter(ne => ne.added);\n  }\n  normalizeExpressionName(expressionName) {\n    return expressionName.toLowerCase();\n  }\n}\nclass WorksheetStore {\n  constructor() {\n    this.mapping = new Map();\n  }\n  add(namedExpression) {\n    this.mapping.set(this.normalizeExpressionName(namedExpression.displayName), namedExpression);\n  }\n  get(expressionName) {\n    return this.mapping.get(this.normalizeExpressionName(expressionName));\n  }\n  has(expressionName) {\n    return this.mapping.has(this.normalizeExpressionName(expressionName));\n  }\n  getAllNamedExpressions() {\n    return Array.from(this.mapping.values()).filter(ne => ne.added);\n  }\n  isNameAvailable(expressionName) {\n    const normalizedExpressionName = this.normalizeExpressionName(expressionName);\n    return !this.mapping.has(normalizedExpressionName);\n  }\n  remove(expressionName) {\n    const normalizedExpressionName = this.normalizeExpressionName(expressionName);\n    const namedExpression = this.mapping.get(normalizedExpressionName);\n    if (namedExpression) {\n      this.mapping.delete(normalizedExpressionName);\n    }\n  }\n  normalizeExpressionName(expressionName) {\n    return expressionName.toLowerCase();\n  }\n}\nexport class NamedExpressions {\n  constructor() {\n    this.nextNamedExpressionRow = 0;\n    this.workbookStore = new WorkbookStore();\n    this.worksheetStores = new Map();\n    this.addressCache = new Map();\n  }\n  isNameAvailable(expressionName, sheetId) {\n    var _a, _b;\n    if (sheetId === undefined) {\n      return this.workbookStore.isNameAvailable(expressionName);\n    } else {\n      return (_b = (_a = this.worksheetStore(sheetId)) === null || _a === void 0 ? void 0 : _a.isNameAvailable(expressionName)) !== null && _b !== void 0 ? _b : true;\n    }\n  }\n  namedExpressionInAddress(row) {\n    const namedExpression = this.addressCache.get(row);\n    if (namedExpression && namedExpression.added) {\n      return namedExpression;\n    } else {\n      return undefined;\n    }\n  }\n  namedExpressionForScope(expressionName, sheetId) {\n    var _a;\n    if (sheetId === undefined) {\n      return this.workbookStore.getExisting(expressionName);\n    } else {\n      return (_a = this.worksheetStore(sheetId)) === null || _a === void 0 ? void 0 : _a.get(expressionName);\n    }\n  }\n  nearestNamedExpression(expressionName, sheetId) {\n    var _a, _b;\n    return (_b = (_a = this.worksheetStore(sheetId)) === null || _a === void 0 ? void 0 : _a.get(expressionName)) !== null && _b !== void 0 ? _b : this.workbookStore.getExisting(expressionName);\n  }\n  isExpressionInScope(expressionName, sheetId) {\n    var _a, _b;\n    return (_b = (_a = this.worksheetStore(sheetId)) === null || _a === void 0 ? void 0 : _a.has(expressionName)) !== null && _b !== void 0 ? _b : false;\n  }\n  /**\r\n   * Checks the validity of a named-expression's name.\r\n   *\r\n   * The name:\r\n   * - Must start with a Unicode letter or with an underscore (`_`).\r\n   * - Can contain only Unicode letters, numbers, underscores, and periods (`.`).\r\n   * - Can't be the same as any possible reference in the A1 notation (`[A-Za-z]+[0-9]+`).\r\n   * - Can't be the same as any possible reference in the R1C1 notation (`[rR][0-9]*[cC][0-9]*`).\r\n   *\r\n   * The naming rules follow the [OpenDocument](https://docs.oasis-open.org/office/OpenDocument/v1.3/os/part4-formula/OpenDocument-v1.3-os-part4-formula.html#__RefHeading__1017964_715980110) standard.\r\n   */\n  isNameValid(expressionName) {\n    const a1CellRefRegexp = new RegExp(`^${CELL_REFERENCE_PATTERN}$`);\n    const r1c1CellRefRegexp = new RegExp(`^${R1C1_CELL_REFERENCE_PATTERN}$`);\n    const namedExpRegexp = new RegExp(`^${NAMED_EXPRESSION_PATTERN}$`);\n    if (a1CellRefRegexp.test(expressionName) || r1c1CellRefRegexp.test(expressionName)) {\n      return false;\n    }\n    return namedExpRegexp.test(expressionName);\n  }\n  addNamedExpression(expressionName, sheetId, options) {\n    const store = sheetId === undefined ? this.workbookStore : this.worksheetStoreOrCreate(sheetId);\n    let namedExpression = store.get(expressionName);\n    if (namedExpression !== undefined) {\n      namedExpression.added = true;\n      namedExpression.displayName = expressionName;\n      namedExpression.options = options;\n    } else {\n      namedExpression = new InternalNamedExpression(expressionName, this.nextAddress(), true, options);\n      store.add(namedExpression);\n    }\n    this.addressCache.set(namedExpression.address.row, namedExpression);\n    return namedExpression;\n  }\n  restoreNamedExpression(namedExpression, sheetId) {\n    const store = sheetId === undefined ? this.workbookStore : this.worksheetStoreOrCreate(sheetId);\n    namedExpression.added = true;\n    store.add(namedExpression);\n    this.addressCache.set(namedExpression.address.row, namedExpression);\n    return namedExpression;\n  }\n  namedExpressionOrPlaceholder(expressionName, sheetId) {\n    var _a;\n    return (_a = this.worksheetStoreOrCreate(sheetId).get(expressionName)) !== null && _a !== void 0 ? _a : this.workbookNamedExpressionOrPlaceholder(expressionName);\n  }\n  workbookNamedExpressionOrPlaceholder(expressionName) {\n    let namedExpression = this.workbookStore.get(expressionName);\n    if (namedExpression === undefined) {\n      namedExpression = new InternalNamedExpression(expressionName, this.nextAddress(), false);\n      this.workbookStore.add(namedExpression);\n    }\n    return namedExpression;\n  }\n  remove(expressionName, sheetId) {\n    let store;\n    if (sheetId === undefined) {\n      store = this.workbookStore;\n    } else {\n      store = this.worksheetStore(sheetId);\n    }\n    const namedExpression = store === null || store === void 0 ? void 0 : store.get(expressionName);\n    if (store === undefined || namedExpression === undefined || !namedExpression.added) {\n      throw Error('Named expression does not exist');\n    }\n    store.remove(expressionName);\n    if (store instanceof WorksheetStore && store.mapping.size === 0) {\n      this.worksheetStores.delete(sheetId);\n    }\n    this.addressCache.delete(namedExpression.address.row);\n  }\n  getAllNamedExpressionsNamesInScope(sheetId) {\n    return this.getAllNamedExpressions().filter(({\n      scope\n    }) => scope === sheetId).map(ne => ne.expression.displayName);\n  }\n  getAllNamedExpressionsNames() {\n    return this.getAllNamedExpressions().map(ne => ne.expression.displayName);\n  }\n  getAllNamedExpressions() {\n    const storedNamedExpressions = [];\n    this.workbookStore.getAllNamedExpressions().forEach(expr => {\n      storedNamedExpressions.push({\n        expression: expr,\n        scope: undefined\n      });\n    });\n    this.worksheetStores.forEach((store, sheetNum) => {\n      store.getAllNamedExpressions().forEach(expr => {\n        storedNamedExpressions.push({\n          expression: expr,\n          scope: sheetNum\n        });\n      });\n    });\n    return storedNamedExpressions;\n  }\n  getAllNamedExpressionsForScope(scope) {\n    var _a, _b;\n    if (scope === undefined) {\n      return this.workbookStore.getAllNamedExpressions();\n    } else {\n      return (_b = (_a = this.worksheetStores.get(scope)) === null || _a === void 0 ? void 0 : _a.getAllNamedExpressions()) !== null && _b !== void 0 ? _b : [];\n    }\n  }\n  worksheetStoreOrCreate(sheetId) {\n    let store = this.worksheetStores.get(sheetId);\n    if (!store) {\n      store = new WorksheetStore();\n      this.worksheetStores.set(sheetId, store);\n    }\n    return store;\n  }\n  worksheetStore(sheetId) {\n    return this.worksheetStores.get(sheetId);\n  }\n  nextAddress() {\n    return simpleCellAddress(NamedExpressions.SHEET_FOR_WORKBOOK_EXPRESSIONS, 0, this.nextNamedExpressionRow++);\n  }\n}\nNamedExpressions.SHEET_FOR_WORKBOOK_EXPRESSIONS = -1;\nexport const doesContainRelativeReferences = ast => {\n  switch (ast.type) {\n    case AstNodeType.EMPTY:\n    case AstNodeType.NUMBER:\n    case AstNodeType.STRING:\n    case AstNodeType.ERROR:\n    case AstNodeType.ERROR_WITH_RAW_INPUT:\n      return false;\n    case AstNodeType.CELL_REFERENCE:\n      return !ast.reference.isAbsolute();\n    case AstNodeType.CELL_RANGE:\n    case AstNodeType.COLUMN_RANGE:\n    case AstNodeType.ROW_RANGE:\n      return !ast.start.isAbsolute();\n    case AstNodeType.NAMED_EXPRESSION:\n      return false;\n    case AstNodeType.PERCENT_OP:\n    case AstNodeType.PLUS_UNARY_OP:\n    case AstNodeType.MINUS_UNARY_OP:\n      {\n        return doesContainRelativeReferences(ast.value);\n      }\n    case AstNodeType.CONCATENATE_OP:\n    case AstNodeType.EQUALS_OP:\n    case AstNodeType.NOT_EQUAL_OP:\n    case AstNodeType.LESS_THAN_OP:\n    case AstNodeType.GREATER_THAN_OP:\n    case AstNodeType.LESS_THAN_OR_EQUAL_OP:\n    case AstNodeType.GREATER_THAN_OR_EQUAL_OP:\n    case AstNodeType.MINUS_OP:\n    case AstNodeType.PLUS_OP:\n    case AstNodeType.TIMES_OP:\n    case AstNodeType.DIV_OP:\n    case AstNodeType.POWER_OP:\n      return doesContainRelativeReferences(ast.left) || doesContainRelativeReferences(ast.right);\n    case AstNodeType.PARENTHESIS:\n      return doesContainRelativeReferences(ast.expression);\n    case AstNodeType.FUNCTION_CALL:\n      {\n        return ast.args.some(arg => doesContainRelativeReferences(arg));\n      }\n    case AstNodeType.ARRAY:\n      {\n        return ast.args.some(row => row.some(arg => doesContainRelativeReferences(arg)));\n      }\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}