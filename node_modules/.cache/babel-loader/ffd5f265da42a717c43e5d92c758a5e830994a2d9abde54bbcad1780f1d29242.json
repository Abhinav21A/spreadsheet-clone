{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { CellError, ErrorType } from \"../Cell.mjs\";\nimport { AstNodeType, buildCellErrorAst, CellAddress } from \"../parser/index.mjs\";\nexport class Transformer {\n  performEagerTransformations(graph, parser) {\n    for (const node of graph.arrayFormulaNodes()) {\n      const [newAst, newAddress] = this.transformSingleAst(node.getFormula(graph.lazilyTransformingAstService), node.getAddress(graph.lazilyTransformingAstService));\n      const cachedAst = parser.rememberNewAst(newAst);\n      node.setFormula(cachedAst);\n      node.setAddress(newAddress);\n    }\n  }\n  transformSingleAst(ast, address) {\n    const newAst = this.transformAst(ast, address);\n    const newAddress = this.fixNodeAddress(address);\n    return [newAst, newAddress];\n  }\n  transformAst(ast, address) {\n    switch (ast.type) {\n      case AstNodeType.CELL_REFERENCE:\n        {\n          return this.transformCellReferenceAst(ast, address);\n        }\n      case AstNodeType.CELL_RANGE:\n        {\n          return this.transformCellRangeAst(ast, address);\n        }\n      case AstNodeType.COLUMN_RANGE:\n        {\n          return this.transformColumnRangeAst(ast, address);\n        }\n      case AstNodeType.ROW_RANGE:\n        {\n          return this.transformRowRangeAst(ast, address);\n        }\n      case AstNodeType.EMPTY:\n      case AstNodeType.ERROR:\n      case AstNodeType.NUMBER:\n      case AstNodeType.NAMED_EXPRESSION:\n      case AstNodeType.ERROR_WITH_RAW_INPUT:\n      case AstNodeType.STRING:\n        {\n          return ast;\n        }\n      case AstNodeType.PERCENT_OP:\n      case AstNodeType.MINUS_UNARY_OP:\n      case AstNodeType.PLUS_UNARY_OP:\n        {\n          return Object.assign(Object.assign({}, ast), {\n            value: this.transformAst(ast.value, address)\n          });\n        }\n      case AstNodeType.FUNCTION_CALL:\n        {\n          return Object.assign(Object.assign({}, ast), {\n            procedureName: ast.procedureName,\n            args: ast.args.map(arg => this.transformAst(arg, address))\n          });\n        }\n      case AstNodeType.PARENTHESIS:\n        {\n          return Object.assign(Object.assign({}, ast), {\n            expression: this.transformAst(ast.expression, address)\n          });\n        }\n      case AstNodeType.ARRAY:\n        {\n          return Object.assign(Object.assign({}, ast), {\n            args: ast.args.map(row => row.map(val => this.transformAst(val, address)))\n          });\n        }\n      default:\n        {\n          return Object.assign(Object.assign({}, ast), {\n            left: this.transformAst(ast.left, address),\n            right: this.transformAst(ast.right, address)\n          });\n        }\n    }\n  }\n  transformCellReferenceAst(ast, formulaAddress) {\n    const newCellAddress = this.transformCellAddress(ast.reference, formulaAddress);\n    if (newCellAddress instanceof CellAddress) {\n      return Object.assign(Object.assign({}, ast), {\n        reference: newCellAddress\n      });\n    } else if (newCellAddress === ErrorType.REF) {\n      return buildCellErrorAst(new CellError(ErrorType.REF));\n    } else {\n      return ast;\n    }\n  }\n  transformCellRangeAst(ast, formulaAddress) {\n    const newRange = this.transformCellRange(ast.start, ast.end, formulaAddress);\n    if (Array.isArray(newRange)) {\n      return Object.assign(Object.assign({}, ast), {\n        start: newRange[0],\n        end: newRange[1]\n      });\n    } else if (newRange === ErrorType.REF) {\n      return buildCellErrorAst(new CellError(ErrorType.REF));\n    } else {\n      return ast;\n    }\n  }\n  transformColumnRangeAst(ast, formulaAddress) {\n    const newRange = this.transformColumnRange(ast.start, ast.end, formulaAddress);\n    if (Array.isArray(newRange)) {\n      return Object.assign(Object.assign({}, ast), {\n        start: newRange[0],\n        end: newRange[1]\n      });\n    } else if (newRange === ErrorType.REF) {\n      return buildCellErrorAst(new CellError(ErrorType.REF));\n    } else {\n      return ast;\n    }\n  }\n  transformRowRangeAst(ast, formulaAddress) {\n    const newRange = this.transformRowRange(ast.start, ast.end, formulaAddress);\n    if (Array.isArray(newRange)) {\n      return Object.assign(Object.assign({}, ast), {\n        start: newRange[0],\n        end: newRange[1]\n      });\n    } else if (newRange === ErrorType.REF) {\n      return buildCellErrorAst(new CellError(ErrorType.REF));\n    } else {\n      return ast;\n    }\n  }\n}","map":{"version":3,"names":["CellError","ErrorType","AstNodeType","buildCellErrorAst","CellAddress","Transformer","performEagerTransformations","graph","parser","node","arrayFormulaNodes","newAst","newAddress","transformSingleAst","getFormula","lazilyTransformingAstService","getAddress","cachedAst","rememberNewAst","setFormula","setAddress","ast","address","transformAst","fixNodeAddress","type","CELL_REFERENCE","transformCellReferenceAst","CELL_RANGE","transformCellRangeAst","COLUMN_RANGE","transformColumnRangeAst","ROW_RANGE","transformRowRangeAst","EMPTY","ERROR","NUMBER","NAMED_EXPRESSION","ERROR_WITH_RAW_INPUT","STRING","PERCENT_OP","MINUS_UNARY_OP","PLUS_UNARY_OP","Object","assign","value","FUNCTION_CALL","procedureName","args","map","arg","PARENTHESIS","expression","ARRAY","row","val","left","right","formulaAddress","newCellAddress","transformCellAddress","reference","REF","newRange","transformCellRange","start","end","Array","isArray","transformColumnRange","transformRowRange"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/dependencyTransformers/Transformer.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { CellError, ErrorType } from \"../Cell.mjs\";\nimport { AstNodeType, buildCellErrorAst, CellAddress } from \"../parser/index.mjs\";\nexport class Transformer {\n  performEagerTransformations(graph, parser) {\n    for (const node of graph.arrayFormulaNodes()) {\n      const [newAst, newAddress] = this.transformSingleAst(node.getFormula(graph.lazilyTransformingAstService), node.getAddress(graph.lazilyTransformingAstService));\n      const cachedAst = parser.rememberNewAst(newAst);\n      node.setFormula(cachedAst);\n      node.setAddress(newAddress);\n    }\n  }\n  transformSingleAst(ast, address) {\n    const newAst = this.transformAst(ast, address);\n    const newAddress = this.fixNodeAddress(address);\n    return [newAst, newAddress];\n  }\n  transformAst(ast, address) {\n    switch (ast.type) {\n      case AstNodeType.CELL_REFERENCE:\n        {\n          return this.transformCellReferenceAst(ast, address);\n        }\n      case AstNodeType.CELL_RANGE:\n        {\n          return this.transformCellRangeAst(ast, address);\n        }\n      case AstNodeType.COLUMN_RANGE:\n        {\n          return this.transformColumnRangeAst(ast, address);\n        }\n      case AstNodeType.ROW_RANGE:\n        {\n          return this.transformRowRangeAst(ast, address);\n        }\n      case AstNodeType.EMPTY:\n      case AstNodeType.ERROR:\n      case AstNodeType.NUMBER:\n      case AstNodeType.NAMED_EXPRESSION:\n      case AstNodeType.ERROR_WITH_RAW_INPUT:\n      case AstNodeType.STRING:\n        {\n          return ast;\n        }\n      case AstNodeType.PERCENT_OP:\n      case AstNodeType.MINUS_UNARY_OP:\n      case AstNodeType.PLUS_UNARY_OP:\n        {\n          return Object.assign(Object.assign({}, ast), {\n            value: this.transformAst(ast.value, address)\n          });\n        }\n      case AstNodeType.FUNCTION_CALL:\n        {\n          return Object.assign(Object.assign({}, ast), {\n            procedureName: ast.procedureName,\n            args: ast.args.map(arg => this.transformAst(arg, address))\n          });\n        }\n      case AstNodeType.PARENTHESIS:\n        {\n          return Object.assign(Object.assign({}, ast), {\n            expression: this.transformAst(ast.expression, address)\n          });\n        }\n      case AstNodeType.ARRAY:\n        {\n          return Object.assign(Object.assign({}, ast), {\n            args: ast.args.map(row => row.map(val => this.transformAst(val, address)))\n          });\n        }\n      default:\n        {\n          return Object.assign(Object.assign({}, ast), {\n            left: this.transformAst(ast.left, address),\n            right: this.transformAst(ast.right, address)\n          });\n        }\n    }\n  }\n  transformCellReferenceAst(ast, formulaAddress) {\n    const newCellAddress = this.transformCellAddress(ast.reference, formulaAddress);\n    if (newCellAddress instanceof CellAddress) {\n      return Object.assign(Object.assign({}, ast), {\n        reference: newCellAddress\n      });\n    } else if (newCellAddress === ErrorType.REF) {\n      return buildCellErrorAst(new CellError(ErrorType.REF));\n    } else {\n      return ast;\n    }\n  }\n  transformCellRangeAst(ast, formulaAddress) {\n    const newRange = this.transformCellRange(ast.start, ast.end, formulaAddress);\n    if (Array.isArray(newRange)) {\n      return Object.assign(Object.assign({}, ast), {\n        start: newRange[0],\n        end: newRange[1]\n      });\n    } else if (newRange === ErrorType.REF) {\n      return buildCellErrorAst(new CellError(ErrorType.REF));\n    } else {\n      return ast;\n    }\n  }\n  transformColumnRangeAst(ast, formulaAddress) {\n    const newRange = this.transformColumnRange(ast.start, ast.end, formulaAddress);\n    if (Array.isArray(newRange)) {\n      return Object.assign(Object.assign({}, ast), {\n        start: newRange[0],\n        end: newRange[1]\n      });\n    } else if (newRange === ErrorType.REF) {\n      return buildCellErrorAst(new CellError(ErrorType.REF));\n    } else {\n      return ast;\n    }\n  }\n  transformRowRangeAst(ast, formulaAddress) {\n    const newRange = this.transformRowRange(ast.start, ast.end, formulaAddress);\n    if (Array.isArray(newRange)) {\n      return Object.assign(Object.assign({}, ast), {\n        start: newRange[0],\n        end: newRange[1]\n      });\n    } else if (newRange === ErrorType.REF) {\n      return buildCellErrorAst(new CellError(ErrorType.REF));\n    } else {\n      return ast;\n    }\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}