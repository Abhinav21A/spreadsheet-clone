{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { simpleCellRange } from \"../AbsoluteCellRange.mjs\";\nimport { simpleCellAddress } from \"../Cell.mjs\";\nimport { CellAddress } from \"./CellAddress.mjs\";\nimport { ColumnAddress } from \"./ColumnAddress.mjs\";\nimport { ABSOLUTE_OPERATOR, RANGE_OPERATOR, SHEET_NAME_PATTERN, UNQUOTED_SHEET_NAME_PATTERN } from \"./parser-consts.mjs\";\nimport { RowAddress } from \"./RowAddress.mjs\";\nconst addressRegex = new RegExp(`^(${SHEET_NAME_PATTERN})?(\\\\${ABSOLUTE_OPERATOR}?)([A-Za-z]+)(\\\\${ABSOLUTE_OPERATOR}?)([0-9]+)$`);\nconst columnRegex = new RegExp(`^(${SHEET_NAME_PATTERN})?(\\\\${ABSOLUTE_OPERATOR}?)([A-Za-z]+)$`);\nconst rowRegex = new RegExp(`^(${SHEET_NAME_PATTERN})?(\\\\${ABSOLUTE_OPERATOR}?)([0-9]+)$`);\nconst simpleSheetNameRegex = new RegExp(`^${UNQUOTED_SHEET_NAME_PATTERN}$`);\n/**\r\n * Computes R0C0 representation of cell address based on it's string representation and base address.\r\n *\r\n * @param sheetMapping - mapping function needed to change name of a sheet to index\r\n * @param stringAddress - string representation of cell address, e.g., 'C64'\r\n * @param baseAddress - base address for R0C0 conversion\r\n * @returns object representation of address\r\n */\nexport const cellAddressFromString = (sheetMapping, stringAddress, baseAddress) => {\n  const result = addressRegex.exec(stringAddress);\n  const col = columnLabelToIndex(result[6]);\n  let sheet = extractSheetNumber(result, sheetMapping);\n  if (sheet === undefined) {\n    return undefined;\n  }\n  if (sheet === null) {\n    sheet = undefined;\n  }\n  const row = Number(result[8]) - 1;\n  if (result[5] === ABSOLUTE_OPERATOR && result[7] === ABSOLUTE_OPERATOR) {\n    return CellAddress.absolute(col, row, sheet);\n  } else if (result[5] === ABSOLUTE_OPERATOR) {\n    return CellAddress.absoluteCol(col, row - baseAddress.row, sheet);\n  } else if (result[7] === ABSOLUTE_OPERATOR) {\n    return CellAddress.absoluteRow(col - baseAddress.col, row, sheet);\n  } else {\n    return CellAddress.relative(col - baseAddress.col, row - baseAddress.row, sheet);\n  }\n};\nexport const columnAddressFromString = (sheetMapping, stringAddress, baseAddress) => {\n  const result = columnRegex.exec(stringAddress);\n  let sheet = extractSheetNumber(result, sheetMapping);\n  if (sheet === undefined) {\n    return undefined;\n  }\n  if (sheet === null) {\n    sheet = undefined;\n  }\n  const col = columnLabelToIndex(result[6]);\n  if (result[5] === ABSOLUTE_OPERATOR) {\n    return ColumnAddress.absolute(col, sheet);\n  } else {\n    return ColumnAddress.relative(col - baseAddress.col, sheet);\n  }\n};\nexport const rowAddressFromString = (sheetMapping, stringAddress, baseAddress) => {\n  const result = rowRegex.exec(stringAddress);\n  let sheet = extractSheetNumber(result, sheetMapping);\n  if (sheet === undefined) {\n    return undefined;\n  }\n  if (sheet === null) {\n    sheet = undefined;\n  }\n  const row = Number(result[6]) - 1;\n  if (result[5] === ABSOLUTE_OPERATOR) {\n    return RowAddress.absolute(row, sheet);\n  } else {\n    return RowAddress.relative(row - baseAddress.row, sheet);\n  }\n};\n/**\r\n * Computes simple (absolute) address of a cell address based on its string representation.\r\n * - If sheet name is present in the string representation but is not present in sheet mapping, returns `undefined`.\r\n * - If sheet name is not present in the string representation, returns {@param contextSheetId} as sheet number.\r\n *\r\n * @param sheetMapping - mapping function needed to change name of a sheet to index\r\n * @param stringAddress - string representation of cell address, e.g., 'C64'\r\n * @param contextSheetId - sheet in context of which we should parse the address\r\n * @returns absolute representation of address, e.g., { sheet: 0, col: 1, row: 1 }\r\n */\nexport const simpleCellAddressFromString = (sheetMapping, stringAddress, contextSheetId) => {\n  const regExpExecArray = addressRegex.exec(stringAddress);\n  if (!regExpExecArray) {\n    return undefined;\n  }\n  const col = columnLabelToIndex(regExpExecArray[6]);\n  let sheet = extractSheetNumber(regExpExecArray, sheetMapping);\n  if (sheet === undefined) {\n    return undefined;\n  }\n  if (sheet === null) {\n    sheet = contextSheetId;\n  }\n  const row = Number(regExpExecArray[8]) - 1;\n  return simpleCellAddress(sheet, col, row);\n};\nexport const simpleCellRangeFromString = (sheetMapping, stringAddress, contextSheetId) => {\n  const split = stringAddress.split(RANGE_OPERATOR);\n  if (split.length !== 2) {\n    return undefined;\n  }\n  const [startString, endString] = split;\n  const start = simpleCellAddressFromString(sheetMapping, startString, contextSheetId);\n  if (start === undefined) {\n    return undefined;\n  }\n  const end = simpleCellAddressFromString(sheetMapping, endString, start.sheet);\n  if (end === undefined) {\n    return undefined;\n  }\n  if (start.sheet !== end.sheet) {\n    return undefined;\n  }\n  return simpleCellRange(start, end);\n};\n/**\r\n * Returns string representation of absolute address\r\n * If sheet index is not present in sheet mapping, returns undefined\r\n *\r\n * @param sheetIndexMapping - mapping function needed to change sheet index to sheet name\r\n * @param address - object representation of absolute address\r\n * @param sheetIndex - if is not equal with address sheet index, string representation will contain sheet name\r\n */\nexport const simpleCellAddressToString = (sheetIndexMapping, address, sheetIndex) => {\n  const column = columnIndexToLabel(address.col);\n  const sheetName = sheetIndexToString(address.sheet, sheetIndexMapping);\n  if (sheetName === undefined) {\n    return undefined;\n  }\n  if (sheetIndex !== address.sheet) {\n    return `${sheetName}!${column}${address.row + 1}`;\n  } else {\n    return `${column}${address.row + 1}`;\n  }\n};\nexport const simpleCellRangeToString = (sheetIndexMapping, address, sheetIndex) => {\n  const startString = simpleCellAddressToString(sheetIndexMapping, address.start, sheetIndex);\n  const endString = simpleCellAddressToString(sheetIndexMapping, address.end, address.start.sheet);\n  if (startString === undefined || endString === undefined) {\n    return undefined;\n  } else {\n    return `${startString}${RANGE_OPERATOR}${endString}`;\n  }\n};\n/**\r\n * Convert column label to index\r\n *\r\n * @param columnStringRepresentation - column label (e.g., 'AAB')\r\n * @returns column index\r\n */\nfunction columnLabelToIndex(columnStringRepresentation) {\n  if (columnStringRepresentation.length === 1) {\n    return columnStringRepresentation.toUpperCase().charCodeAt(0) - 65;\n  } else {\n    return columnStringRepresentation.split('').reduce((currentColumn, nextLetter) => {\n      return currentColumn * 26 + (nextLetter.toUpperCase().charCodeAt(0) - 64);\n    }, 0) - 1;\n  }\n}\n/**\r\n * Converts column index to label\r\n *\r\n * @param column - address to convert\r\n * @returns string representation, e.g., 'AAB'\r\n */\nexport function columnIndexToLabel(column) {\n  let result = '';\n  while (column >= 0) {\n    result = String.fromCharCode(column % 26 + 97) + result;\n    column = Math.floor(column / 26) - 1;\n  }\n  return result.toUpperCase();\n}\nexport function sheetIndexToString(sheetId, sheetMappingFn) {\n  let sheetName = sheetMappingFn(sheetId);\n  if (sheetName === undefined) {\n    return undefined;\n  }\n  if (simpleSheetNameRegex.test(sheetName)) {\n    return sheetName;\n  } else {\n    sheetName = sheetName.replace(/'/g, \"''\");\n    return `'${sheetName}'`;\n  }\n}\nfunction extractSheetNumber(regexResult, sheetMapping) {\n  var _a;\n  let maybeSheetName = (_a = regexResult[3]) !== null && _a !== void 0 ? _a : regexResult[2];\n  if (maybeSheetName) {\n    maybeSheetName = maybeSheetName.replace(/''/g, \"'\");\n    return sheetMapping(maybeSheetName);\n  } else {\n    return null;\n  }\n}","map":{"version":3,"names":["simpleCellRange","simpleCellAddress","CellAddress","ColumnAddress","ABSOLUTE_OPERATOR","RANGE_OPERATOR","SHEET_NAME_PATTERN","UNQUOTED_SHEET_NAME_PATTERN","RowAddress","addressRegex","RegExp","columnRegex","rowRegex","simpleSheetNameRegex","cellAddressFromString","sheetMapping","stringAddress","baseAddress","result","exec","col","columnLabelToIndex","sheet","extractSheetNumber","undefined","row","Number","absolute","absoluteCol","absoluteRow","relative","columnAddressFromString","rowAddressFromString","simpleCellAddressFromString","contextSheetId","regExpExecArray","simpleCellRangeFromString","split","length","startString","endString","start","end","simpleCellAddressToString","sheetIndexMapping","address","sheetIndex","column","columnIndexToLabel","sheetName","sheetIndexToString","simpleCellRangeToString","columnStringRepresentation","toUpperCase","charCodeAt","reduce","currentColumn","nextLetter","String","fromCharCode","Math","floor","sheetId","sheetMappingFn","test","replace","regexResult","_a","maybeSheetName"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/parser/addressRepresentationConverters.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { simpleCellRange } from \"../AbsoluteCellRange.mjs\";\nimport { simpleCellAddress } from \"../Cell.mjs\";\nimport { CellAddress } from \"./CellAddress.mjs\";\nimport { ColumnAddress } from \"./ColumnAddress.mjs\";\nimport { ABSOLUTE_OPERATOR, RANGE_OPERATOR, SHEET_NAME_PATTERN, UNQUOTED_SHEET_NAME_PATTERN } from \"./parser-consts.mjs\";\nimport { RowAddress } from \"./RowAddress.mjs\";\nconst addressRegex = new RegExp(`^(${SHEET_NAME_PATTERN})?(\\\\${ABSOLUTE_OPERATOR}?)([A-Za-z]+)(\\\\${ABSOLUTE_OPERATOR}?)([0-9]+)$`);\nconst columnRegex = new RegExp(`^(${SHEET_NAME_PATTERN})?(\\\\${ABSOLUTE_OPERATOR}?)([A-Za-z]+)$`);\nconst rowRegex = new RegExp(`^(${SHEET_NAME_PATTERN})?(\\\\${ABSOLUTE_OPERATOR}?)([0-9]+)$`);\nconst simpleSheetNameRegex = new RegExp(`^${UNQUOTED_SHEET_NAME_PATTERN}$`);\n/**\r\n * Computes R0C0 representation of cell address based on it's string representation and base address.\r\n *\r\n * @param sheetMapping - mapping function needed to change name of a sheet to index\r\n * @param stringAddress - string representation of cell address, e.g., 'C64'\r\n * @param baseAddress - base address for R0C0 conversion\r\n * @returns object representation of address\r\n */\nexport const cellAddressFromString = (sheetMapping, stringAddress, baseAddress) => {\n  const result = addressRegex.exec(stringAddress);\n  const col = columnLabelToIndex(result[6]);\n  let sheet = extractSheetNumber(result, sheetMapping);\n  if (sheet === undefined) {\n    return undefined;\n  }\n  if (sheet === null) {\n    sheet = undefined;\n  }\n  const row = Number(result[8]) - 1;\n  if (result[5] === ABSOLUTE_OPERATOR && result[7] === ABSOLUTE_OPERATOR) {\n    return CellAddress.absolute(col, row, sheet);\n  } else if (result[5] === ABSOLUTE_OPERATOR) {\n    return CellAddress.absoluteCol(col, row - baseAddress.row, sheet);\n  } else if (result[7] === ABSOLUTE_OPERATOR) {\n    return CellAddress.absoluteRow(col - baseAddress.col, row, sheet);\n  } else {\n    return CellAddress.relative(col - baseAddress.col, row - baseAddress.row, sheet);\n  }\n};\nexport const columnAddressFromString = (sheetMapping, stringAddress, baseAddress) => {\n  const result = columnRegex.exec(stringAddress);\n  let sheet = extractSheetNumber(result, sheetMapping);\n  if (sheet === undefined) {\n    return undefined;\n  }\n  if (sheet === null) {\n    sheet = undefined;\n  }\n  const col = columnLabelToIndex(result[6]);\n  if (result[5] === ABSOLUTE_OPERATOR) {\n    return ColumnAddress.absolute(col, sheet);\n  } else {\n    return ColumnAddress.relative(col - baseAddress.col, sheet);\n  }\n};\nexport const rowAddressFromString = (sheetMapping, stringAddress, baseAddress) => {\n  const result = rowRegex.exec(stringAddress);\n  let sheet = extractSheetNumber(result, sheetMapping);\n  if (sheet === undefined) {\n    return undefined;\n  }\n  if (sheet === null) {\n    sheet = undefined;\n  }\n  const row = Number(result[6]) - 1;\n  if (result[5] === ABSOLUTE_OPERATOR) {\n    return RowAddress.absolute(row, sheet);\n  } else {\n    return RowAddress.relative(row - baseAddress.row, sheet);\n  }\n};\n/**\r\n * Computes simple (absolute) address of a cell address based on its string representation.\r\n * - If sheet name is present in the string representation but is not present in sheet mapping, returns `undefined`.\r\n * - If sheet name is not present in the string representation, returns {@param contextSheetId} as sheet number.\r\n *\r\n * @param sheetMapping - mapping function needed to change name of a sheet to index\r\n * @param stringAddress - string representation of cell address, e.g., 'C64'\r\n * @param contextSheetId - sheet in context of which we should parse the address\r\n * @returns absolute representation of address, e.g., { sheet: 0, col: 1, row: 1 }\r\n */\nexport const simpleCellAddressFromString = (sheetMapping, stringAddress, contextSheetId) => {\n  const regExpExecArray = addressRegex.exec(stringAddress);\n  if (!regExpExecArray) {\n    return undefined;\n  }\n  const col = columnLabelToIndex(regExpExecArray[6]);\n  let sheet = extractSheetNumber(regExpExecArray, sheetMapping);\n  if (sheet === undefined) {\n    return undefined;\n  }\n  if (sheet === null) {\n    sheet = contextSheetId;\n  }\n  const row = Number(regExpExecArray[8]) - 1;\n  return simpleCellAddress(sheet, col, row);\n};\nexport const simpleCellRangeFromString = (sheetMapping, stringAddress, contextSheetId) => {\n  const split = stringAddress.split(RANGE_OPERATOR);\n  if (split.length !== 2) {\n    return undefined;\n  }\n  const [startString, endString] = split;\n  const start = simpleCellAddressFromString(sheetMapping, startString, contextSheetId);\n  if (start === undefined) {\n    return undefined;\n  }\n  const end = simpleCellAddressFromString(sheetMapping, endString, start.sheet);\n  if (end === undefined) {\n    return undefined;\n  }\n  if (start.sheet !== end.sheet) {\n    return undefined;\n  }\n  return simpleCellRange(start, end);\n};\n/**\r\n * Returns string representation of absolute address\r\n * If sheet index is not present in sheet mapping, returns undefined\r\n *\r\n * @param sheetIndexMapping - mapping function needed to change sheet index to sheet name\r\n * @param address - object representation of absolute address\r\n * @param sheetIndex - if is not equal with address sheet index, string representation will contain sheet name\r\n */\nexport const simpleCellAddressToString = (sheetIndexMapping, address, sheetIndex) => {\n  const column = columnIndexToLabel(address.col);\n  const sheetName = sheetIndexToString(address.sheet, sheetIndexMapping);\n  if (sheetName === undefined) {\n    return undefined;\n  }\n  if (sheetIndex !== address.sheet) {\n    return `${sheetName}!${column}${address.row + 1}`;\n  } else {\n    return `${column}${address.row + 1}`;\n  }\n};\nexport const simpleCellRangeToString = (sheetIndexMapping, address, sheetIndex) => {\n  const startString = simpleCellAddressToString(sheetIndexMapping, address.start, sheetIndex);\n  const endString = simpleCellAddressToString(sheetIndexMapping, address.end, address.start.sheet);\n  if (startString === undefined || endString === undefined) {\n    return undefined;\n  } else {\n    return `${startString}${RANGE_OPERATOR}${endString}`;\n  }\n};\n/**\r\n * Convert column label to index\r\n *\r\n * @param columnStringRepresentation - column label (e.g., 'AAB')\r\n * @returns column index\r\n */\nfunction columnLabelToIndex(columnStringRepresentation) {\n  if (columnStringRepresentation.length === 1) {\n    return columnStringRepresentation.toUpperCase().charCodeAt(0) - 65;\n  } else {\n    return columnStringRepresentation.split('').reduce((currentColumn, nextLetter) => {\n      return currentColumn * 26 + (nextLetter.toUpperCase().charCodeAt(0) - 64);\n    }, 0) - 1;\n  }\n}\n/**\r\n * Converts column index to label\r\n *\r\n * @param column - address to convert\r\n * @returns string representation, e.g., 'AAB'\r\n */\nexport function columnIndexToLabel(column) {\n  let result = '';\n  while (column >= 0) {\n    result = String.fromCharCode(column % 26 + 97) + result;\n    column = Math.floor(column / 26) - 1;\n  }\n  return result.toUpperCase();\n}\nexport function sheetIndexToString(sheetId, sheetMappingFn) {\n  let sheetName = sheetMappingFn(sheetId);\n  if (sheetName === undefined) {\n    return undefined;\n  }\n  if (simpleSheetNameRegex.test(sheetName)) {\n    return sheetName;\n  } else {\n    sheetName = sheetName.replace(/'/g, \"''\");\n    return `'${sheetName}'`;\n  }\n}\nfunction extractSheetNumber(regexResult, sheetMapping) {\n  var _a;\n  let maybeSheetName = (_a = regexResult[3]) !== null && _a !== void 0 ? _a : regexResult[2];\n  if (maybeSheetName) {\n    maybeSheetName = maybeSheetName.replace(/''/g, \"'\");\n    return sheetMapping(maybeSheetName);\n  } else {\n    return null;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}