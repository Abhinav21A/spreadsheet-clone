{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { CellError, simpleCellAddress } from \"../Cell.mjs\";\nimport { EmptyValue, getRawValue } from \"./InterpreterValue.mjs\";\nconst NOT_FOUND = -1;\n/*\r\n * Searches for the searchKey in a sorted 1-D range.\r\n *\r\n * Options:\r\n * - searchCoordinate - must be set to either 'row' or 'col' to indicate the dimension of the search,\r\n * - orderingDirection - must be set to either 'asc' or 'desc' to indicate the ordering direction for the search range,\r\n * - ifNoMatch - must be set to 'returnLowerBound', 'returnUpperBound' or 'returnNotFound'\r\n *\r\n * If the search range contains duplicates, returns the last matching value. If no value found in the range satisfies the above, returns -1.\r\n *\r\n * Note: this function does not normalize input strings.\r\n */\nexport function findLastOccurrenceInOrderedRange(searchKey, range, {\n  searchCoordinate,\n  orderingDirection,\n  ifNoMatch\n}, dependencyGraph) {\n  const start = range.start[searchCoordinate];\n  const end = searchCoordinate === 'col' ? range.effectiveEndColumn(dependencyGraph) : range.effectiveEndRow(dependencyGraph);\n  const getValueFromIndexFn = searchCoordinate === 'col' ? index => getRawValue(dependencyGraph.getCellValue(simpleCellAddress(range.sheet, index, range.start.row))) : index => getRawValue(dependencyGraph.getCellValue(simpleCellAddress(range.sheet, range.start.col, index)));\n  const compareFn = orderingDirection === 'asc' ? (left, right) => compare(left, right) : (left, right) => -compare(left, right);\n  const foundIndex = findLastMatchingIndex(index => compareFn(searchKey, getValueFromIndexFn(index)) >= 0, start, end);\n  const foundValue = getValueFromIndexFn(foundIndex);\n  if (foundValue === searchKey) {\n    return foundIndex - start;\n  }\n  if (ifNoMatch === 'returnLowerBound') {\n    if (foundIndex === NOT_FOUND) {\n      return orderingDirection === 'asc' ? NOT_FOUND : 0;\n    }\n    if (typeof foundValue !== typeof searchKey) {\n      return NOT_FOUND;\n    }\n    // here: foundValue !== searchKey\n    if (orderingDirection === 'asc') {\n      return foundIndex - start;\n    }\n    // orderingDirection === 'desc'\n    const nextIndex = foundIndex + 1;\n    return nextIndex <= end ? nextIndex - start : NOT_FOUND;\n  }\n  if (ifNoMatch === 'returnUpperBound') {\n    if (foundIndex === NOT_FOUND) {\n      return orderingDirection === 'asc' ? 0 : NOT_FOUND;\n    }\n    if (typeof foundValue !== typeof searchKey) {\n      return NOT_FOUND;\n    }\n    // here: foundValue !== searchKey\n    if (orderingDirection === 'desc') {\n      return foundIndex - start;\n    }\n    // orderingDirection === 'asc'\n    const nextIndex = foundIndex + 1;\n    return nextIndex <= end ? nextIndex - start : NOT_FOUND;\n  }\n  // ifNoMatch === 'returnNotFound'\n  return NOT_FOUND;\n}\n/*\r\n * Searches for the searchKey in a sorted array.\r\n * Param orderingDirection must be set to either 'asc' or 'desc' to indicate the ordering direction of the array.\r\n *\r\n * Semantics:\r\n * - If orderingDirection === 'asc', searches for the lower bound for the searchKey value.\r\n * - If orderingDirection === 'desc', searches for the upper bound for the searchKey value.\r\n * - If the array contains duplicates, returns the last matching value.\r\n * - If no value in the range satisfies the above, returns -1.\r\n */\nexport function findLastOccurrenceInOrderedArray(searchKey, array, orderingDirection = 'asc') {\n  const predicate = orderingDirection === 'asc' ? index => compare(searchKey, array[index]) >= 0 : index => -compare(searchKey, array[index]) >= 0;\n  return findLastMatchingIndex(predicate, 0, array.length - 1);\n}\n/*\r\n * Returns:\r\n *   - the last element in the range for which predicate === true or,\r\n *   - value -1 if predicate === false for all elements.\r\n * Assumption: All elements for which predicate === true are before the elements for which predicate === false.\r\n */\nexport function findLastMatchingIndex(predicate, startRange, endRange) {\n  let start = startRange;\n  let end = endRange;\n  while (start < end) {\n    const pivot = Math.ceil((start + end) / 2);\n    if (predicate(pivot)) {\n      start = pivot;\n    } else {\n      end = pivot - 1;\n    }\n  }\n  if (start === end && predicate(start)) {\n    return start;\n  }\n  return NOT_FOUND;\n}\n/*\r\n * numbers < strings < false < true\r\n */\nexport function compare(left, right) {\n  if (typeof left === typeof right) {\n    if (left === EmptyValue) {\n      return 0;\n    }\n    return left < right ? -1 : left > right ? 1 : 0;\n  }\n  if (left === EmptyValue) {\n    return -1;\n  }\n  if (right === EmptyValue) {\n    return 1;\n  }\n  if (right instanceof CellError) {\n    return -1;\n  }\n  if (typeof left === 'number' && typeof right === 'string') {\n    return -1;\n  }\n  if (typeof left === 'number' && typeof right === 'boolean') {\n    return -1;\n  }\n  if (typeof left === 'string' && typeof right === 'number') {\n    return 1;\n  }\n  if (typeof left === 'string' && typeof right === 'boolean') {\n    return -1;\n  }\n  return 1;\n}","map":{"version":3,"names":["CellError","simpleCellAddress","EmptyValue","getRawValue","NOT_FOUND","findLastOccurrenceInOrderedRange","searchKey","range","searchCoordinate","orderingDirection","ifNoMatch","dependencyGraph","start","end","effectiveEndColumn","effectiveEndRow","getValueFromIndexFn","index","getCellValue","sheet","row","col","compareFn","left","right","compare","foundIndex","findLastMatchingIndex","foundValue","nextIndex","findLastOccurrenceInOrderedArray","array","predicate","length","startRange","endRange","pivot","Math","ceil"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/interpreter/binarySearch.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { CellError, simpleCellAddress } from \"../Cell.mjs\";\nimport { EmptyValue, getRawValue } from \"./InterpreterValue.mjs\";\nconst NOT_FOUND = -1;\n/*\r\n * Searches for the searchKey in a sorted 1-D range.\r\n *\r\n * Options:\r\n * - searchCoordinate - must be set to either 'row' or 'col' to indicate the dimension of the search,\r\n * - orderingDirection - must be set to either 'asc' or 'desc' to indicate the ordering direction for the search range,\r\n * - ifNoMatch - must be set to 'returnLowerBound', 'returnUpperBound' or 'returnNotFound'\r\n *\r\n * If the search range contains duplicates, returns the last matching value. If no value found in the range satisfies the above, returns -1.\r\n *\r\n * Note: this function does not normalize input strings.\r\n */\nexport function findLastOccurrenceInOrderedRange(searchKey, range, {\n  searchCoordinate,\n  orderingDirection,\n  ifNoMatch\n}, dependencyGraph) {\n  const start = range.start[searchCoordinate];\n  const end = searchCoordinate === 'col' ? range.effectiveEndColumn(dependencyGraph) : range.effectiveEndRow(dependencyGraph);\n  const getValueFromIndexFn = searchCoordinate === 'col' ? index => getRawValue(dependencyGraph.getCellValue(simpleCellAddress(range.sheet, index, range.start.row))) : index => getRawValue(dependencyGraph.getCellValue(simpleCellAddress(range.sheet, range.start.col, index)));\n  const compareFn = orderingDirection === 'asc' ? (left, right) => compare(left, right) : (left, right) => -compare(left, right);\n  const foundIndex = findLastMatchingIndex(index => compareFn(searchKey, getValueFromIndexFn(index)) >= 0, start, end);\n  const foundValue = getValueFromIndexFn(foundIndex);\n  if (foundValue === searchKey) {\n    return foundIndex - start;\n  }\n  if (ifNoMatch === 'returnLowerBound') {\n    if (foundIndex === NOT_FOUND) {\n      return orderingDirection === 'asc' ? NOT_FOUND : 0;\n    }\n    if (typeof foundValue !== typeof searchKey) {\n      return NOT_FOUND;\n    }\n    // here: foundValue !== searchKey\n    if (orderingDirection === 'asc') {\n      return foundIndex - start;\n    }\n    // orderingDirection === 'desc'\n    const nextIndex = foundIndex + 1;\n    return nextIndex <= end ? nextIndex - start : NOT_FOUND;\n  }\n  if (ifNoMatch === 'returnUpperBound') {\n    if (foundIndex === NOT_FOUND) {\n      return orderingDirection === 'asc' ? 0 : NOT_FOUND;\n    }\n    if (typeof foundValue !== typeof searchKey) {\n      return NOT_FOUND;\n    }\n    // here: foundValue !== searchKey\n    if (orderingDirection === 'desc') {\n      return foundIndex - start;\n    }\n    // orderingDirection === 'asc'\n    const nextIndex = foundIndex + 1;\n    return nextIndex <= end ? nextIndex - start : NOT_FOUND;\n  }\n  // ifNoMatch === 'returnNotFound'\n  return NOT_FOUND;\n}\n/*\r\n * Searches for the searchKey in a sorted array.\r\n * Param orderingDirection must be set to either 'asc' or 'desc' to indicate the ordering direction of the array.\r\n *\r\n * Semantics:\r\n * - If orderingDirection === 'asc', searches for the lower bound for the searchKey value.\r\n * - If orderingDirection === 'desc', searches for the upper bound for the searchKey value.\r\n * - If the array contains duplicates, returns the last matching value.\r\n * - If no value in the range satisfies the above, returns -1.\r\n */\nexport function findLastOccurrenceInOrderedArray(searchKey, array, orderingDirection = 'asc') {\n  const predicate = orderingDirection === 'asc' ? index => compare(searchKey, array[index]) >= 0 : index => -compare(searchKey, array[index]) >= 0;\n  return findLastMatchingIndex(predicate, 0, array.length - 1);\n}\n/*\r\n * Returns:\r\n *   - the last element in the range for which predicate === true or,\r\n *   - value -1 if predicate === false for all elements.\r\n * Assumption: All elements for which predicate === true are before the elements for which predicate === false.\r\n */\nexport function findLastMatchingIndex(predicate, startRange, endRange) {\n  let start = startRange;\n  let end = endRange;\n  while (start < end) {\n    const pivot = Math.ceil((start + end) / 2);\n    if (predicate(pivot)) {\n      start = pivot;\n    } else {\n      end = pivot - 1;\n    }\n  }\n  if (start === end && predicate(start)) {\n    return start;\n  }\n  return NOT_FOUND;\n}\n/*\r\n * numbers < strings < false < true\r\n */\nexport function compare(left, right) {\n  if (typeof left === typeof right) {\n    if (left === EmptyValue) {\n      return 0;\n    }\n    return left < right ? -1 : left > right ? 1 : 0;\n  }\n  if (left === EmptyValue) {\n    return -1;\n  }\n  if (right === EmptyValue) {\n    return 1;\n  }\n  if (right instanceof CellError) {\n    return -1;\n  }\n  if (typeof left === 'number' && typeof right === 'string') {\n    return -1;\n  }\n  if (typeof left === 'number' && typeof right === 'boolean') {\n    return -1;\n  }\n  if (typeof left === 'string' && typeof right === 'number') {\n    return 1;\n  }\n  if (typeof left === 'string' && typeof right === 'boolean') {\n    return -1;\n  }\n  return 1;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}