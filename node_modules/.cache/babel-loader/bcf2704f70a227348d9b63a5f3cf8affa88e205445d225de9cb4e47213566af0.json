{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { checkKeySchema, extractTime } from \"./licenseKeyHelper.mjs\";\n/**\r\n * List of all not valid messages which may occur.\r\n */\nconst consoleMessages = {\n  invalid: () => 'The license key for HyperFormula is invalid.',\n  expired: ({\n    keyValidityDate\n  }) => 'The license key for HyperFormula expired' + ` on ${keyValidityDate}, and is not valid for the installed version.`,\n  missing: () => 'The license key for HyperFormula is missing.'\n};\nlet _notified = false;\n/**\r\n * Checks if the provided license key is grammatically valid or not expired.\r\n *\r\n * @param {string} licenseKey The license key to check.\r\n * @returns {LicenseKeyValidityState} Returns the checking state.\r\n */\nexport function checkLicenseKeyValidity(licenseKey) {\n  const messageDescriptor = {\n    template: \"missing\" /* MISSING */,\n    vars: {}\n  };\n  if (licenseKey === 'gpl-v3' || licenseKey === 'internal-use-in-handsontable') {\n    messageDescriptor.template = \"valid\" /* VALID */;\n  } else if (typeof licenseKey === 'string' && checkKeySchema(licenseKey)) {\n    const [day, month, year] = (\"14/01/2025\" || '').split('/');\n    const releaseDays = Math.floor(new Date(`${month}/${day}/${year}`).getTime() / 8.64e7);\n    const keyValidityDays = extractTime(licenseKey);\n    messageDescriptor.vars.keyValidityDate = formatDate(new Date((keyValidityDays + 1) * 8.64e7));\n    if (releaseDays > keyValidityDays) {\n      messageDescriptor.template = \"expired\" /* EXPIRED */;\n    } else {\n      messageDescriptor.template = \"valid\" /* VALID */;\n    }\n  } else if (licenseKey !== '') {\n    messageDescriptor.template = \"invalid\" /* INVALID */;\n  }\n  if (!_notified && messageDescriptor.template !== \"valid\" /* VALID */) {\n    console.warn(consoleMessages[messageDescriptor.template](messageDescriptor.vars));\n    _notified = true;\n  }\n  return messageDescriptor.template;\n}\n/**\r\n * Formats a Date instance to hard-coded format MMMM DD, YYYY.\r\n *\r\n * @param {Date} date The date to format.\r\n * @returns {string}\r\n */\nfunction formatDate(date) {\n  const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\n  const month = monthNames[date.getMonth()];\n  const day = date.getDate();\n  const year = date.getFullYear();\n  return `${month} ${day}, ${year}`;\n}","map":{"version":3,"names":["checkKeySchema","extractTime","consoleMessages","invalid","expired","keyValidityDate","missing","_notified","checkLicenseKeyValidity","licenseKey","messageDescriptor","template","vars","day","month","year","split","releaseDays","Math","floor","Date","getTime","keyValidityDays","formatDate","console","warn","date","monthNames","getMonth","getDate","getFullYear"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/helpers/licenseKeyValidator.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { checkKeySchema, extractTime } from \"./licenseKeyHelper.mjs\";\n/**\r\n * List of all not valid messages which may occur.\r\n */\nconst consoleMessages = {\n  invalid: () => 'The license key for HyperFormula is invalid.',\n  expired: ({\n    keyValidityDate\n  }) => 'The license key for HyperFormula expired' + ` on ${keyValidityDate}, and is not valid for the installed version.`,\n  missing: () => 'The license key for HyperFormula is missing.'\n};\nlet _notified = false;\n/**\r\n * Checks if the provided license key is grammatically valid or not expired.\r\n *\r\n * @param {string} licenseKey The license key to check.\r\n * @returns {LicenseKeyValidityState} Returns the checking state.\r\n */\nexport function checkLicenseKeyValidity(licenseKey) {\n  const messageDescriptor = {\n    template: \"missing\" /* MISSING */,\n    vars: {}\n  };\n  if (licenseKey === 'gpl-v3' || licenseKey === 'internal-use-in-handsontable') {\n    messageDescriptor.template = \"valid\" /* VALID */;\n  } else if (typeof licenseKey === 'string' && checkKeySchema(licenseKey)) {\n    const [day, month, year] = (\"14/01/2025\" || '').split('/');\n    const releaseDays = Math.floor(new Date(`${month}/${day}/${year}`).getTime() / 8.64e7);\n    const keyValidityDays = extractTime(licenseKey);\n    messageDescriptor.vars.keyValidityDate = formatDate(new Date((keyValidityDays + 1) * 8.64e7));\n    if (releaseDays > keyValidityDays) {\n      messageDescriptor.template = \"expired\" /* EXPIRED */;\n    } else {\n      messageDescriptor.template = \"valid\" /* VALID */;\n    }\n  } else if (licenseKey !== '') {\n    messageDescriptor.template = \"invalid\" /* INVALID */;\n  }\n  if (!_notified && messageDescriptor.template !== \"valid\" /* VALID */) {\n    console.warn(consoleMessages[messageDescriptor.template](messageDescriptor.vars));\n    _notified = true;\n  }\n  return messageDescriptor.template;\n}\n/**\r\n * Formats a Date instance to hard-coded format MMMM DD, YYYY.\r\n *\r\n * @param {Date} date The date to format.\r\n * @returns {string}\r\n */\nfunction formatDate(date) {\n  const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\n  const month = monthNames[date.getMonth()];\n  const day = date.getDate();\n  const year = date.getFullYear();\n  return `${month} ${day}, ${year}`;\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,cAAc,EAAEC,WAAW,QAAQ,wBAAwB;AACpE;AACA;AACA;AACA,MAAMC,eAAe,GAAG;EACtBC,OAAO,EAAEA,CAAA,KAAM,8CAA8C;EAC7DC,OAAO,EAAEA,CAAC;IACRC;EACF,CAAC,KAAK,0CAA0C,GAAG,OAAOA,eAAe,+CAA+C;EACxHC,OAAO,EAAEA,CAAA,KAAM;AACjB,CAAC;AACD,IAAIC,SAAS,GAAG,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,uBAAuBA,CAACC,UAAU,EAAE;EAClD,MAAMC,iBAAiB,GAAG;IACxBC,QAAQ,EAAE,SAAS,CAAC;IACpBC,IAAI,EAAE,CAAC;EACT,CAAC;EACD,IAAIH,UAAU,KAAK,QAAQ,IAAIA,UAAU,KAAK,8BAA8B,EAAE;IAC5EC,iBAAiB,CAACC,QAAQ,GAAG,OAAO,CAAC;EACvC,CAAC,MAAM,IAAI,OAAOF,UAAU,KAAK,QAAQ,IAAIT,cAAc,CAACS,UAAU,CAAC,EAAE;IACvE,MAAM,CAACI,GAAG,EAAEC,KAAK,EAAEC,IAAI,CAAC,GAAG,CAAC,YAAY,IAAI,EAAE,EAAEC,KAAK,CAAC,GAAG,CAAC;IAC1D,MAAMC,WAAW,GAAGC,IAAI,CAACC,KAAK,CAAC,IAAIC,IAAI,CAAC,GAAGN,KAAK,IAAID,GAAG,IAAIE,IAAI,EAAE,CAAC,CAACM,OAAO,CAAC,CAAC,GAAG,MAAM,CAAC;IACtF,MAAMC,eAAe,GAAGrB,WAAW,CAACQ,UAAU,CAAC;IAC/CC,iBAAiB,CAACE,IAAI,CAACP,eAAe,GAAGkB,UAAU,CAAC,IAAIH,IAAI,CAAC,CAACE,eAAe,GAAG,CAAC,IAAI,MAAM,CAAC,CAAC;IAC7F,IAAIL,WAAW,GAAGK,eAAe,EAAE;MACjCZ,iBAAiB,CAACC,QAAQ,GAAG,SAAS,CAAC;IACzC,CAAC,MAAM;MACLD,iBAAiB,CAACC,QAAQ,GAAG,OAAO,CAAC;IACvC;EACF,CAAC,MAAM,IAAIF,UAAU,KAAK,EAAE,EAAE;IAC5BC,iBAAiB,CAACC,QAAQ,GAAG,SAAS,CAAC;EACzC;EACA,IAAI,CAACJ,SAAS,IAAIG,iBAAiB,CAACC,QAAQ,KAAK,OAAO,CAAC,aAAa;IACpEa,OAAO,CAACC,IAAI,CAACvB,eAAe,CAACQ,iBAAiB,CAACC,QAAQ,CAAC,CAACD,iBAAiB,CAACE,IAAI,CAAC,CAAC;IACjFL,SAAS,GAAG,IAAI;EAClB;EACA,OAAOG,iBAAiB,CAACC,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASY,UAAUA,CAACG,IAAI,EAAE;EACxB,MAAMC,UAAU,GAAG,CAAC,SAAS,EAAE,UAAU,EAAE,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,WAAW,EAAE,SAAS,EAAE,UAAU,EAAE,UAAU,CAAC;EAC7I,MAAMb,KAAK,GAAGa,UAAU,CAACD,IAAI,CAACE,QAAQ,CAAC,CAAC,CAAC;EACzC,MAAMf,GAAG,GAAGa,IAAI,CAACG,OAAO,CAAC,CAAC;EAC1B,MAAMd,IAAI,GAAGW,IAAI,CAACI,WAAW,CAAC,CAAC;EAC/B,OAAO,GAAGhB,KAAK,IAAID,GAAG,KAAKE,IAAI,EAAE;AACnC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}