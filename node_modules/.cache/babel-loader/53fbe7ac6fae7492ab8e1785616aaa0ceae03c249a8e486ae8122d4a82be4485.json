{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { simpleCellAddress } from \"../Cell.mjs\";\nimport { CellAddress } from \"../parser/index.mjs\";\nimport { RowAddress } from \"../parser/RowAddress.mjs\";\nimport { Transformer } from \"./Transformer.mjs\";\nexport class MoveCellsTransformer extends Transformer {\n  constructor(sourceRange, toRight, toBottom, toSheet) {\n    super();\n    this.sourceRange = sourceRange;\n    this.toRight = toRight;\n    this.toBottom = toBottom;\n    this.toSheet = toSheet;\n    this.dependentFormulaTransformer = new DependentFormulaTransformer(sourceRange, toRight, toBottom, toSheet);\n  }\n  get sheet() {\n    return this.sourceRange.sheet;\n  }\n  isIrreversible() {\n    return true;\n  }\n  transformSingleAst(ast, address) {\n    if (this.sourceRange.addressInRange(address)) {\n      const newAst = this.transformAst(ast, address);\n      return [newAst, this.fixNodeAddress(address)];\n    } else {\n      return this.dependentFormulaTransformer.transformSingleAst(ast, address);\n    }\n  }\n  fixNodeAddress(address) {\n    return simpleCellAddress(this.toSheet, address.col + this.toRight, address.row + this.toBottom);\n  }\n  transformCellAddress(dependencyAddress, formulaAddress) {\n    return this.transformAddress(dependencyAddress, formulaAddress);\n  }\n  transformCellRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformColumnRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformRowRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformAddress(dependencyAddress, formulaAddress) {\n    const sourceRange = this.sourceRange;\n    if (dependencyAddress instanceof CellAddress) {\n      const absoluteDependencyAddress = dependencyAddress.toSimpleCellAddress(formulaAddress);\n      if (sourceRange.addressInRange(absoluteDependencyAddress)) {\n        // If dependency is internal, move only absolute dimensions\n        return dependencyAddress.shiftAbsoluteDimensions(this.toRight, this.toBottom);\n      }\n    }\n    return dependencyAddress.shiftRelativeDimensions(-this.toRight, -this.toBottom);\n  }\n  transformRange(start, end, formulaAddress) {\n    const sourceRange = this.sourceRange;\n    if (start instanceof CellAddress && end instanceof CellAddress) {\n      const absoluteStart = start.toSimpleCellAddress(formulaAddress);\n      const absoluteEnd = end.toSimpleCellAddress(formulaAddress);\n      if (sourceRange.addressInRange(absoluteStart) && sourceRange.addressInRange(absoluteEnd)) {\n        return [start.shiftAbsoluteDimensions(this.toRight, this.toBottom), end.shiftAbsoluteDimensions(this.toRight, this.toBottom)];\n      }\n    }\n    return [start.shiftRelativeDimensions(-this.toRight, -this.toBottom), end.shiftRelativeDimensions(-this.toRight, -this.toBottom)];\n  }\n}\nexport class DependentFormulaTransformer extends Transformer {\n  constructor(sourceRange, toRight, toBottom, toSheet) {\n    super();\n    this.sourceRange = sourceRange;\n    this.toRight = toRight;\n    this.toBottom = toBottom;\n    this.toSheet = toSheet;\n  }\n  get sheet() {\n    return this.sourceRange.sheet;\n  }\n  isIrreversible() {\n    return true;\n  }\n  fixNodeAddress(address) {\n    return address;\n  }\n  transformCellAddress(dependencyAddress, formulaAddress) {\n    if (this.shouldMove(dependencyAddress, formulaAddress)) {\n      return dependencyAddress.moved(this.toSheet, this.toRight, this.toBottom);\n    }\n    return false;\n  }\n  transformCellRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformColumnRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformRowRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  shouldMove(dependencyAddress, formulaAddress) {\n    if (dependencyAddress instanceof CellAddress) {\n      return this.sourceRange.addressInRange(dependencyAddress.toSimpleCellAddress(formulaAddress));\n    } else if (dependencyAddress instanceof RowAddress) {\n      return this.sourceRange.rowInRange(dependencyAddress.toSimpleRowAddress(formulaAddress)) && !this.sourceRange.isFinite();\n    } else {\n      return this.sourceRange.columnInRange(dependencyAddress.toSimpleColumnAddress(formulaAddress)) && !this.sourceRange.isFinite();\n    }\n  }\n  transformRange(start, end, formulaAddress) {\n    const newStart = this.transformCellAddress(start, formulaAddress);\n    const newEnd = this.transformCellAddress(end, formulaAddress);\n    if (newStart && newEnd) {\n      return [newStart, newEnd];\n    }\n    return false;\n  }\n}","map":{"version":3,"names":["simpleCellAddress","CellAddress","RowAddress","Transformer","MoveCellsTransformer","constructor","sourceRange","toRight","toBottom","toSheet","dependentFormulaTransformer","DependentFormulaTransformer","sheet","isIrreversible","transformSingleAst","ast","address","addressInRange","newAst","transformAst","fixNodeAddress","col","row","transformCellAddress","dependencyAddress","formulaAddress","transformAddress","transformCellRange","start","end","transformRange","transformColumnRange","transformRowRange","absoluteDependencyAddress","toSimpleCellAddress","shiftAbsoluteDimensions","shiftRelativeDimensions","absoluteStart","absoluteEnd","shouldMove","moved","rowInRange","toSimpleRowAddress","isFinite","columnInRange","toSimpleColumnAddress","newStart","newEnd"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/dependencyTransformers/MoveCellsTransformer.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { simpleCellAddress } from \"../Cell.mjs\";\nimport { CellAddress } from \"../parser/index.mjs\";\nimport { RowAddress } from \"../parser/RowAddress.mjs\";\nimport { Transformer } from \"./Transformer.mjs\";\nexport class MoveCellsTransformer extends Transformer {\n  constructor(sourceRange, toRight, toBottom, toSheet) {\n    super();\n    this.sourceRange = sourceRange;\n    this.toRight = toRight;\n    this.toBottom = toBottom;\n    this.toSheet = toSheet;\n    this.dependentFormulaTransformer = new DependentFormulaTransformer(sourceRange, toRight, toBottom, toSheet);\n  }\n  get sheet() {\n    return this.sourceRange.sheet;\n  }\n  isIrreversible() {\n    return true;\n  }\n  transformSingleAst(ast, address) {\n    if (this.sourceRange.addressInRange(address)) {\n      const newAst = this.transformAst(ast, address);\n      return [newAst, this.fixNodeAddress(address)];\n    } else {\n      return this.dependentFormulaTransformer.transformSingleAst(ast, address);\n    }\n  }\n  fixNodeAddress(address) {\n    return simpleCellAddress(this.toSheet, address.col + this.toRight, address.row + this.toBottom);\n  }\n  transformCellAddress(dependencyAddress, formulaAddress) {\n    return this.transformAddress(dependencyAddress, formulaAddress);\n  }\n  transformCellRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformColumnRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformRowRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformAddress(dependencyAddress, formulaAddress) {\n    const sourceRange = this.sourceRange;\n    if (dependencyAddress instanceof CellAddress) {\n      const absoluteDependencyAddress = dependencyAddress.toSimpleCellAddress(formulaAddress);\n      if (sourceRange.addressInRange(absoluteDependencyAddress)) {\n        // If dependency is internal, move only absolute dimensions\n        return dependencyAddress.shiftAbsoluteDimensions(this.toRight, this.toBottom);\n      }\n    }\n    return dependencyAddress.shiftRelativeDimensions(-this.toRight, -this.toBottom);\n  }\n  transformRange(start, end, formulaAddress) {\n    const sourceRange = this.sourceRange;\n    if (start instanceof CellAddress && end instanceof CellAddress) {\n      const absoluteStart = start.toSimpleCellAddress(formulaAddress);\n      const absoluteEnd = end.toSimpleCellAddress(formulaAddress);\n      if (sourceRange.addressInRange(absoluteStart) && sourceRange.addressInRange(absoluteEnd)) {\n        return [start.shiftAbsoluteDimensions(this.toRight, this.toBottom), end.shiftAbsoluteDimensions(this.toRight, this.toBottom)];\n      }\n    }\n    return [start.shiftRelativeDimensions(-this.toRight, -this.toBottom), end.shiftRelativeDimensions(-this.toRight, -this.toBottom)];\n  }\n}\nexport class DependentFormulaTransformer extends Transformer {\n  constructor(sourceRange, toRight, toBottom, toSheet) {\n    super();\n    this.sourceRange = sourceRange;\n    this.toRight = toRight;\n    this.toBottom = toBottom;\n    this.toSheet = toSheet;\n  }\n  get sheet() {\n    return this.sourceRange.sheet;\n  }\n  isIrreversible() {\n    return true;\n  }\n  fixNodeAddress(address) {\n    return address;\n  }\n  transformCellAddress(dependencyAddress, formulaAddress) {\n    if (this.shouldMove(dependencyAddress, formulaAddress)) {\n      return dependencyAddress.moved(this.toSheet, this.toRight, this.toBottom);\n    }\n    return false;\n  }\n  transformCellRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformColumnRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformRowRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  shouldMove(dependencyAddress, formulaAddress) {\n    if (dependencyAddress instanceof CellAddress) {\n      return this.sourceRange.addressInRange(dependencyAddress.toSimpleCellAddress(formulaAddress));\n    } else if (dependencyAddress instanceof RowAddress) {\n      return this.sourceRange.rowInRange(dependencyAddress.toSimpleRowAddress(formulaAddress)) && !this.sourceRange.isFinite();\n    } else {\n      return this.sourceRange.columnInRange(dependencyAddress.toSimpleColumnAddress(formulaAddress)) && !this.sourceRange.isFinite();\n    }\n  }\n  transformRange(start, end, formulaAddress) {\n    const newStart = this.transformCellAddress(start, formulaAddress);\n    const newEnd = this.transformCellAddress(end, formulaAddress);\n    if (newStart && newEnd) {\n      return [newStart, newEnd];\n    }\n    return false;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}