{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { getRawValue } from \"../interpreter/InterpreterValue.mjs\";\nimport { forceNormalizeString } from \"../interpreter/ArithmeticHelper.mjs\";\nimport { compare, findLastOccurrenceInOrderedRange } from \"../interpreter/binarySearch.mjs\";\nconst NOT_FOUND = -1;\nexport class AdvancedFind {\n  constructor(dependencyGraph) {\n    this.dependencyGraph = dependencyGraph;\n  }\n  advancedFind(keyMatcher, rangeValue, {\n    returnOccurrence\n  } = {\n    returnOccurrence: 'first'\n  }) {\n    const range = rangeValue.range;\n    const values = range === undefined ? rangeValue.valuesFromTopLeftCorner() : this.dependencyGraph.computeListOfValuesInRange(range);\n    const initialIterationIndex = returnOccurrence === 'first' ? 0 : values.length - 1;\n    const iterationCondition = returnOccurrence === 'first' ? i => i < values.length : i => i >= 0;\n    const incrementIndex = returnOccurrence === 'first' ? i => i + 1 : i => i - 1;\n    for (let i = initialIterationIndex; iterationCondition(i); i = incrementIndex(i)) {\n      if (keyMatcher(getRawValue(values[i]))) {\n        return i;\n      }\n    }\n    return NOT_FOUND;\n  }\n  basicFind(searchKey, rangeValue, searchCoordinate, {\n    ordering,\n    ifNoMatch,\n    returnOccurrence\n  }) {\n    const normalizedSearchKey = typeof searchKey === 'string' ? forceNormalizeString(searchKey) : searchKey;\n    const range = rangeValue.range;\n    if (range === undefined) {\n      return this.findNormalizedValue(normalizedSearchKey, rangeValue.valuesFromTopLeftCorner(), ifNoMatch, returnOccurrence);\n    }\n    if (ordering === 'none') {\n      return this.findNormalizedValue(normalizedSearchKey, this.dependencyGraph.computeListOfValuesInRange(range), ifNoMatch, returnOccurrence);\n    }\n    return findLastOccurrenceInOrderedRange(normalizedSearchKey, range, {\n      searchCoordinate,\n      orderingDirection: ordering,\n      ifNoMatch\n    }, this.dependencyGraph);\n  }\n  findNormalizedValue(searchKey, searchArray, ifNoMatch = 'returnNotFound', returnOccurrence = 'first') {\n    const normalizedArray = searchArray.map(getRawValue).map(val => typeof val === 'string' ? forceNormalizeString(val) : val);\n    if (ifNoMatch === 'returnNotFound') {\n      return returnOccurrence === 'first' ? normalizedArray.indexOf(searchKey) : normalizedArray.lastIndexOf(searchKey);\n    }\n    const compareFn = ifNoMatch === 'returnLowerBound' ? (left, right) => compare(left, right) : (left, right) => -compare(left, right);\n    let bestValue = ifNoMatch === 'returnLowerBound' ? -Infinity : Infinity;\n    let bestIndex = NOT_FOUND;\n    const initialIterationIndex = returnOccurrence === 'first' ? 0 : normalizedArray.length - 1;\n    const iterationCondition = returnOccurrence === 'first' ? i => i < normalizedArray.length : i => i >= 0;\n    const incrementIndex = returnOccurrence === 'first' ? i => i + 1 : i => i - 1;\n    for (let i = initialIterationIndex; iterationCondition(i); i = incrementIndex(i)) {\n      const value = normalizedArray[i];\n      if (value === searchKey) {\n        return i;\n      }\n      if (compareFn(value, searchKey) > 0) {\n        continue;\n      }\n      if (compareFn(bestValue, value) < 0) {\n        bestValue = value;\n        bestIndex = i;\n      }\n    }\n    return bestIndex;\n  }\n}","map":{"version":3,"names":["getRawValue","forceNormalizeString","compare","findLastOccurrenceInOrderedRange","NOT_FOUND","AdvancedFind","constructor","dependencyGraph","advancedFind","keyMatcher","rangeValue","returnOccurrence","range","values","undefined","valuesFromTopLeftCorner","computeListOfValuesInRange","initialIterationIndex","length","iterationCondition","i","incrementIndex","basicFind","searchKey","searchCoordinate","ordering","ifNoMatch","normalizedSearchKey","findNormalizedValue","orderingDirection","searchArray","normalizedArray","map","val","indexOf","lastIndexOf","compareFn","left","right","bestValue","Infinity","bestIndex","value"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/Lookup/AdvancedFind.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { getRawValue } from \"../interpreter/InterpreterValue.mjs\";\nimport { forceNormalizeString } from \"../interpreter/ArithmeticHelper.mjs\";\nimport { compare, findLastOccurrenceInOrderedRange } from \"../interpreter/binarySearch.mjs\";\nconst NOT_FOUND = -1;\nexport class AdvancedFind {\n  constructor(dependencyGraph) {\n    this.dependencyGraph = dependencyGraph;\n  }\n  advancedFind(keyMatcher, rangeValue, {\n    returnOccurrence\n  } = {\n    returnOccurrence: 'first'\n  }) {\n    const range = rangeValue.range;\n    const values = range === undefined ? rangeValue.valuesFromTopLeftCorner() : this.dependencyGraph.computeListOfValuesInRange(range);\n    const initialIterationIndex = returnOccurrence === 'first' ? 0 : values.length - 1;\n    const iterationCondition = returnOccurrence === 'first' ? i => i < values.length : i => i >= 0;\n    const incrementIndex = returnOccurrence === 'first' ? i => i + 1 : i => i - 1;\n    for (let i = initialIterationIndex; iterationCondition(i); i = incrementIndex(i)) {\n      if (keyMatcher(getRawValue(values[i]))) {\n        return i;\n      }\n    }\n    return NOT_FOUND;\n  }\n  basicFind(searchKey, rangeValue, searchCoordinate, {\n    ordering,\n    ifNoMatch,\n    returnOccurrence\n  }) {\n    const normalizedSearchKey = typeof searchKey === 'string' ? forceNormalizeString(searchKey) : searchKey;\n    const range = rangeValue.range;\n    if (range === undefined) {\n      return this.findNormalizedValue(normalizedSearchKey, rangeValue.valuesFromTopLeftCorner(), ifNoMatch, returnOccurrence);\n    }\n    if (ordering === 'none') {\n      return this.findNormalizedValue(normalizedSearchKey, this.dependencyGraph.computeListOfValuesInRange(range), ifNoMatch, returnOccurrence);\n    }\n    return findLastOccurrenceInOrderedRange(normalizedSearchKey, range, {\n      searchCoordinate,\n      orderingDirection: ordering,\n      ifNoMatch\n    }, this.dependencyGraph);\n  }\n  findNormalizedValue(searchKey, searchArray, ifNoMatch = 'returnNotFound', returnOccurrence = 'first') {\n    const normalizedArray = searchArray.map(getRawValue).map(val => typeof val === 'string' ? forceNormalizeString(val) : val);\n    if (ifNoMatch === 'returnNotFound') {\n      return returnOccurrence === 'first' ? normalizedArray.indexOf(searchKey) : normalizedArray.lastIndexOf(searchKey);\n    }\n    const compareFn = ifNoMatch === 'returnLowerBound' ? (left, right) => compare(left, right) : (left, right) => -compare(left, right);\n    let bestValue = ifNoMatch === 'returnLowerBound' ? -Infinity : Infinity;\n    let bestIndex = NOT_FOUND;\n    const initialIterationIndex = returnOccurrence === 'first' ? 0 : normalizedArray.length - 1;\n    const iterationCondition = returnOccurrence === 'first' ? i => i < normalizedArray.length : i => i >= 0;\n    const incrementIndex = returnOccurrence === 'first' ? i => i + 1 : i => i - 1;\n    for (let i = initialIterationIndex; iterationCondition(i); i = incrementIndex(i)) {\n      const value = normalizedArray[i];\n      if (value === searchKey) {\n        return i;\n      }\n      if (compareFn(value, searchKey) > 0) {\n        continue;\n      }\n      if (compareFn(bestValue, value) < 0) {\n        bestValue = value;\n        bestIndex = i;\n      }\n    }\n    return bestIndex;\n  }\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,WAAW,QAAQ,qCAAqC;AACjE,SAASC,oBAAoB,QAAQ,qCAAqC;AAC1E,SAASC,OAAO,EAAEC,gCAAgC,QAAQ,iCAAiC;AAC3F,MAAMC,SAAS,GAAG,CAAC,CAAC;AACpB,OAAO,MAAMC,YAAY,CAAC;EACxBC,WAAWA,CAACC,eAAe,EAAE;IAC3B,IAAI,CAACA,eAAe,GAAGA,eAAe;EACxC;EACAC,YAAYA,CAACC,UAAU,EAAEC,UAAU,EAAE;IACnCC;EACF,CAAC,GAAG;IACFA,gBAAgB,EAAE;EACpB,CAAC,EAAE;IACD,MAAMC,KAAK,GAAGF,UAAU,CAACE,KAAK;IAC9B,MAAMC,MAAM,GAAGD,KAAK,KAAKE,SAAS,GAAGJ,UAAU,CAACK,uBAAuB,CAAC,CAAC,GAAG,IAAI,CAACR,eAAe,CAACS,0BAA0B,CAACJ,KAAK,CAAC;IAClI,MAAMK,qBAAqB,GAAGN,gBAAgB,KAAK,OAAO,GAAG,CAAC,GAAGE,MAAM,CAACK,MAAM,GAAG,CAAC;IAClF,MAAMC,kBAAkB,GAAGR,gBAAgB,KAAK,OAAO,GAAGS,CAAC,IAAIA,CAAC,GAAGP,MAAM,CAACK,MAAM,GAAGE,CAAC,IAAIA,CAAC,IAAI,CAAC;IAC9F,MAAMC,cAAc,GAAGV,gBAAgB,KAAK,OAAO,GAAGS,CAAC,IAAIA,CAAC,GAAG,CAAC,GAAGA,CAAC,IAAIA,CAAC,GAAG,CAAC;IAC7E,KAAK,IAAIA,CAAC,GAAGH,qBAAqB,EAAEE,kBAAkB,CAACC,CAAC,CAAC,EAAEA,CAAC,GAAGC,cAAc,CAACD,CAAC,CAAC,EAAE;MAChF,IAAIX,UAAU,CAACT,WAAW,CAACa,MAAM,CAACO,CAAC,CAAC,CAAC,CAAC,EAAE;QACtC,OAAOA,CAAC;MACV;IACF;IACA,OAAOhB,SAAS;EAClB;EACAkB,SAASA,CAACC,SAAS,EAAEb,UAAU,EAAEc,gBAAgB,EAAE;IACjDC,QAAQ;IACRC,SAAS;IACTf;EACF,CAAC,EAAE;IACD,MAAMgB,mBAAmB,GAAG,OAAOJ,SAAS,KAAK,QAAQ,GAAGtB,oBAAoB,CAACsB,SAAS,CAAC,GAAGA,SAAS;IACvG,MAAMX,KAAK,GAAGF,UAAU,CAACE,KAAK;IAC9B,IAAIA,KAAK,KAAKE,SAAS,EAAE;MACvB,OAAO,IAAI,CAACc,mBAAmB,CAACD,mBAAmB,EAAEjB,UAAU,CAACK,uBAAuB,CAAC,CAAC,EAAEW,SAAS,EAAEf,gBAAgB,CAAC;IACzH;IACA,IAAIc,QAAQ,KAAK,MAAM,EAAE;MACvB,OAAO,IAAI,CAACG,mBAAmB,CAACD,mBAAmB,EAAE,IAAI,CAACpB,eAAe,CAACS,0BAA0B,CAACJ,KAAK,CAAC,EAAEc,SAAS,EAAEf,gBAAgB,CAAC;IAC3I;IACA,OAAOR,gCAAgC,CAACwB,mBAAmB,EAAEf,KAAK,EAAE;MAClEY,gBAAgB;MAChBK,iBAAiB,EAAEJ,QAAQ;MAC3BC;IACF,CAAC,EAAE,IAAI,CAACnB,eAAe,CAAC;EAC1B;EACAqB,mBAAmBA,CAACL,SAAS,EAAEO,WAAW,EAAEJ,SAAS,GAAG,gBAAgB,EAAEf,gBAAgB,GAAG,OAAO,EAAE;IACpG,MAAMoB,eAAe,GAAGD,WAAW,CAACE,GAAG,CAAChC,WAAW,CAAC,CAACgC,GAAG,CAACC,GAAG,IAAI,OAAOA,GAAG,KAAK,QAAQ,GAAGhC,oBAAoB,CAACgC,GAAG,CAAC,GAAGA,GAAG,CAAC;IAC1H,IAAIP,SAAS,KAAK,gBAAgB,EAAE;MAClC,OAAOf,gBAAgB,KAAK,OAAO,GAAGoB,eAAe,CAACG,OAAO,CAACX,SAAS,CAAC,GAAGQ,eAAe,CAACI,WAAW,CAACZ,SAAS,CAAC;IACnH;IACA,MAAMa,SAAS,GAAGV,SAAS,KAAK,kBAAkB,GAAG,CAACW,IAAI,EAAEC,KAAK,KAAKpC,OAAO,CAACmC,IAAI,EAAEC,KAAK,CAAC,GAAG,CAACD,IAAI,EAAEC,KAAK,KAAK,CAACpC,OAAO,CAACmC,IAAI,EAAEC,KAAK,CAAC;IACnI,IAAIC,SAAS,GAAGb,SAAS,KAAK,kBAAkB,GAAG,CAACc,QAAQ,GAAGA,QAAQ;IACvE,IAAIC,SAAS,GAAGrC,SAAS;IACzB,MAAMa,qBAAqB,GAAGN,gBAAgB,KAAK,OAAO,GAAG,CAAC,GAAGoB,eAAe,CAACb,MAAM,GAAG,CAAC;IAC3F,MAAMC,kBAAkB,GAAGR,gBAAgB,KAAK,OAAO,GAAGS,CAAC,IAAIA,CAAC,GAAGW,eAAe,CAACb,MAAM,GAAGE,CAAC,IAAIA,CAAC,IAAI,CAAC;IACvG,MAAMC,cAAc,GAAGV,gBAAgB,KAAK,OAAO,GAAGS,CAAC,IAAIA,CAAC,GAAG,CAAC,GAAGA,CAAC,IAAIA,CAAC,GAAG,CAAC;IAC7E,KAAK,IAAIA,CAAC,GAAGH,qBAAqB,EAAEE,kBAAkB,CAACC,CAAC,CAAC,EAAEA,CAAC,GAAGC,cAAc,CAACD,CAAC,CAAC,EAAE;MAChF,MAAMsB,KAAK,GAAGX,eAAe,CAACX,CAAC,CAAC;MAChC,IAAIsB,KAAK,KAAKnB,SAAS,EAAE;QACvB,OAAOH,CAAC;MACV;MACA,IAAIgB,SAAS,CAACM,KAAK,EAAEnB,SAAS,CAAC,GAAG,CAAC,EAAE;QACnC;MACF;MACA,IAAIa,SAAS,CAACG,SAAS,EAAEG,KAAK,CAAC,GAAG,CAAC,EAAE;QACnCH,SAAS,GAAGG,KAAK;QACjBD,SAAS,GAAGrB,CAAC;MACf;IACF;IACA,OAAOqB,SAAS;EAClB;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}