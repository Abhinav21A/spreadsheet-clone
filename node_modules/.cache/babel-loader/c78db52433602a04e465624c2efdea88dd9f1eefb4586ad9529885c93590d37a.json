{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { simpleCellAddress } from \"../../Cell.mjs\";\n/**\r\n * Mapping from cell addresses to vertices\r\n *\r\n * Uses Array to store addresses, having minimal memory usage for dense sheets and constant set/lookup.\r\n */\nexport class DenseStrategy {\n  /**\r\n   * @param width - width of the stored sheet\r\n   * @param height - height of the stored sheet\r\n   */\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n    this.mapping = new Array(height);\n    for (let i = 0; i < height; i++) {\n      this.mapping[i] = new Array(width);\n    }\n  }\n  /** @inheritDoc */\n  getCell(address) {\n    return this.getCellVertex(address.col, address.row);\n  }\n  /** @inheritDoc */\n  setCell(address, newVertex) {\n    this.width = Math.max(this.width, address.col + 1);\n    this.height = Math.max(this.height, address.row + 1);\n    const rowMapping = this.mapping[address.row];\n    if (!rowMapping) {\n      this.mapping[address.row] = new Array(this.width);\n    }\n    this.mapping[address.row][address.col] = newVertex;\n  }\n  /** @inheritDoc */\n  has(address) {\n    const row = this.mapping[address.row];\n    if (!row) {\n      return false;\n    }\n    return !!row[address.col];\n  }\n  /** @inheritDoc */\n  getHeight() {\n    return this.height;\n  }\n  /** @inheritDoc */\n  getWidth() {\n    return this.width;\n  }\n  removeCell(address) {\n    if (this.mapping[address.row] !== undefined) {\n      delete this.mapping[address.row][address.col];\n    }\n  }\n  addRows(row, numberOfRows) {\n    const newRows = [];\n    for (let i = 0; i < numberOfRows; i++) {\n      newRows.push(new Array(this.width));\n    }\n    this.mapping.splice(row, 0, ...newRows);\n    this.height += numberOfRows;\n  }\n  addColumns(column, numberOfColumns) {\n    for (let i = 0; i < this.height; i++) {\n      if (this.mapping[i] !== undefined) {\n        this.mapping[i].splice(column, 0, ...new Array(numberOfColumns));\n      }\n    }\n    this.width += numberOfColumns;\n  }\n  removeRows(removedRows) {\n    this.mapping.splice(removedRows.rowStart, removedRows.numberOfRows);\n    const rightmostRowRemoved = Math.min(this.height - 1, removedRows.rowEnd);\n    const numberOfRowsRemoved = Math.max(0, rightmostRowRemoved - removedRows.rowStart + 1);\n    this.height = Math.max(0, this.height - numberOfRowsRemoved);\n  }\n  removeColumns(removedColumns) {\n    for (let i = 0; i < this.height; i++) {\n      if (this.mapping[i] !== undefined) {\n        this.mapping[i].splice(removedColumns.columnStart, removedColumns.numberOfColumns);\n      }\n    }\n    const rightmostColumnRemoved = Math.min(this.width - 1, removedColumns.columnEnd);\n    const numberOfColumnsRemoved = Math.max(0, rightmostColumnRemoved - removedColumns.columnStart + 1);\n    this.width = Math.max(0, this.width - numberOfColumnsRemoved);\n  }\n  *getEntries(sheet) {\n    for (let y = 0; y < this.height; ++y) {\n      for (let x = 0; x < this.width; ++x) {\n        const vertex = this.getCellVertex(x, y);\n        if (vertex) {\n          yield [simpleCellAddress(sheet, x, y), vertex];\n        }\n      }\n    }\n  }\n  *verticesFromColumn(column) {\n    for (let y = 0; y < this.height; ++y) {\n      const vertex = this.getCellVertex(column, y);\n      if (vertex) {\n        yield vertex;\n      }\n    }\n  }\n  *verticesFromRow(row) {\n    for (let x = 0; x < this.width; ++x) {\n      const vertex = this.getCellVertex(x, row);\n      if (vertex) {\n        yield vertex;\n      }\n    }\n  }\n  *verticesFromColumnsSpan(columnsSpan) {\n    for (let x = columnsSpan.columnStart; x <= columnsSpan.columnEnd; ++x) {\n      for (let y = 0; y < this.height; ++y) {\n        const vertex = this.getCellVertex(x, y);\n        if (vertex) {\n          yield vertex;\n        }\n      }\n    }\n  }\n  *verticesFromRowsSpan(rowsSpan) {\n    for (let x = 0; x < this.width; ++x) {\n      for (let y = rowsSpan.rowStart; y <= rowsSpan.rowEnd; ++y) {\n        const vertex = this.getCellVertex(x, y);\n        if (vertex) {\n          yield vertex;\n        }\n      }\n    }\n  }\n  *entriesFromRowsSpan(rowsSpan) {\n    for (let x = 0; x < this.width; ++x) {\n      for (let y = rowsSpan.rowStart; y <= rowsSpan.rowEnd; ++y) {\n        const vertex = this.getCellVertex(x, y);\n        if (vertex) {\n          yield [simpleCellAddress(rowsSpan.sheet, x, y), vertex];\n        }\n      }\n    }\n  }\n  *entriesFromColumnsSpan(columnsSpan) {\n    for (let x = columnsSpan.columnStart; x <= columnsSpan.columnEnd; ++x) {\n      for (let y = 0; y < this.height; ++y) {\n        const vertex = this.getCellVertex(x, y);\n        if (vertex) {\n          yield [simpleCellAddress(columnsSpan.sheet, x, y), vertex];\n        }\n      }\n    }\n  }\n  *vertices() {\n    for (let y = 0; y < this.height; ++y) {\n      for (let x = 0; x < this.width; ++x) {\n        const vertex = this.getCellVertex(x, y);\n        if (vertex) {\n          yield vertex;\n        }\n      }\n    }\n  }\n  getCellVertex(x, y) {\n    var _a;\n    return (_a = this.mapping[y]) === null || _a === void 0 ? void 0 : _a[x];\n  }\n}","map":{"version":3,"names":["simpleCellAddress","DenseStrategy","constructor","width","height","mapping","Array","i","getCell","address","getCellVertex","col","row","setCell","newVertex","Math","max","rowMapping","has","getHeight","getWidth","removeCell","undefined","addRows","numberOfRows","newRows","push","splice","addColumns","column","numberOfColumns","removeRows","removedRows","rowStart","rightmostRowRemoved","min","rowEnd","numberOfRowsRemoved","removeColumns","removedColumns","columnStart","rightmostColumnRemoved","columnEnd","numberOfColumnsRemoved","getEntries","sheet","y","x","vertex","verticesFromColumn","verticesFromRow","verticesFromColumnsSpan","columnsSpan","verticesFromRowsSpan","rowsSpan","entriesFromRowsSpan","entriesFromColumnsSpan","vertices","_a"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/DependencyGraph/AddressMapping/DenseStrategy.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { simpleCellAddress } from \"../../Cell.mjs\";\n/**\r\n * Mapping from cell addresses to vertices\r\n *\r\n * Uses Array to store addresses, having minimal memory usage for dense sheets and constant set/lookup.\r\n */\nexport class DenseStrategy {\n  /**\r\n   * @param width - width of the stored sheet\r\n   * @param height - height of the stored sheet\r\n   */\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n    this.mapping = new Array(height);\n    for (let i = 0; i < height; i++) {\n      this.mapping[i] = new Array(width);\n    }\n  }\n  /** @inheritDoc */\n  getCell(address) {\n    return this.getCellVertex(address.col, address.row);\n  }\n  /** @inheritDoc */\n  setCell(address, newVertex) {\n    this.width = Math.max(this.width, address.col + 1);\n    this.height = Math.max(this.height, address.row + 1);\n    const rowMapping = this.mapping[address.row];\n    if (!rowMapping) {\n      this.mapping[address.row] = new Array(this.width);\n    }\n    this.mapping[address.row][address.col] = newVertex;\n  }\n  /** @inheritDoc */\n  has(address) {\n    const row = this.mapping[address.row];\n    if (!row) {\n      return false;\n    }\n    return !!row[address.col];\n  }\n  /** @inheritDoc */\n  getHeight() {\n    return this.height;\n  }\n  /** @inheritDoc */\n  getWidth() {\n    return this.width;\n  }\n  removeCell(address) {\n    if (this.mapping[address.row] !== undefined) {\n      delete this.mapping[address.row][address.col];\n    }\n  }\n  addRows(row, numberOfRows) {\n    const newRows = [];\n    for (let i = 0; i < numberOfRows; i++) {\n      newRows.push(new Array(this.width));\n    }\n    this.mapping.splice(row, 0, ...newRows);\n    this.height += numberOfRows;\n  }\n  addColumns(column, numberOfColumns) {\n    for (let i = 0; i < this.height; i++) {\n      if (this.mapping[i] !== undefined) {\n        this.mapping[i].splice(column, 0, ...new Array(numberOfColumns));\n      }\n    }\n    this.width += numberOfColumns;\n  }\n  removeRows(removedRows) {\n    this.mapping.splice(removedRows.rowStart, removedRows.numberOfRows);\n    const rightmostRowRemoved = Math.min(this.height - 1, removedRows.rowEnd);\n    const numberOfRowsRemoved = Math.max(0, rightmostRowRemoved - removedRows.rowStart + 1);\n    this.height = Math.max(0, this.height - numberOfRowsRemoved);\n  }\n  removeColumns(removedColumns) {\n    for (let i = 0; i < this.height; i++) {\n      if (this.mapping[i] !== undefined) {\n        this.mapping[i].splice(removedColumns.columnStart, removedColumns.numberOfColumns);\n      }\n    }\n    const rightmostColumnRemoved = Math.min(this.width - 1, removedColumns.columnEnd);\n    const numberOfColumnsRemoved = Math.max(0, rightmostColumnRemoved - removedColumns.columnStart + 1);\n    this.width = Math.max(0, this.width - numberOfColumnsRemoved);\n  }\n  *getEntries(sheet) {\n    for (let y = 0; y < this.height; ++y) {\n      for (let x = 0; x < this.width; ++x) {\n        const vertex = this.getCellVertex(x, y);\n        if (vertex) {\n          yield [simpleCellAddress(sheet, x, y), vertex];\n        }\n      }\n    }\n  }\n  *verticesFromColumn(column) {\n    for (let y = 0; y < this.height; ++y) {\n      const vertex = this.getCellVertex(column, y);\n      if (vertex) {\n        yield vertex;\n      }\n    }\n  }\n  *verticesFromRow(row) {\n    for (let x = 0; x < this.width; ++x) {\n      const vertex = this.getCellVertex(x, row);\n      if (vertex) {\n        yield vertex;\n      }\n    }\n  }\n  *verticesFromColumnsSpan(columnsSpan) {\n    for (let x = columnsSpan.columnStart; x <= columnsSpan.columnEnd; ++x) {\n      for (let y = 0; y < this.height; ++y) {\n        const vertex = this.getCellVertex(x, y);\n        if (vertex) {\n          yield vertex;\n        }\n      }\n    }\n  }\n  *verticesFromRowsSpan(rowsSpan) {\n    for (let x = 0; x < this.width; ++x) {\n      for (let y = rowsSpan.rowStart; y <= rowsSpan.rowEnd; ++y) {\n        const vertex = this.getCellVertex(x, y);\n        if (vertex) {\n          yield vertex;\n        }\n      }\n    }\n  }\n  *entriesFromRowsSpan(rowsSpan) {\n    for (let x = 0; x < this.width; ++x) {\n      for (let y = rowsSpan.rowStart; y <= rowsSpan.rowEnd; ++y) {\n        const vertex = this.getCellVertex(x, y);\n        if (vertex) {\n          yield [simpleCellAddress(rowsSpan.sheet, x, y), vertex];\n        }\n      }\n    }\n  }\n  *entriesFromColumnsSpan(columnsSpan) {\n    for (let x = columnsSpan.columnStart; x <= columnsSpan.columnEnd; ++x) {\n      for (let y = 0; y < this.height; ++y) {\n        const vertex = this.getCellVertex(x, y);\n        if (vertex) {\n          yield [simpleCellAddress(columnsSpan.sheet, x, y), vertex];\n        }\n      }\n    }\n  }\n  *vertices() {\n    for (let y = 0; y < this.height; ++y) {\n      for (let x = 0; x < this.width; ++x) {\n        const vertex = this.getCellVertex(x, y);\n        if (vertex) {\n          yield vertex;\n        }\n      }\n    }\n  }\n  getCellVertex(x, y) {\n    var _a;\n    return (_a = this.mapping[y]) === null || _a === void 0 ? void 0 : _a[x];\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}