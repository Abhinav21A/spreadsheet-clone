{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange, simpleCellRange } from \"../AbsoluteCellRange.mjs\";\nimport { absolutizeDependencies } from \"../absolutizeDependencies.mjs\";\nimport { CellError, ErrorType, isSimpleCellAddress, simpleCellAddress } from \"../Cell.mjs\";\nimport { ContentChanges } from \"../ContentChanges.mjs\";\nimport { ErrorMessage } from \"../error-message.mjs\";\nimport { EmptyValue, getRawValue } from \"../interpreter/InterpreterValue.mjs\";\nimport { SimpleRangeValue } from \"../SimpleRangeValue.mjs\";\nimport { collectDependencies, NamedExpressionDependency } from \"../parser/index.mjs\";\nimport { ColumnsSpan, RowsSpan } from \"../Span.mjs\";\nimport { StatType } from \"../statistics/index.mjs\";\nimport { ArrayVertex, EmptyCellVertex, FormulaCellVertex, RangeVertex, ValueCellVertex } from \".//index.mjs\";\nimport { AddressMapping } from \"./AddressMapping/AddressMapping.mjs\";\nimport { ArrayMapping } from \"./ArrayMapping.mjs\";\nimport { collectAddressesDependentToRange } from \"./collectAddressesDependentToRange.mjs\";\nimport { FormulaVertex } from \"./FormulaCellVertex.mjs\";\nimport { Graph } from \"./Graph.mjs\";\nimport { RangeMapping } from \"./RangeMapping.mjs\";\nimport { SheetMapping } from \"./SheetMapping.mjs\";\nexport class DependencyGraph {\n  constructor(addressMapping, rangeMapping, sheetMapping, arrayMapping, stats, lazilyTransformingAstService, functionRegistry, namedExpressions) {\n    this.addressMapping = addressMapping;\n    this.rangeMapping = rangeMapping;\n    this.sheetMapping = sheetMapping;\n    this.arrayMapping = arrayMapping;\n    this.stats = stats;\n    this.lazilyTransformingAstService = lazilyTransformingAstService;\n    this.functionRegistry = functionRegistry;\n    this.namedExpressions = namedExpressions;\n    this.changes = ContentChanges.empty();\n    this.dependencyQueryAddresses = vertex => {\n      if (vertex instanceof RangeVertex) {\n        return this.rangeDependencyQuery(vertex).map(([address, _]) => address);\n      } else {\n        const dependenciesResult = this.formulaDependencyQuery(vertex);\n        if (dependenciesResult !== undefined) {\n          const [address, dependencies] = dependenciesResult;\n          return dependencies.map(dependency => {\n            if (dependency instanceof NamedExpressionDependency) {\n              return this.namedExpressions.namedExpressionOrPlaceholder(dependency.name, address.sheet).address;\n            } else if (isSimpleCellAddress(dependency)) {\n              return dependency;\n            } else {\n              return simpleCellRange(dependency.start, dependency.end);\n            }\n          });\n        } else {\n          return [];\n        }\n      }\n    };\n    this.dependencyQueryVertices = vertex => {\n      if (vertex instanceof RangeVertex) {\n        return this.rangeDependencyQuery(vertex);\n      } else {\n        const dependenciesResult = this.formulaDependencyQuery(vertex);\n        if (dependenciesResult !== undefined) {\n          const [address, dependencies] = dependenciesResult;\n          return dependencies.map(dependency => {\n            if (dependency instanceof AbsoluteCellRange) {\n              return [dependency.start, this.rangeMapping.fetchRange(dependency.start, dependency.end)];\n            } else if (dependency instanceof NamedExpressionDependency) {\n              const namedExpression = this.namedExpressions.namedExpressionOrPlaceholder(dependency.name, address.sheet);\n              return [namedExpression.address, this.addressMapping.fetchCell(namedExpression.address)];\n            } else {\n              return [dependency, this.addressMapping.fetchCell(dependency)];\n            }\n          });\n        } else {\n          return [];\n        }\n      }\n    };\n    this.rangeDependencyQuery = vertex => {\n      const allDeps = [];\n      const {\n        smallerRangeVertex,\n        restRange\n      } = this.rangeMapping.findSmallerRange(vertex.range); //checking whether this range was splitted by bruteForce or not\n      let range;\n      if (smallerRangeVertex !== undefined && this.graph.adjacentNodes(smallerRangeVertex).has(vertex)) {\n        range = restRange;\n        allDeps.push([new AbsoluteCellRange(smallerRangeVertex.start, smallerRangeVertex.end), smallerRangeVertex]);\n      } else {\n        //did we ever need to use full range\n        range = vertex.range;\n      }\n      for (const address of range.addresses(this)) {\n        const cell = this.addressMapping.getCell(address);\n        if (cell !== undefined) {\n          allDeps.push([address, cell]);\n        }\n      }\n      return allDeps;\n    };\n    this.formulaDependencyQuery = vertex => {\n      let formula;\n      let address;\n      if (vertex instanceof FormulaVertex) {\n        address = vertex.getAddress(this.lazilyTransformingAstService);\n        formula = vertex.getFormula(this.lazilyTransformingAstService);\n      } else {\n        return undefined;\n      }\n      const deps = collectDependencies(formula, this.functionRegistry);\n      return [address, absolutizeDependencies(deps, address)];\n    };\n    this.graph = new Graph(this.dependencyQueryVertices);\n  }\n  /**\r\n   * Invariants:\r\n   * - empty cell has associated EmptyCellVertex if and only if it is a dependency (possibly indirect, through range) to some formula\r\n   */\n  static buildEmpty(lazilyTransformingAstService, config, functionRegistry, namedExpressions, stats) {\n    return new DependencyGraph(new AddressMapping(config.chooseAddressMappingPolicy), new RangeMapping(), new SheetMapping(config.translationPackage), new ArrayMapping(), stats, lazilyTransformingAstService, functionRegistry, namedExpressions);\n  }\n  setFormulaToCell(address, ast, dependencies, size, hasVolatileFunction, hasStructuralChangeFunction) {\n    const newVertex = FormulaVertex.fromAst(ast, address, size, this.lazilyTransformingAstService.version());\n    this.exchangeOrAddFormulaVertex(newVertex);\n    this.processCellDependencies(dependencies, newVertex);\n    this.graph.markNodeAsDirty(newVertex);\n    if (hasVolatileFunction) {\n      this.markAsVolatile(newVertex);\n    }\n    if (hasStructuralChangeFunction) {\n      this.markAsDependentOnStructureChange(newVertex);\n    }\n    this.correctInfiniteRangesDependency(address);\n    return this.getAndClearContentChanges();\n  }\n  setParsingErrorToCell(address, errorVertex) {\n    const vertex = this.shrinkPossibleArrayAndGetCell(address);\n    this.exchangeOrAddGraphNode(vertex, errorVertex);\n    this.addressMapping.setCell(address, errorVertex);\n    this.graph.markNodeAsDirty(errorVertex);\n    this.correctInfiniteRangesDependency(address);\n    return this.getAndClearContentChanges();\n  }\n  setValueToCell(address, value) {\n    const vertex = this.shrinkPossibleArrayAndGetCell(address);\n    if (vertex instanceof ArrayVertex) {\n      this.arrayMapping.removeArray(vertex.getRange());\n    }\n    if (vertex instanceof ValueCellVertex) {\n      const oldValues = vertex.getValues();\n      if (oldValues.rawValue !== value.rawValue) {\n        vertex.setValues(value);\n        this.graph.markNodeAsDirty(vertex);\n      }\n    } else {\n      const newVertex = new ValueCellVertex(value.parsedValue, value.rawValue);\n      this.exchangeOrAddGraphNode(vertex, newVertex);\n      this.addressMapping.setCell(address, newVertex);\n      this.graph.markNodeAsDirty(newVertex);\n    }\n    this.correctInfiniteRangesDependency(address);\n    return this.getAndClearContentChanges();\n  }\n  setCellEmpty(address) {\n    const vertex = this.shrinkPossibleArrayAndGetCell(address);\n    if (vertex === undefined) {\n      return ContentChanges.empty();\n    }\n    if (this.graph.adjacentNodes(vertex).size > 0) {\n      const emptyVertex = new EmptyCellVertex();\n      this.exchangeGraphNode(vertex, emptyVertex);\n      if (this.graph.adjacentNodesCount(emptyVertex) === 0) {\n        this.removeVertex(emptyVertex);\n        this.addressMapping.removeCell(address);\n      } else {\n        this.graph.markNodeAsDirty(emptyVertex);\n        this.addressMapping.setCell(address, emptyVertex);\n      }\n    } else {\n      this.removeVertex(vertex);\n      this.addressMapping.removeCell(address);\n    }\n    return this.getAndClearContentChanges();\n  }\n  clearDirtyVertices() {\n    this.graph.clearDirtyNodes();\n  }\n  verticesToRecompute() {\n    return this.graph.getDirtyAndVolatileNodes();\n  }\n  processCellDependencies(cellDependencies, endVertex) {\n    const endVertexId = this.graph.getNodeId(endVertex);\n    cellDependencies.forEach(dep => {\n      if (dep instanceof AbsoluteCellRange) {\n        const range = dep;\n        let rangeVertex = this.getRange(range.start, range.end);\n        if (rangeVertex === undefined) {\n          rangeVertex = new RangeVertex(range);\n          this.rangeMapping.setRange(rangeVertex);\n        }\n        this.graph.addNodeAndReturnId(rangeVertex);\n        const rangeVertexId = this.graph.getNodeId(rangeVertex);\n        if (!range.isFinite()) {\n          this.graph.markNodeAsInfiniteRange(rangeVertexId);\n        }\n        const {\n          smallerRangeVertex,\n          restRange\n        } = this.rangeMapping.findSmallerRange(range);\n        if (smallerRangeVertex !== undefined) {\n          this.graph.addEdge(smallerRangeVertex, rangeVertexId);\n          if (rangeVertex.bruteForce) {\n            rangeVertex.bruteForce = false;\n            for (const cellFromRange of range.addresses(this)) {\n              //if we ever switch heuristic to processing by sorted sizes, this would be unnecessary\n              this.graph.removeEdge(this.fetchCell(cellFromRange), rangeVertexId);\n            }\n          }\n        } else {\n          rangeVertex.bruteForce = true;\n        }\n        const array = this.arrayMapping.getArray(restRange);\n        if (array !== undefined) {\n          this.graph.addEdge(array, rangeVertexId);\n        } else {\n          for (const cellFromRange of restRange.addresses(this)) {\n            const {\n              vertex,\n              id\n            } = this.fetchCellOrCreateEmpty(cellFromRange);\n            this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, rangeVertexId);\n          }\n        }\n        this.graph.addEdge(rangeVertexId, endVertexId);\n        if (range.isFinite()) {\n          this.correctInfiniteRangesDependenciesByRangeVertex(rangeVertex);\n        }\n      } else if (dep instanceof NamedExpressionDependency) {\n        const sheetOfVertex = endVertex.getAddress(this.lazilyTransformingAstService).sheet;\n        const {\n          vertex,\n          id\n        } = this.fetchNamedExpressionVertex(dep.name, sheetOfVertex);\n        this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, endVertexId);\n      } else {\n        const {\n          vertex,\n          id\n        } = this.fetchCellOrCreateEmpty(dep);\n        this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, endVertexId);\n      }\n    });\n  }\n  fetchNamedExpressionVertex(expressionName, sheetId) {\n    const namedExpression = this.namedExpressions.namedExpressionOrPlaceholder(expressionName, sheetId);\n    return this.fetchCellOrCreateEmpty(namedExpression.address);\n  }\n  exchangeNode(addressFrom, addressTo) {\n    const vertexFrom = this.fetchCellOrCreateEmpty(addressFrom).vertex;\n    const vertexTo = this.fetchCellOrCreateEmpty(addressTo).vertex;\n    this.addressMapping.removeCell(addressFrom);\n    this.exchangeGraphNode(vertexFrom, vertexTo);\n  }\n  fetchCellOrCreateEmpty(address) {\n    const existingVertex = this.addressMapping.getCell(address);\n    if (existingVertex !== undefined) {\n      return {\n        vertex: existingVertex,\n        id: undefined\n      };\n    }\n    const newVertex = new EmptyCellVertex();\n    const newVertexId = this.graph.addNodeAndReturnId(newVertex);\n    this.addressMapping.setCell(address, newVertex);\n    return {\n      vertex: newVertex,\n      id: newVertexId\n    };\n  }\n  removeRows(removedRows) {\n    this.stats.measure(StatType.ADJUSTING_GRAPH, () => {\n      for (const [address, vertex] of this.addressMapping.entriesFromRowsSpan(removedRows)) {\n        for (const adjacentNode of this.graph.adjacentNodes(vertex)) {\n          this.graph.markNodeAsDirty(adjacentNode);\n        }\n        if (vertex instanceof ArrayVertex) {\n          if (vertex.isLeftCorner(address)) {\n            this.shrinkArrayToCorner(vertex);\n            this.arrayMapping.removeArray(vertex.getRange());\n          } else {\n            continue;\n          }\n        }\n        this.removeVertex(vertex);\n      }\n    });\n    this.stats.measure(StatType.ADJUSTING_ADDRESS_MAPPING, () => {\n      this.addressMapping.removeRows(removedRows);\n    });\n    const affectedArrays = this.stats.measure(StatType.ADJUSTING_RANGES, () => {\n      const affectedRanges = this.truncateRanges(removedRows, address => address.row);\n      return this.getArrayVerticesRelatedToRanges(affectedRanges);\n    });\n    this.stats.measure(StatType.ADJUSTING_ARRAY_MAPPING, () => {\n      this.fixArraysAfterRemovingRows(removedRows.sheet, removedRows.rowStart, removedRows.numberOfRows);\n    });\n    this.addStructuralNodesToChangeSet();\n    return {\n      affectedArrays,\n      contentChanges: this.getAndClearContentChanges()\n    };\n  }\n  removeSheet(removedSheetId) {\n    this.clearSheet(removedSheetId);\n    for (const [adr, vertex] of this.addressMapping.sheetEntries(removedSheetId)) {\n      for (const adjacentNode of this.graph.adjacentNodes(vertex)) {\n        this.graph.markNodeAsDirty(adjacentNode);\n      }\n      this.removeVertex(vertex);\n      this.addressMapping.removeCell(adr);\n    }\n    this.stats.measure(StatType.ADJUSTING_RANGES, () => {\n      const rangesToRemove = this.rangeMapping.removeRangesInSheet(removedSheetId);\n      for (const range of rangesToRemove) {\n        this.removeVertex(range);\n      }\n      this.stats.measure(StatType.ADJUSTING_ADDRESS_MAPPING, () => {\n        this.addressMapping.removeSheet(removedSheetId);\n      });\n    });\n  }\n  clearSheet(sheetId) {\n    const arrays = new Set();\n    for (const [address, vertex] of this.addressMapping.sheetEntries(sheetId)) {\n      if (vertex instanceof ArrayVertex) {\n        arrays.add(vertex);\n      } else {\n        this.setCellEmpty(address);\n      }\n    }\n    for (const array of arrays.values()) {\n      this.setArrayEmpty(array);\n    }\n    this.addStructuralNodesToChangeSet();\n  }\n  removeColumns(removedColumns) {\n    this.stats.measure(StatType.ADJUSTING_GRAPH, () => {\n      for (const [address, vertex] of this.addressMapping.entriesFromColumnsSpan(removedColumns)) {\n        for (const adjacentNode of this.graph.adjacentNodes(vertex)) {\n          this.graph.markNodeAsDirty(adjacentNode);\n        }\n        if (vertex instanceof ArrayVertex) {\n          if (vertex.isLeftCorner(address)) {\n            this.shrinkArrayToCorner(vertex);\n            this.arrayMapping.removeArray(vertex.getRange());\n          } else {\n            continue;\n          }\n        }\n        this.removeVertex(vertex);\n      }\n    });\n    this.stats.measure(StatType.ADJUSTING_ADDRESS_MAPPING, () => {\n      this.addressMapping.removeColumns(removedColumns);\n    });\n    const affectedArrays = this.stats.measure(StatType.ADJUSTING_RANGES, () => {\n      const affectedRanges = this.truncateRanges(removedColumns, address => address.col);\n      return this.getArrayVerticesRelatedToRanges(affectedRanges);\n    });\n    this.stats.measure(StatType.ADJUSTING_ARRAY_MAPPING, () => {\n      return this.fixArraysAfterRemovingColumns(removedColumns.sheet, removedColumns.columnStart, removedColumns.numberOfColumns);\n    });\n    this.addStructuralNodesToChangeSet();\n    return {\n      affectedArrays,\n      contentChanges: this.getAndClearContentChanges()\n    };\n  }\n  addRows(addedRows) {\n    this.stats.measure(StatType.ADJUSTING_ADDRESS_MAPPING, () => {\n      this.addressMapping.addRows(addedRows.sheet, addedRows.rowStart, addedRows.numberOfRows);\n    });\n    const affectedArrays = this.stats.measure(StatType.ADJUSTING_RANGES, () => {\n      const result = this.rangeMapping.moveAllRangesInSheetAfterRowByRows(addedRows.sheet, addedRows.rowStart, addedRows.numberOfRows);\n      this.fixRangesWhenAddingRows(addedRows.sheet, addedRows.rowStart, addedRows.numberOfRows);\n      return this.getArrayVerticesRelatedToRanges(result.verticesWithChangedSize);\n    });\n    this.stats.measure(StatType.ADJUSTING_ARRAY_MAPPING, () => {\n      this.fixArraysAfterAddingRow(addedRows.sheet, addedRows.rowStart, addedRows.numberOfRows);\n    });\n    for (const vertex of this.addressMapping.verticesFromRowsSpan(addedRows)) {\n      this.graph.markNodeAsDirty(vertex);\n    }\n    this.addStructuralNodesToChangeSet();\n    return {\n      affectedArrays\n    };\n  }\n  addColumns(addedColumns) {\n    this.stats.measure(StatType.ADJUSTING_ADDRESS_MAPPING, () => {\n      this.addressMapping.addColumns(addedColumns.sheet, addedColumns.columnStart, addedColumns.numberOfColumns);\n    });\n    const affectedArrays = this.stats.measure(StatType.ADJUSTING_RANGES, () => {\n      const result = this.rangeMapping.moveAllRangesInSheetAfterColumnByColumns(addedColumns.sheet, addedColumns.columnStart, addedColumns.numberOfColumns);\n      this.fixRangesWhenAddingColumns(addedColumns.sheet, addedColumns.columnStart, addedColumns.numberOfColumns);\n      return this.getArrayVerticesRelatedToRanges(result.verticesWithChangedSize);\n    });\n    this.stats.measure(StatType.ADJUSTING_ARRAY_MAPPING, () => {\n      return this.fixArraysAfterAddingColumn(addedColumns.sheet, addedColumns.columnStart, addedColumns.numberOfColumns);\n    });\n    for (const vertex of this.addressMapping.verticesFromColumnsSpan(addedColumns)) {\n      this.graph.markNodeAsDirty(vertex);\n    }\n    this.addStructuralNodesToChangeSet();\n    return {\n      affectedArrays,\n      contentChanges: this.getAndClearContentChanges()\n    };\n  }\n  isThereSpaceForArray(arrayVertex) {\n    const range = arrayVertex.getRangeOrUndef();\n    if (range === undefined) {\n      return false;\n    }\n    for (const address of range.addresses(this)) {\n      const vertexUnderAddress = this.addressMapping.getCell(address);\n      if (vertexUnderAddress !== undefined && !(vertexUnderAddress instanceof EmptyCellVertex) && vertexUnderAddress !== arrayVertex) {\n        return false;\n      }\n    }\n    return true;\n  }\n  moveCells(sourceRange, toRight, toBottom, toSheet) {\n    for (const sourceAddress of sourceRange.addressesWithDirection(toRight, toBottom, this)) {\n      const targetAddress = simpleCellAddress(toSheet, sourceAddress.col + toRight, sourceAddress.row + toBottom);\n      let sourceVertex = this.addressMapping.getCell(sourceAddress);\n      const targetVertex = this.addressMapping.getCell(targetAddress);\n      this.addressMapping.removeCell(sourceAddress);\n      if (sourceVertex !== undefined) {\n        this.graph.markNodeAsDirty(sourceVertex);\n        this.addressMapping.setCell(targetAddress, sourceVertex);\n        let emptyVertex = undefined;\n        for (const adjacentNode of this.graph.adjacentNodes(sourceVertex)) {\n          if (adjacentNode instanceof RangeVertex && !sourceRange.containsRange(adjacentNode.range)) {\n            emptyVertex = emptyVertex !== null && emptyVertex !== void 0 ? emptyVertex : this.fetchCellOrCreateEmpty(sourceAddress).vertex;\n            this.graph.addEdge(emptyVertex, adjacentNode);\n            this.graph.removeEdge(sourceVertex, adjacentNode);\n          }\n        }\n        if (emptyVertex) {\n          this.graph.markNodeAsDirty(emptyVertex);\n          this.addressMapping.setCell(sourceAddress, emptyVertex);\n        }\n      }\n      if (targetVertex !== undefined) {\n        if (sourceVertex === undefined) {\n          this.addressMapping.removeCell(targetAddress);\n        }\n        for (const adjacentNode of this.graph.adjacentNodes(targetVertex)) {\n          sourceVertex = sourceVertex !== null && sourceVertex !== void 0 ? sourceVertex : this.fetchCellOrCreateEmpty(targetAddress).vertex;\n          this.graph.addEdge(sourceVertex, adjacentNode);\n          this.graph.markNodeAsDirty(sourceVertex);\n        }\n        this.removeVertex(targetVertex);\n      }\n    }\n    for (const rangeVertex of this.rangeMapping.rangeVerticesContainedInRange(sourceRange)) {\n      for (const adjacentNode of this.graph.adjacentNodes(rangeVertex)) {\n        if (adjacentNode instanceof RangeVertex && !sourceRange.containsRange(adjacentNode.range)) {\n          this.graph.removeEdge(rangeVertex, adjacentNode);\n          for (const address of rangeVertex.range.addresses(this)) {\n            const {\n              vertex,\n              id\n            } = this.fetchCellOrCreateEmpty(address);\n            this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, adjacentNode);\n            this.addressMapping.setCell(address, vertex);\n            this.graph.markNodeAsDirty(vertex);\n          }\n        }\n      }\n    }\n    this.rangeMapping.moveRangesInsideSourceRange(sourceRange, toRight, toBottom, toSheet);\n  }\n  setArrayEmpty(arrayVertex) {\n    const arrayRange = AbsoluteCellRange.spanFrom(arrayVertex.getAddress(this.lazilyTransformingAstService), arrayVertex.width, arrayVertex.height);\n    const adjacentNodes = this.graph.adjacentNodes(arrayVertex);\n    for (const address of arrayRange.addresses(this)) {\n      this.addressMapping.removeCell(address);\n    }\n    for (const adjacentNode of adjacentNodes.values()) {\n      const nodeDependencies = collectAddressesDependentToRange(this.functionRegistry, adjacentNode, arrayVertex.getRange(), this.lazilyTransformingAstService, this);\n      for (const address of nodeDependencies) {\n        const {\n          vertex,\n          id\n        } = this.fetchCellOrCreateEmpty(address);\n        this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, adjacentNode);\n      }\n      if (nodeDependencies.length > 0) {\n        this.graph.markNodeAsDirty(adjacentNode);\n      }\n    }\n    this.removeVertex(arrayVertex);\n    this.arrayMapping.removeArray(arrayVertex.getRange());\n  }\n  addVertex(address, vertex) {\n    this.graph.addNodeAndReturnId(vertex);\n    this.addressMapping.setCell(address, vertex);\n  }\n  addArrayVertex(address, vertex) {\n    this.graph.addNodeAndReturnId(vertex);\n    this.setAddressMappingForArrayVertex(vertex, address);\n  }\n  *arrayFormulaNodes() {\n    for (const vertex of this.graph.getNodes()) {\n      if (vertex instanceof ArrayVertex) {\n        yield vertex;\n      }\n    }\n  }\n  *entriesFromRowsSpan(rowsSpan) {\n    yield* this.addressMapping.entriesFromRowsSpan(rowsSpan);\n  }\n  *entriesFromColumnsSpan(columnsSpan) {\n    yield* this.addressMapping.entriesFromColumnsSpan(columnsSpan);\n  }\n  fetchCell(address) {\n    return this.addressMapping.fetchCell(address);\n  }\n  getCell(address) {\n    return this.addressMapping.getCell(address);\n  }\n  getCellValue(address) {\n    return this.addressMapping.getCellValue(address);\n  }\n  getRawValue(address) {\n    return this.addressMapping.getRawValue(address);\n  }\n  getScalarValue(address) {\n    const value = this.addressMapping.getCellValue(address);\n    if (value instanceof SimpleRangeValue) {\n      return new CellError(ErrorType.VALUE, ErrorMessage.ScalarExpected);\n    }\n    return value;\n  }\n  existsEdge(fromNode, toNode) {\n    return this.graph.existsEdge(fromNode, toNode);\n  }\n  getSheetId(sheetName) {\n    return this.sheetMapping.fetch(sheetName);\n  }\n  getSheetHeight(sheet) {\n    return this.addressMapping.getHeight(sheet);\n  }\n  getSheetWidth(sheet) {\n    return this.addressMapping.getWidth(sheet);\n  }\n  getArray(range) {\n    return this.arrayMapping.getArray(range);\n  }\n  getRange(start, end) {\n    return this.rangeMapping.getRange(start, end);\n  }\n  topSortWithScc() {\n    return this.graph.topSortWithScc();\n  }\n  markAsVolatile(vertex) {\n    this.graph.markNodeAsVolatile(vertex);\n  }\n  markAsDependentOnStructureChange(vertex) {\n    this.graph.markNodeAsChangingWithStructure(vertex);\n  }\n  forceApplyPostponedTransformations() {\n    for (const vertex of this.graph.getNodes()) {\n      if (vertex instanceof FormulaCellVertex) {\n        vertex.ensureRecentData(this.lazilyTransformingAstService);\n      }\n    }\n  }\n  *rawValuesFromRange(range) {\n    for (const address of range.addresses(this)) {\n      const value = this.getScalarValue(address);\n      if (value !== EmptyValue) {\n        yield [getRawValue(value), address];\n      }\n    }\n  }\n  computeListOfValuesInRange(range) {\n    const values = [];\n    for (const cellFromRange of range.addresses(this)) {\n      const value = this.getScalarValue(cellFromRange);\n      values.push(value);\n    }\n    return values;\n  }\n  shrinkArrayToCorner(array) {\n    this.cleanAddressMappingUnderArray(array);\n    for (const adjacentVertex of this.adjacentArrayVertices(array)) {\n      let relevantDependencies;\n      if (adjacentVertex instanceof FormulaVertex) {\n        relevantDependencies = this.formulaDirectDependenciesToArray(adjacentVertex, array);\n      } else {\n        relevantDependencies = this.rangeDirectDependenciesToArray(adjacentVertex, array);\n      }\n      let dependentToCorner = false;\n      for (const [address, vertex] of relevantDependencies) {\n        if (array.isLeftCorner(address)) {\n          dependentToCorner = true;\n        }\n        this.graph.addEdge(vertex, adjacentVertex);\n        this.graph.markNodeAsDirty(vertex);\n      }\n      if (!dependentToCorner) {\n        this.graph.removeEdge(array, adjacentVertex);\n      }\n    }\n    this.graph.markNodeAsDirty(array);\n  }\n  isArrayInternalCell(address) {\n    const vertex = this.getCell(address);\n    return vertex instanceof ArrayVertex && !vertex.isLeftCorner(address);\n  }\n  getAndClearContentChanges() {\n    const changes = this.changes;\n    this.changes = ContentChanges.empty();\n    return changes;\n  }\n  getAdjacentNodesAddresses(inputVertex) {\n    const deps = this.graph.adjacentNodes(inputVertex);\n    const ret = [];\n    deps.forEach(vertex => {\n      const castVertex = vertex;\n      if (castVertex instanceof RangeVertex) {\n        ret.push(simpleCellRange(castVertex.start, castVertex.end));\n      } else {\n        ret.push(castVertex.getAddress(this.lazilyTransformingAstService));\n      }\n    });\n    return ret;\n  }\n  exchangeGraphNode(oldNode, newNode) {\n    this.graph.addNodeAndReturnId(newNode);\n    const adjNodesStored = this.graph.adjacentNodes(oldNode);\n    this.removeVertex(oldNode);\n    adjNodesStored.forEach(adjacentNode => {\n      if (this.graph.hasNode(adjacentNode)) {\n        this.graph.addEdge(newNode, adjacentNode);\n      }\n    });\n  }\n  setArray(range, vertex) {\n    this.arrayMapping.setArray(range, vertex);\n  }\n  correctInfiniteRangesDependency(address) {\n    const relevantInfiniteRanges = this.graph.getInfiniteRanges().filter(({\n      node\n    }) => node.range.addressInRange(address));\n    if (relevantInfiniteRanges.length <= 0) {\n      return;\n    }\n    const {\n      vertex,\n      id: maybeVertexId\n    } = this.fetchCellOrCreateEmpty(address);\n    const vertexId = maybeVertexId !== null && maybeVertexId !== void 0 ? maybeVertexId : this.graph.getNodeId(vertex);\n    relevantInfiniteRanges.forEach(({\n      id\n    }) => {\n      this.graph.addEdge(vertexId, id);\n    });\n  }\n  exchangeOrAddGraphNode(oldNode, newNode) {\n    if (oldNode) {\n      this.exchangeGraphNode(oldNode, newNode);\n    } else {\n      this.graph.addNodeAndReturnId(newNode);\n    }\n  }\n  getArrayVerticesRelatedToRanges(ranges) {\n    const arrayVertices = new Set();\n    ranges.forEach(range => {\n      if (!this.graph.hasNode(range)) {\n        return;\n      }\n      this.graph.adjacentNodes(range).forEach(adjacentVertex => {\n        if (adjacentVertex instanceof ArrayVertex) {\n          arrayVertices.add(adjacentVertex);\n        }\n      });\n    });\n    return arrayVertices;\n  }\n  correctInfiniteRangesDependenciesByRangeVertex(vertex) {\n    this.graph.getInfiniteRanges().forEach(({\n      id: infiniteRangeVertexId,\n      node: infiniteRangeVertex\n    }) => {\n      const intersection = vertex.range.intersectionWith(infiniteRangeVertex.range);\n      if (intersection === undefined) {\n        return;\n      }\n      intersection.addresses(this).forEach(address => {\n        const {\n          vertex,\n          id\n        } = this.fetchCellOrCreateEmpty(address);\n        this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, infiniteRangeVertexId);\n      });\n    });\n  }\n  cleanAddressMappingUnderArray(vertex) {\n    const arrayRange = vertex.getRange();\n    for (const address of arrayRange.addresses(this)) {\n      const oldValue = vertex.getArrayCellValue(address);\n      if (this.getCell(address) === vertex) {\n        if (vertex.isLeftCorner(address)) {\n          this.changes.addChange(new CellError(ErrorType.REF), address, oldValue);\n        } else {\n          this.addressMapping.removeCell(address);\n          this.changes.addChange(EmptyValue, address, oldValue);\n        }\n      } else {\n        this.changes.addChange(EmptyValue, address, oldValue);\n      }\n    }\n  }\n  *formulaDirectDependenciesToArray(vertex, array) {\n    var _a;\n    const [, formulaDependencies] = (_a = this.formulaDependencyQuery(vertex)) !== null && _a !== void 0 ? _a : [];\n    if (formulaDependencies === undefined) {\n      return;\n    }\n    for (const dependency of formulaDependencies) {\n      if (dependency instanceof NamedExpressionDependency || dependency instanceof AbsoluteCellRange) {\n        continue;\n      }\n      if (array.getRange().addressInRange(dependency)) {\n        const vertex = this.fetchCellOrCreateEmpty(dependency).vertex;\n        yield [dependency, vertex];\n      }\n    }\n  }\n  *rangeDirectDependenciesToArray(vertex, array) {\n    const {\n      restRange: range\n    } = this.rangeMapping.findSmallerRange(vertex.range);\n    for (const address of range.addresses(this)) {\n      if (array.getRange().addressInRange(address)) {\n        const cell = this.fetchCellOrCreateEmpty(address).vertex;\n        yield [address, cell];\n      }\n    }\n  }\n  *adjacentArrayVertices(vertex) {\n    const adjacentNodes = this.graph.adjacentNodes(vertex);\n    for (const item of adjacentNodes) {\n      if (item instanceof FormulaVertex || item instanceof RangeVertex) {\n        yield item;\n      }\n    }\n  }\n  addStructuralNodesToChangeSet() {\n    this.graph.markChangingWithStructureNodesAsDirty();\n  }\n  fixRangesWhenAddingRows(sheet, row, numberOfRows) {\n    const originalValues = Array.from(this.rangeMapping.rangesInSheet(sheet));\n    for (const rangeVertex of originalValues) {\n      if (rangeVertex.range.includesRow(row + numberOfRows)) {\n        if (rangeVertex.bruteForce) {\n          const addedSubrangeInThatRange = rangeVertex.range.rangeWithSameWidth(row, numberOfRows);\n          for (const address of addedSubrangeInThatRange.addresses(this)) {\n            const {\n              vertex,\n              id\n            } = this.fetchCellOrCreateEmpty(address);\n            this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, rangeVertex);\n          }\n        } else {\n          let currentRangeVertex = rangeVertex;\n          let find = this.rangeMapping.findSmallerRange(currentRangeVertex.range);\n          if (find.smallerRangeVertex !== undefined) {\n            continue;\n          }\n          while (find.smallerRangeVertex === undefined) {\n            const newRangeVertex = new RangeVertex(AbsoluteCellRange.spanFrom(currentRangeVertex.range.start, currentRangeVertex.range.width(), currentRangeVertex.range.height() - 1));\n            this.rangeMapping.setRange(newRangeVertex);\n            this.graph.addNodeAndReturnId(newRangeVertex);\n            const restRange = new AbsoluteCellRange(simpleCellAddress(currentRangeVertex.range.start.sheet, currentRangeVertex.range.start.col, currentRangeVertex.range.end.row), currentRangeVertex.range.end);\n            this.addAllFromRange(restRange, currentRangeVertex);\n            this.graph.addEdge(newRangeVertex, currentRangeVertex);\n            currentRangeVertex = newRangeVertex;\n            find = this.rangeMapping.findSmallerRange(currentRangeVertex.range);\n          }\n          this.graph.addEdge(find.smallerRangeVertex, currentRangeVertex);\n          this.addAllFromRange(find.restRange, currentRangeVertex);\n          this.graph.removeEdge(find.smallerRangeVertex, rangeVertex);\n        }\n      }\n    }\n  }\n  addAllFromRange(range, rangeVertex) {\n    for (const address of range.addresses(this)) {\n      const {\n        vertex,\n        id\n      } = this.fetchCellOrCreateEmpty(address);\n      this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, rangeVertex);\n    }\n  }\n  fixRangesWhenAddingColumns(sheet, column, numberOfColumns) {\n    for (const rangeVertex of this.rangeMapping.rangesInSheet(sheet)) {\n      if (rangeVertex.range.includesColumn(column + numberOfColumns)) {\n        let subrange;\n        if (rangeVertex.bruteForce) {\n          subrange = rangeVertex.range.rangeWithSameHeight(column, numberOfColumns);\n        } else {\n          subrange = AbsoluteCellRange.spanFrom(simpleCellAddress(sheet, column, rangeVertex.range.end.row), numberOfColumns, 1);\n        }\n        for (const address of subrange.addresses(this)) {\n          const {\n            vertex,\n            id\n          } = this.fetchCellOrCreateEmpty(address);\n          this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, rangeVertex);\n        }\n      }\n    }\n  }\n  exchangeOrAddFormulaVertex(vertex) {\n    const address = vertex.getAddress(this.lazilyTransformingAstService);\n    const range = AbsoluteCellRange.spanFrom(address, vertex.width, vertex.height);\n    const oldNode = this.shrinkPossibleArrayAndGetCell(address);\n    if (vertex instanceof ArrayVertex) {\n      this.setArray(range, vertex);\n    }\n    this.exchangeOrAddGraphNode(oldNode, vertex);\n    this.addressMapping.setCell(address, vertex);\n    if (vertex instanceof ArrayVertex) {\n      if (!this.isThereSpaceForArray(vertex)) {\n        return;\n      }\n      for (const cellAddress of range.addresses(this)) {\n        if (vertex.isLeftCorner(cellAddress)) {\n          continue;\n        }\n        const old = this.getCell(cellAddress);\n        this.exchangeOrAddGraphNode(old, vertex);\n      }\n    }\n    for (const cellAddress of range.addresses(this)) {\n      this.addressMapping.setCell(cellAddress, vertex);\n    }\n  }\n  setAddressMappingForArrayVertex(vertex, formulaAddress) {\n    this.addressMapping.setCell(formulaAddress, vertex);\n    if (!(vertex instanceof ArrayVertex)) {\n      return;\n    }\n    const range = AbsoluteCellRange.spanFromOrUndef(formulaAddress, vertex.width, vertex.height);\n    if (range === undefined) {\n      return;\n    }\n    this.setArray(range, vertex);\n    if (!this.isThereSpaceForArray(vertex)) {\n      return;\n    }\n    for (const address of range.addresses(this)) {\n      this.addressMapping.setCell(address, vertex);\n    }\n  }\n  truncateRanges(span, coordinate) {\n    const {\n      verticesToRemove,\n      verticesToMerge,\n      verticesWithChangedSize\n    } = this.rangeMapping.truncateRanges(span, coordinate);\n    for (const [existingVertex, mergedVertex] of verticesToMerge) {\n      this.mergeRangeVertices(existingVertex, mergedVertex);\n    }\n    for (const rangeVertex of verticesToRemove) {\n      this.removeVertexAndCleanupDependencies(rangeVertex);\n    }\n    return verticesWithChangedSize;\n  }\n  fixArraysAfterAddingRow(sheet, rowStart, numberOfRows) {\n    this.arrayMapping.moveArrayVerticesAfterRowByRows(sheet, rowStart, numberOfRows);\n    if (rowStart <= 0) {\n      return;\n    }\n    for (const [, array] of this.arrayMapping.arraysInRows(RowsSpan.fromRowStartAndEnd(sheet, rowStart - 1, rowStart - 1))) {\n      const arrayRange = array.getRange();\n      for (let col = arrayRange.start.col; col <= arrayRange.end.col; ++col) {\n        for (let row = rowStart; row <= arrayRange.end.row; ++row) {\n          const destination = simpleCellAddress(sheet, col, row);\n          const source = simpleCellAddress(sheet, col, row + numberOfRows);\n          const value = array.getArrayCellValue(destination);\n          this.addressMapping.moveCell(source, destination);\n          this.changes.addChange(EmptyValue, source, value);\n        }\n      }\n    }\n  }\n  fixArraysAfterRemovingRows(sheet, rowStart, numberOfRows) {\n    this.arrayMapping.moveArrayVerticesAfterRowByRows(sheet, rowStart, -numberOfRows);\n    if (rowStart <= 0) {\n      return;\n    }\n    for (const [, array] of this.arrayMapping.arraysInRows(RowsSpan.fromRowStartAndEnd(sheet, rowStart - 1, rowStart - 1))) {\n      if (this.isThereSpaceForArray(array)) {\n        for (const address of array.getRange().addresses(this)) {\n          this.addressMapping.setCell(address, array);\n        }\n      } else {\n        this.setNoSpaceIfArray(array);\n      }\n    }\n  }\n  fixArraysAfterAddingColumn(sheet, columnStart, numberOfColumns) {\n    this.arrayMapping.moveArrayVerticesAfterColumnByColumns(sheet, columnStart, numberOfColumns);\n    if (columnStart <= 0) {\n      return;\n    }\n    for (const [, array] of this.arrayMapping.arraysInCols(ColumnsSpan.fromColumnStartAndEnd(sheet, columnStart - 1, columnStart - 1))) {\n      const arrayRange = array.getRange();\n      for (let row = arrayRange.start.row; row <= arrayRange.end.row; ++row) {\n        for (let col = columnStart; col <= arrayRange.end.col; ++col) {\n          const destination = simpleCellAddress(sheet, col, row);\n          const source = simpleCellAddress(sheet, col + numberOfColumns, row);\n          const value = array.getArrayCellValue(destination);\n          this.addressMapping.moveCell(source, destination);\n          this.changes.addChange(EmptyValue, source, value);\n        }\n      }\n    }\n  }\n  fixArraysAfterRemovingColumns(sheet, columnStart, numberOfColumns) {\n    this.arrayMapping.moveArrayVerticesAfterColumnByColumns(sheet, columnStart, -numberOfColumns);\n    if (columnStart <= 0) {\n      return;\n    }\n    for (const [, array] of this.arrayMapping.arraysInCols(ColumnsSpan.fromColumnStartAndEnd(sheet, columnStart - 1, columnStart - 1))) {\n      if (this.isThereSpaceForArray(array)) {\n        for (const address of array.getRange().addresses(this)) {\n          this.addressMapping.setCell(address, array);\n        }\n      } else {\n        this.setNoSpaceIfArray(array);\n      }\n    }\n  }\n  shrinkPossibleArrayAndGetCell(address) {\n    const vertex = this.getCell(address);\n    if (!(vertex instanceof ArrayVertex)) {\n      return vertex;\n    }\n    this.setNoSpaceIfArray(vertex);\n    return this.getCell(address);\n  }\n  setNoSpaceIfArray(vertex) {\n    if (vertex instanceof ArrayVertex) {\n      this.shrinkArrayToCorner(vertex);\n      vertex.setNoSpace();\n    }\n  }\n  removeVertex(vertex) {\n    this.removeVertexAndCleanupDependencies(vertex);\n    if (vertex instanceof RangeVertex) {\n      this.rangeMapping.removeRange(vertex);\n    }\n  }\n  mergeRangeVertices(existingVertex, newVertex) {\n    const adjNodesStored = this.graph.adjacentNodes(newVertex);\n    this.removeVertexAndCleanupDependencies(newVertex);\n    this.graph.removeEdgeIfExists(existingVertex, newVertex);\n    adjNodesStored.forEach(adjacentNode => {\n      if (this.graph.hasNode(adjacentNode)) {\n        this.graph.addEdge(existingVertex, adjacentNode);\n      }\n    });\n  }\n  removeVertexAndCleanupDependencies(inputVertex) {\n    const dependencies = new Set(this.graph.removeNode(inputVertex));\n    while (dependencies.size > 0) {\n      const dependency = dependencies.values().next().value;\n      dependencies.delete(dependency);\n      const [address, vertex] = dependency;\n      if (this.graph.hasNode(vertex) && this.graph.adjacentNodesCount(vertex) === 0) {\n        if (vertex instanceof RangeVertex || vertex instanceof EmptyCellVertex) {\n          this.graph.removeNode(vertex).forEach(candidate => dependencies.add(candidate));\n        }\n        if (vertex instanceof RangeVertex) {\n          this.rangeMapping.removeRange(vertex);\n        } else if (vertex instanceof EmptyCellVertex) {\n          this.addressMapping.removeCell(address);\n        }\n      }\n    }\n  }\n}","map":{"version":3,"names":["AbsoluteCellRange","simpleCellRange","absolutizeDependencies","CellError","ErrorType","isSimpleCellAddress","simpleCellAddress","ContentChanges","ErrorMessage","EmptyValue","getRawValue","SimpleRangeValue","collectDependencies","NamedExpressionDependency","ColumnsSpan","RowsSpan","StatType","ArrayVertex","EmptyCellVertex","FormulaCellVertex","RangeVertex","ValueCellVertex","AddressMapping","ArrayMapping","collectAddressesDependentToRange","FormulaVertex","Graph","RangeMapping","SheetMapping","DependencyGraph","constructor","addressMapping","rangeMapping","sheetMapping","arrayMapping","stats","lazilyTransformingAstService","functionRegistry","namedExpressions","changes","empty","dependencyQueryAddresses","vertex","rangeDependencyQuery","map","address","_","dependenciesResult","formulaDependencyQuery","undefined","dependencies","dependency","namedExpressionOrPlaceholder","name","sheet","start","end","dependencyQueryVertices","fetchRange","namedExpression","fetchCell","allDeps","smallerRangeVertex","restRange","findSmallerRange","range","graph","adjacentNodes","has","push","addresses","cell","getCell","formula","getAddress","getFormula","deps","buildEmpty","config","chooseAddressMappingPolicy","translationPackage","setFormulaToCell","ast","size","hasVolatileFunction","hasStructuralChangeFunction","newVertex","fromAst","version","exchangeOrAddFormulaVertex","processCellDependencies","markNodeAsDirty","markAsVolatile","markAsDependentOnStructureChange","correctInfiniteRangesDependency","getAndClearContentChanges","setParsingErrorToCell","errorVertex","shrinkPossibleArrayAndGetCell","exchangeOrAddGraphNode","setCell","setValueToCell","value","removeArray","getRange","oldValues","getValues","rawValue","setValues","parsedValue","setCellEmpty","emptyVertex","exchangeGraphNode","adjacentNodesCount","removeVertex","removeCell","clearDirtyVertices","clearDirtyNodes","verticesToRecompute","getDirtyAndVolatileNodes","cellDependencies","endVertex","endVertexId","getNodeId","forEach","dep","rangeVertex","setRange","addNodeAndReturnId","rangeVertexId","isFinite","markNodeAsInfiniteRange","addEdge","bruteForce","cellFromRange","removeEdge","array","getArray","id","fetchCellOrCreateEmpty","correctInfiniteRangesDependenciesByRangeVertex","sheetOfVertex","fetchNamedExpressionVertex","expressionName","sheetId","exchangeNode","addressFrom","addressTo","vertexFrom","vertexTo","existingVertex","newVertexId","removeRows","removedRows","measure","ADJUSTING_GRAPH","entriesFromRowsSpan","adjacentNode","isLeftCorner","shrinkArrayToCorner","ADJUSTING_ADDRESS_MAPPING","affectedArrays","ADJUSTING_RANGES","affectedRanges","truncateRanges","row","getArrayVerticesRelatedToRanges","ADJUSTING_ARRAY_MAPPING","fixArraysAfterRemovingRows","rowStart","numberOfRows","addStructuralNodesToChangeSet","contentChanges","removeSheet","removedSheetId","clearSheet","adr","sheetEntries","rangesToRemove","removeRangesInSheet","arrays","Set","add","values","setArrayEmpty","removeColumns","removedColumns","entriesFromColumnsSpan","col","fixArraysAfterRemovingColumns","columnStart","numberOfColumns","addRows","addedRows","result","moveAllRangesInSheetAfterRowByRows","fixRangesWhenAddingRows","verticesWithChangedSize","fixArraysAfterAddingRow","verticesFromRowsSpan","addColumns","addedColumns","moveAllRangesInSheetAfterColumnByColumns","fixRangesWhenAddingColumns","fixArraysAfterAddingColumn","verticesFromColumnsSpan","isThereSpaceForArray","arrayVertex","getRangeOrUndef","vertexUnderAddress","moveCells","sourceRange","toRight","toBottom","toSheet","sourceAddress","addressesWithDirection","targetAddress","sourceVertex","targetVertex","containsRange","rangeVerticesContainedInRange","moveRangesInsideSourceRange","arrayRange","spanFrom","width","height","nodeDependencies","length","addVertex","addArrayVertex","setAddressMappingForArrayVertex","arrayFormulaNodes","getNodes","rowsSpan","columnsSpan","getCellValue","getScalarValue","VALUE","ScalarExpected","existsEdge","fromNode","toNode","getSheetId","sheetName","fetch","getSheetHeight","getHeight","getSheetWidth","getWidth","topSortWithScc","markNodeAsVolatile","markNodeAsChangingWithStructure","forceApplyPostponedTransformations","ensureRecentData","rawValuesFromRange","computeListOfValuesInRange","cleanAddressMappingUnderArray","adjacentVertex","adjacentArrayVertices","relevantDependencies","formulaDirectDependenciesToArray","rangeDirectDependenciesToArray","dependentToCorner","isArrayInternalCell","getAdjacentNodesAddresses","inputVertex","ret","castVertex","oldNode","newNode","adjNodesStored","hasNode","setArray","relevantInfiniteRanges","getInfiniteRanges","filter","node","addressInRange","maybeVertexId","vertexId","ranges","arrayVertices","infiniteRangeVertexId","infiniteRangeVertex","intersection","intersectionWith","oldValue","getArrayCellValue","addChange","REF","_a","formulaDependencies","item","markChangingWithStructureNodesAsDirty","originalValues","Array","from","rangesInSheet","includesRow","addedSubrangeInThatRange","rangeWithSameWidth","currentRangeVertex","find","newRangeVertex","addAllFromRange","column","includesColumn","subrange","rangeWithSameHeight","cellAddress","old","formulaAddress","spanFromOrUndef","span","coordinate","verticesToRemove","verticesToMerge","mergedVertex","mergeRangeVertices","removeVertexAndCleanupDependencies","moveArrayVerticesAfterRowByRows","arraysInRows","fromRowStartAndEnd","destination","source","moveCell","setNoSpaceIfArray","moveArrayVerticesAfterColumnByColumns","arraysInCols","fromColumnStartAndEnd","setNoSpace","removeRange","removeEdgeIfExists","removeNode","next","delete","candidate"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/DependencyGraph/DependencyGraph.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange, simpleCellRange } from \"../AbsoluteCellRange.mjs\";\nimport { absolutizeDependencies } from \"../absolutizeDependencies.mjs\";\nimport { CellError, ErrorType, isSimpleCellAddress, simpleCellAddress } from \"../Cell.mjs\";\nimport { ContentChanges } from \"../ContentChanges.mjs\";\nimport { ErrorMessage } from \"../error-message.mjs\";\nimport { EmptyValue, getRawValue } from \"../interpreter/InterpreterValue.mjs\";\nimport { SimpleRangeValue } from \"../SimpleRangeValue.mjs\";\nimport { collectDependencies, NamedExpressionDependency } from \"../parser/index.mjs\";\nimport { ColumnsSpan, RowsSpan } from \"../Span.mjs\";\nimport { StatType } from \"../statistics/index.mjs\";\nimport { ArrayVertex, EmptyCellVertex, FormulaCellVertex, RangeVertex, ValueCellVertex } from \".//index.mjs\";\nimport { AddressMapping } from \"./AddressMapping/AddressMapping.mjs\";\nimport { ArrayMapping } from \"./ArrayMapping.mjs\";\nimport { collectAddressesDependentToRange } from \"./collectAddressesDependentToRange.mjs\";\nimport { FormulaVertex } from \"./FormulaCellVertex.mjs\";\nimport { Graph } from \"./Graph.mjs\";\nimport { RangeMapping } from \"./RangeMapping.mjs\";\nimport { SheetMapping } from \"./SheetMapping.mjs\";\nexport class DependencyGraph {\n  constructor(addressMapping, rangeMapping, sheetMapping, arrayMapping, stats, lazilyTransformingAstService, functionRegistry, namedExpressions) {\n    this.addressMapping = addressMapping;\n    this.rangeMapping = rangeMapping;\n    this.sheetMapping = sheetMapping;\n    this.arrayMapping = arrayMapping;\n    this.stats = stats;\n    this.lazilyTransformingAstService = lazilyTransformingAstService;\n    this.functionRegistry = functionRegistry;\n    this.namedExpressions = namedExpressions;\n    this.changes = ContentChanges.empty();\n    this.dependencyQueryAddresses = vertex => {\n      if (vertex instanceof RangeVertex) {\n        return this.rangeDependencyQuery(vertex).map(([address, _]) => address);\n      } else {\n        const dependenciesResult = this.formulaDependencyQuery(vertex);\n        if (dependenciesResult !== undefined) {\n          const [address, dependencies] = dependenciesResult;\n          return dependencies.map(dependency => {\n            if (dependency instanceof NamedExpressionDependency) {\n              return this.namedExpressions.namedExpressionOrPlaceholder(dependency.name, address.sheet).address;\n            } else if (isSimpleCellAddress(dependency)) {\n              return dependency;\n            } else {\n              return simpleCellRange(dependency.start, dependency.end);\n            }\n          });\n        } else {\n          return [];\n        }\n      }\n    };\n    this.dependencyQueryVertices = vertex => {\n      if (vertex instanceof RangeVertex) {\n        return this.rangeDependencyQuery(vertex);\n      } else {\n        const dependenciesResult = this.formulaDependencyQuery(vertex);\n        if (dependenciesResult !== undefined) {\n          const [address, dependencies] = dependenciesResult;\n          return dependencies.map(dependency => {\n            if (dependency instanceof AbsoluteCellRange) {\n              return [dependency.start, this.rangeMapping.fetchRange(dependency.start, dependency.end)];\n            } else if (dependency instanceof NamedExpressionDependency) {\n              const namedExpression = this.namedExpressions.namedExpressionOrPlaceholder(dependency.name, address.sheet);\n              return [namedExpression.address, this.addressMapping.fetchCell(namedExpression.address)];\n            } else {\n              return [dependency, this.addressMapping.fetchCell(dependency)];\n            }\n          });\n        } else {\n          return [];\n        }\n      }\n    };\n    this.rangeDependencyQuery = vertex => {\n      const allDeps = [];\n      const {\n        smallerRangeVertex,\n        restRange\n      } = this.rangeMapping.findSmallerRange(vertex.range); //checking whether this range was splitted by bruteForce or not\n      let range;\n      if (smallerRangeVertex !== undefined && this.graph.adjacentNodes(smallerRangeVertex).has(vertex)) {\n        range = restRange;\n        allDeps.push([new AbsoluteCellRange(smallerRangeVertex.start, smallerRangeVertex.end), smallerRangeVertex]);\n      } else {\n        //did we ever need to use full range\n        range = vertex.range;\n      }\n      for (const address of range.addresses(this)) {\n        const cell = this.addressMapping.getCell(address);\n        if (cell !== undefined) {\n          allDeps.push([address, cell]);\n        }\n      }\n      return allDeps;\n    };\n    this.formulaDependencyQuery = vertex => {\n      let formula;\n      let address;\n      if (vertex instanceof FormulaVertex) {\n        address = vertex.getAddress(this.lazilyTransformingAstService);\n        formula = vertex.getFormula(this.lazilyTransformingAstService);\n      } else {\n        return undefined;\n      }\n      const deps = collectDependencies(formula, this.functionRegistry);\n      return [address, absolutizeDependencies(deps, address)];\n    };\n    this.graph = new Graph(this.dependencyQueryVertices);\n  }\n  /**\r\n   * Invariants:\r\n   * - empty cell has associated EmptyCellVertex if and only if it is a dependency (possibly indirect, through range) to some formula\r\n   */\n  static buildEmpty(lazilyTransformingAstService, config, functionRegistry, namedExpressions, stats) {\n    return new DependencyGraph(new AddressMapping(config.chooseAddressMappingPolicy), new RangeMapping(), new SheetMapping(config.translationPackage), new ArrayMapping(), stats, lazilyTransformingAstService, functionRegistry, namedExpressions);\n  }\n  setFormulaToCell(address, ast, dependencies, size, hasVolatileFunction, hasStructuralChangeFunction) {\n    const newVertex = FormulaVertex.fromAst(ast, address, size, this.lazilyTransformingAstService.version());\n    this.exchangeOrAddFormulaVertex(newVertex);\n    this.processCellDependencies(dependencies, newVertex);\n    this.graph.markNodeAsDirty(newVertex);\n    if (hasVolatileFunction) {\n      this.markAsVolatile(newVertex);\n    }\n    if (hasStructuralChangeFunction) {\n      this.markAsDependentOnStructureChange(newVertex);\n    }\n    this.correctInfiniteRangesDependency(address);\n    return this.getAndClearContentChanges();\n  }\n  setParsingErrorToCell(address, errorVertex) {\n    const vertex = this.shrinkPossibleArrayAndGetCell(address);\n    this.exchangeOrAddGraphNode(vertex, errorVertex);\n    this.addressMapping.setCell(address, errorVertex);\n    this.graph.markNodeAsDirty(errorVertex);\n    this.correctInfiniteRangesDependency(address);\n    return this.getAndClearContentChanges();\n  }\n  setValueToCell(address, value) {\n    const vertex = this.shrinkPossibleArrayAndGetCell(address);\n    if (vertex instanceof ArrayVertex) {\n      this.arrayMapping.removeArray(vertex.getRange());\n    }\n    if (vertex instanceof ValueCellVertex) {\n      const oldValues = vertex.getValues();\n      if (oldValues.rawValue !== value.rawValue) {\n        vertex.setValues(value);\n        this.graph.markNodeAsDirty(vertex);\n      }\n    } else {\n      const newVertex = new ValueCellVertex(value.parsedValue, value.rawValue);\n      this.exchangeOrAddGraphNode(vertex, newVertex);\n      this.addressMapping.setCell(address, newVertex);\n      this.graph.markNodeAsDirty(newVertex);\n    }\n    this.correctInfiniteRangesDependency(address);\n    return this.getAndClearContentChanges();\n  }\n  setCellEmpty(address) {\n    const vertex = this.shrinkPossibleArrayAndGetCell(address);\n    if (vertex === undefined) {\n      return ContentChanges.empty();\n    }\n    if (this.graph.adjacentNodes(vertex).size > 0) {\n      const emptyVertex = new EmptyCellVertex();\n      this.exchangeGraphNode(vertex, emptyVertex);\n      if (this.graph.adjacentNodesCount(emptyVertex) === 0) {\n        this.removeVertex(emptyVertex);\n        this.addressMapping.removeCell(address);\n      } else {\n        this.graph.markNodeAsDirty(emptyVertex);\n        this.addressMapping.setCell(address, emptyVertex);\n      }\n    } else {\n      this.removeVertex(vertex);\n      this.addressMapping.removeCell(address);\n    }\n    return this.getAndClearContentChanges();\n  }\n  clearDirtyVertices() {\n    this.graph.clearDirtyNodes();\n  }\n  verticesToRecompute() {\n    return this.graph.getDirtyAndVolatileNodes();\n  }\n  processCellDependencies(cellDependencies, endVertex) {\n    const endVertexId = this.graph.getNodeId(endVertex);\n    cellDependencies.forEach(dep => {\n      if (dep instanceof AbsoluteCellRange) {\n        const range = dep;\n        let rangeVertex = this.getRange(range.start, range.end);\n        if (rangeVertex === undefined) {\n          rangeVertex = new RangeVertex(range);\n          this.rangeMapping.setRange(rangeVertex);\n        }\n        this.graph.addNodeAndReturnId(rangeVertex);\n        const rangeVertexId = this.graph.getNodeId(rangeVertex);\n        if (!range.isFinite()) {\n          this.graph.markNodeAsInfiniteRange(rangeVertexId);\n        }\n        const {\n          smallerRangeVertex,\n          restRange\n        } = this.rangeMapping.findSmallerRange(range);\n        if (smallerRangeVertex !== undefined) {\n          this.graph.addEdge(smallerRangeVertex, rangeVertexId);\n          if (rangeVertex.bruteForce) {\n            rangeVertex.bruteForce = false;\n            for (const cellFromRange of range.addresses(this)) {\n              //if we ever switch heuristic to processing by sorted sizes, this would be unnecessary\n              this.graph.removeEdge(this.fetchCell(cellFromRange), rangeVertexId);\n            }\n          }\n        } else {\n          rangeVertex.bruteForce = true;\n        }\n        const array = this.arrayMapping.getArray(restRange);\n        if (array !== undefined) {\n          this.graph.addEdge(array, rangeVertexId);\n        } else {\n          for (const cellFromRange of restRange.addresses(this)) {\n            const {\n              vertex,\n              id\n            } = this.fetchCellOrCreateEmpty(cellFromRange);\n            this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, rangeVertexId);\n          }\n        }\n        this.graph.addEdge(rangeVertexId, endVertexId);\n        if (range.isFinite()) {\n          this.correctInfiniteRangesDependenciesByRangeVertex(rangeVertex);\n        }\n      } else if (dep instanceof NamedExpressionDependency) {\n        const sheetOfVertex = endVertex.getAddress(this.lazilyTransformingAstService).sheet;\n        const {\n          vertex,\n          id\n        } = this.fetchNamedExpressionVertex(dep.name, sheetOfVertex);\n        this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, endVertexId);\n      } else {\n        const {\n          vertex,\n          id\n        } = this.fetchCellOrCreateEmpty(dep);\n        this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, endVertexId);\n      }\n    });\n  }\n  fetchNamedExpressionVertex(expressionName, sheetId) {\n    const namedExpression = this.namedExpressions.namedExpressionOrPlaceholder(expressionName, sheetId);\n    return this.fetchCellOrCreateEmpty(namedExpression.address);\n  }\n  exchangeNode(addressFrom, addressTo) {\n    const vertexFrom = this.fetchCellOrCreateEmpty(addressFrom).vertex;\n    const vertexTo = this.fetchCellOrCreateEmpty(addressTo).vertex;\n    this.addressMapping.removeCell(addressFrom);\n    this.exchangeGraphNode(vertexFrom, vertexTo);\n  }\n  fetchCellOrCreateEmpty(address) {\n    const existingVertex = this.addressMapping.getCell(address);\n    if (existingVertex !== undefined) {\n      return {\n        vertex: existingVertex,\n        id: undefined\n      };\n    }\n    const newVertex = new EmptyCellVertex();\n    const newVertexId = this.graph.addNodeAndReturnId(newVertex);\n    this.addressMapping.setCell(address, newVertex);\n    return {\n      vertex: newVertex,\n      id: newVertexId\n    };\n  }\n  removeRows(removedRows) {\n    this.stats.measure(StatType.ADJUSTING_GRAPH, () => {\n      for (const [address, vertex] of this.addressMapping.entriesFromRowsSpan(removedRows)) {\n        for (const adjacentNode of this.graph.adjacentNodes(vertex)) {\n          this.graph.markNodeAsDirty(adjacentNode);\n        }\n        if (vertex instanceof ArrayVertex) {\n          if (vertex.isLeftCorner(address)) {\n            this.shrinkArrayToCorner(vertex);\n            this.arrayMapping.removeArray(vertex.getRange());\n          } else {\n            continue;\n          }\n        }\n        this.removeVertex(vertex);\n      }\n    });\n    this.stats.measure(StatType.ADJUSTING_ADDRESS_MAPPING, () => {\n      this.addressMapping.removeRows(removedRows);\n    });\n    const affectedArrays = this.stats.measure(StatType.ADJUSTING_RANGES, () => {\n      const affectedRanges = this.truncateRanges(removedRows, address => address.row);\n      return this.getArrayVerticesRelatedToRanges(affectedRanges);\n    });\n    this.stats.measure(StatType.ADJUSTING_ARRAY_MAPPING, () => {\n      this.fixArraysAfterRemovingRows(removedRows.sheet, removedRows.rowStart, removedRows.numberOfRows);\n    });\n    this.addStructuralNodesToChangeSet();\n    return {\n      affectedArrays,\n      contentChanges: this.getAndClearContentChanges()\n    };\n  }\n  removeSheet(removedSheetId) {\n    this.clearSheet(removedSheetId);\n    for (const [adr, vertex] of this.addressMapping.sheetEntries(removedSheetId)) {\n      for (const adjacentNode of this.graph.adjacentNodes(vertex)) {\n        this.graph.markNodeAsDirty(adjacentNode);\n      }\n      this.removeVertex(vertex);\n      this.addressMapping.removeCell(adr);\n    }\n    this.stats.measure(StatType.ADJUSTING_RANGES, () => {\n      const rangesToRemove = this.rangeMapping.removeRangesInSheet(removedSheetId);\n      for (const range of rangesToRemove) {\n        this.removeVertex(range);\n      }\n      this.stats.measure(StatType.ADJUSTING_ADDRESS_MAPPING, () => {\n        this.addressMapping.removeSheet(removedSheetId);\n      });\n    });\n  }\n  clearSheet(sheetId) {\n    const arrays = new Set();\n    for (const [address, vertex] of this.addressMapping.sheetEntries(sheetId)) {\n      if (vertex instanceof ArrayVertex) {\n        arrays.add(vertex);\n      } else {\n        this.setCellEmpty(address);\n      }\n    }\n    for (const array of arrays.values()) {\n      this.setArrayEmpty(array);\n    }\n    this.addStructuralNodesToChangeSet();\n  }\n  removeColumns(removedColumns) {\n    this.stats.measure(StatType.ADJUSTING_GRAPH, () => {\n      for (const [address, vertex] of this.addressMapping.entriesFromColumnsSpan(removedColumns)) {\n        for (const adjacentNode of this.graph.adjacentNodes(vertex)) {\n          this.graph.markNodeAsDirty(adjacentNode);\n        }\n        if (vertex instanceof ArrayVertex) {\n          if (vertex.isLeftCorner(address)) {\n            this.shrinkArrayToCorner(vertex);\n            this.arrayMapping.removeArray(vertex.getRange());\n          } else {\n            continue;\n          }\n        }\n        this.removeVertex(vertex);\n      }\n    });\n    this.stats.measure(StatType.ADJUSTING_ADDRESS_MAPPING, () => {\n      this.addressMapping.removeColumns(removedColumns);\n    });\n    const affectedArrays = this.stats.measure(StatType.ADJUSTING_RANGES, () => {\n      const affectedRanges = this.truncateRanges(removedColumns, address => address.col);\n      return this.getArrayVerticesRelatedToRanges(affectedRanges);\n    });\n    this.stats.measure(StatType.ADJUSTING_ARRAY_MAPPING, () => {\n      return this.fixArraysAfterRemovingColumns(removedColumns.sheet, removedColumns.columnStart, removedColumns.numberOfColumns);\n    });\n    this.addStructuralNodesToChangeSet();\n    return {\n      affectedArrays,\n      contentChanges: this.getAndClearContentChanges()\n    };\n  }\n  addRows(addedRows) {\n    this.stats.measure(StatType.ADJUSTING_ADDRESS_MAPPING, () => {\n      this.addressMapping.addRows(addedRows.sheet, addedRows.rowStart, addedRows.numberOfRows);\n    });\n    const affectedArrays = this.stats.measure(StatType.ADJUSTING_RANGES, () => {\n      const result = this.rangeMapping.moveAllRangesInSheetAfterRowByRows(addedRows.sheet, addedRows.rowStart, addedRows.numberOfRows);\n      this.fixRangesWhenAddingRows(addedRows.sheet, addedRows.rowStart, addedRows.numberOfRows);\n      return this.getArrayVerticesRelatedToRanges(result.verticesWithChangedSize);\n    });\n    this.stats.measure(StatType.ADJUSTING_ARRAY_MAPPING, () => {\n      this.fixArraysAfterAddingRow(addedRows.sheet, addedRows.rowStart, addedRows.numberOfRows);\n    });\n    for (const vertex of this.addressMapping.verticesFromRowsSpan(addedRows)) {\n      this.graph.markNodeAsDirty(vertex);\n    }\n    this.addStructuralNodesToChangeSet();\n    return {\n      affectedArrays\n    };\n  }\n  addColumns(addedColumns) {\n    this.stats.measure(StatType.ADJUSTING_ADDRESS_MAPPING, () => {\n      this.addressMapping.addColumns(addedColumns.sheet, addedColumns.columnStart, addedColumns.numberOfColumns);\n    });\n    const affectedArrays = this.stats.measure(StatType.ADJUSTING_RANGES, () => {\n      const result = this.rangeMapping.moveAllRangesInSheetAfterColumnByColumns(addedColumns.sheet, addedColumns.columnStart, addedColumns.numberOfColumns);\n      this.fixRangesWhenAddingColumns(addedColumns.sheet, addedColumns.columnStart, addedColumns.numberOfColumns);\n      return this.getArrayVerticesRelatedToRanges(result.verticesWithChangedSize);\n    });\n    this.stats.measure(StatType.ADJUSTING_ARRAY_MAPPING, () => {\n      return this.fixArraysAfterAddingColumn(addedColumns.sheet, addedColumns.columnStart, addedColumns.numberOfColumns);\n    });\n    for (const vertex of this.addressMapping.verticesFromColumnsSpan(addedColumns)) {\n      this.graph.markNodeAsDirty(vertex);\n    }\n    this.addStructuralNodesToChangeSet();\n    return {\n      affectedArrays,\n      contentChanges: this.getAndClearContentChanges()\n    };\n  }\n  isThereSpaceForArray(arrayVertex) {\n    const range = arrayVertex.getRangeOrUndef();\n    if (range === undefined) {\n      return false;\n    }\n    for (const address of range.addresses(this)) {\n      const vertexUnderAddress = this.addressMapping.getCell(address);\n      if (vertexUnderAddress !== undefined && !(vertexUnderAddress instanceof EmptyCellVertex) && vertexUnderAddress !== arrayVertex) {\n        return false;\n      }\n    }\n    return true;\n  }\n  moveCells(sourceRange, toRight, toBottom, toSheet) {\n    for (const sourceAddress of sourceRange.addressesWithDirection(toRight, toBottom, this)) {\n      const targetAddress = simpleCellAddress(toSheet, sourceAddress.col + toRight, sourceAddress.row + toBottom);\n      let sourceVertex = this.addressMapping.getCell(sourceAddress);\n      const targetVertex = this.addressMapping.getCell(targetAddress);\n      this.addressMapping.removeCell(sourceAddress);\n      if (sourceVertex !== undefined) {\n        this.graph.markNodeAsDirty(sourceVertex);\n        this.addressMapping.setCell(targetAddress, sourceVertex);\n        let emptyVertex = undefined;\n        for (const adjacentNode of this.graph.adjacentNodes(sourceVertex)) {\n          if (adjacentNode instanceof RangeVertex && !sourceRange.containsRange(adjacentNode.range)) {\n            emptyVertex = emptyVertex !== null && emptyVertex !== void 0 ? emptyVertex : this.fetchCellOrCreateEmpty(sourceAddress).vertex;\n            this.graph.addEdge(emptyVertex, adjacentNode);\n            this.graph.removeEdge(sourceVertex, adjacentNode);\n          }\n        }\n        if (emptyVertex) {\n          this.graph.markNodeAsDirty(emptyVertex);\n          this.addressMapping.setCell(sourceAddress, emptyVertex);\n        }\n      }\n      if (targetVertex !== undefined) {\n        if (sourceVertex === undefined) {\n          this.addressMapping.removeCell(targetAddress);\n        }\n        for (const adjacentNode of this.graph.adjacentNodes(targetVertex)) {\n          sourceVertex = sourceVertex !== null && sourceVertex !== void 0 ? sourceVertex : this.fetchCellOrCreateEmpty(targetAddress).vertex;\n          this.graph.addEdge(sourceVertex, adjacentNode);\n          this.graph.markNodeAsDirty(sourceVertex);\n        }\n        this.removeVertex(targetVertex);\n      }\n    }\n    for (const rangeVertex of this.rangeMapping.rangeVerticesContainedInRange(sourceRange)) {\n      for (const adjacentNode of this.graph.adjacentNodes(rangeVertex)) {\n        if (adjacentNode instanceof RangeVertex && !sourceRange.containsRange(adjacentNode.range)) {\n          this.graph.removeEdge(rangeVertex, adjacentNode);\n          for (const address of rangeVertex.range.addresses(this)) {\n            const {\n              vertex,\n              id\n            } = this.fetchCellOrCreateEmpty(address);\n            this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, adjacentNode);\n            this.addressMapping.setCell(address, vertex);\n            this.graph.markNodeAsDirty(vertex);\n          }\n        }\n      }\n    }\n    this.rangeMapping.moveRangesInsideSourceRange(sourceRange, toRight, toBottom, toSheet);\n  }\n  setArrayEmpty(arrayVertex) {\n    const arrayRange = AbsoluteCellRange.spanFrom(arrayVertex.getAddress(this.lazilyTransformingAstService), arrayVertex.width, arrayVertex.height);\n    const adjacentNodes = this.graph.adjacentNodes(arrayVertex);\n    for (const address of arrayRange.addresses(this)) {\n      this.addressMapping.removeCell(address);\n    }\n    for (const adjacentNode of adjacentNodes.values()) {\n      const nodeDependencies = collectAddressesDependentToRange(this.functionRegistry, adjacentNode, arrayVertex.getRange(), this.lazilyTransformingAstService, this);\n      for (const address of nodeDependencies) {\n        const {\n          vertex,\n          id\n        } = this.fetchCellOrCreateEmpty(address);\n        this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, adjacentNode);\n      }\n      if (nodeDependencies.length > 0) {\n        this.graph.markNodeAsDirty(adjacentNode);\n      }\n    }\n    this.removeVertex(arrayVertex);\n    this.arrayMapping.removeArray(arrayVertex.getRange());\n  }\n  addVertex(address, vertex) {\n    this.graph.addNodeAndReturnId(vertex);\n    this.addressMapping.setCell(address, vertex);\n  }\n  addArrayVertex(address, vertex) {\n    this.graph.addNodeAndReturnId(vertex);\n    this.setAddressMappingForArrayVertex(vertex, address);\n  }\n  *arrayFormulaNodes() {\n    for (const vertex of this.graph.getNodes()) {\n      if (vertex instanceof ArrayVertex) {\n        yield vertex;\n      }\n    }\n  }\n  *entriesFromRowsSpan(rowsSpan) {\n    yield* this.addressMapping.entriesFromRowsSpan(rowsSpan);\n  }\n  *entriesFromColumnsSpan(columnsSpan) {\n    yield* this.addressMapping.entriesFromColumnsSpan(columnsSpan);\n  }\n  fetchCell(address) {\n    return this.addressMapping.fetchCell(address);\n  }\n  getCell(address) {\n    return this.addressMapping.getCell(address);\n  }\n  getCellValue(address) {\n    return this.addressMapping.getCellValue(address);\n  }\n  getRawValue(address) {\n    return this.addressMapping.getRawValue(address);\n  }\n  getScalarValue(address) {\n    const value = this.addressMapping.getCellValue(address);\n    if (value instanceof SimpleRangeValue) {\n      return new CellError(ErrorType.VALUE, ErrorMessage.ScalarExpected);\n    }\n    return value;\n  }\n  existsEdge(fromNode, toNode) {\n    return this.graph.existsEdge(fromNode, toNode);\n  }\n  getSheetId(sheetName) {\n    return this.sheetMapping.fetch(sheetName);\n  }\n  getSheetHeight(sheet) {\n    return this.addressMapping.getHeight(sheet);\n  }\n  getSheetWidth(sheet) {\n    return this.addressMapping.getWidth(sheet);\n  }\n  getArray(range) {\n    return this.arrayMapping.getArray(range);\n  }\n  getRange(start, end) {\n    return this.rangeMapping.getRange(start, end);\n  }\n  topSortWithScc() {\n    return this.graph.topSortWithScc();\n  }\n  markAsVolatile(vertex) {\n    this.graph.markNodeAsVolatile(vertex);\n  }\n  markAsDependentOnStructureChange(vertex) {\n    this.graph.markNodeAsChangingWithStructure(vertex);\n  }\n  forceApplyPostponedTransformations() {\n    for (const vertex of this.graph.getNodes()) {\n      if (vertex instanceof FormulaCellVertex) {\n        vertex.ensureRecentData(this.lazilyTransformingAstService);\n      }\n    }\n  }\n  *rawValuesFromRange(range) {\n    for (const address of range.addresses(this)) {\n      const value = this.getScalarValue(address);\n      if (value !== EmptyValue) {\n        yield [getRawValue(value), address];\n      }\n    }\n  }\n  computeListOfValuesInRange(range) {\n    const values = [];\n    for (const cellFromRange of range.addresses(this)) {\n      const value = this.getScalarValue(cellFromRange);\n      values.push(value);\n    }\n    return values;\n  }\n  shrinkArrayToCorner(array) {\n    this.cleanAddressMappingUnderArray(array);\n    for (const adjacentVertex of this.adjacentArrayVertices(array)) {\n      let relevantDependencies;\n      if (adjacentVertex instanceof FormulaVertex) {\n        relevantDependencies = this.formulaDirectDependenciesToArray(adjacentVertex, array);\n      } else {\n        relevantDependencies = this.rangeDirectDependenciesToArray(adjacentVertex, array);\n      }\n      let dependentToCorner = false;\n      for (const [address, vertex] of relevantDependencies) {\n        if (array.isLeftCorner(address)) {\n          dependentToCorner = true;\n        }\n        this.graph.addEdge(vertex, adjacentVertex);\n        this.graph.markNodeAsDirty(vertex);\n      }\n      if (!dependentToCorner) {\n        this.graph.removeEdge(array, adjacentVertex);\n      }\n    }\n    this.graph.markNodeAsDirty(array);\n  }\n  isArrayInternalCell(address) {\n    const vertex = this.getCell(address);\n    return vertex instanceof ArrayVertex && !vertex.isLeftCorner(address);\n  }\n  getAndClearContentChanges() {\n    const changes = this.changes;\n    this.changes = ContentChanges.empty();\n    return changes;\n  }\n  getAdjacentNodesAddresses(inputVertex) {\n    const deps = this.graph.adjacentNodes(inputVertex);\n    const ret = [];\n    deps.forEach(vertex => {\n      const castVertex = vertex;\n      if (castVertex instanceof RangeVertex) {\n        ret.push(simpleCellRange(castVertex.start, castVertex.end));\n      } else {\n        ret.push(castVertex.getAddress(this.lazilyTransformingAstService));\n      }\n    });\n    return ret;\n  }\n  exchangeGraphNode(oldNode, newNode) {\n    this.graph.addNodeAndReturnId(newNode);\n    const adjNodesStored = this.graph.adjacentNodes(oldNode);\n    this.removeVertex(oldNode);\n    adjNodesStored.forEach(adjacentNode => {\n      if (this.graph.hasNode(adjacentNode)) {\n        this.graph.addEdge(newNode, adjacentNode);\n      }\n    });\n  }\n  setArray(range, vertex) {\n    this.arrayMapping.setArray(range, vertex);\n  }\n  correctInfiniteRangesDependency(address) {\n    const relevantInfiniteRanges = this.graph.getInfiniteRanges().filter(({\n      node\n    }) => node.range.addressInRange(address));\n    if (relevantInfiniteRanges.length <= 0) {\n      return;\n    }\n    const {\n      vertex,\n      id: maybeVertexId\n    } = this.fetchCellOrCreateEmpty(address);\n    const vertexId = maybeVertexId !== null && maybeVertexId !== void 0 ? maybeVertexId : this.graph.getNodeId(vertex);\n    relevantInfiniteRanges.forEach(({\n      id\n    }) => {\n      this.graph.addEdge(vertexId, id);\n    });\n  }\n  exchangeOrAddGraphNode(oldNode, newNode) {\n    if (oldNode) {\n      this.exchangeGraphNode(oldNode, newNode);\n    } else {\n      this.graph.addNodeAndReturnId(newNode);\n    }\n  }\n  getArrayVerticesRelatedToRanges(ranges) {\n    const arrayVertices = new Set();\n    ranges.forEach(range => {\n      if (!this.graph.hasNode(range)) {\n        return;\n      }\n      this.graph.adjacentNodes(range).forEach(adjacentVertex => {\n        if (adjacentVertex instanceof ArrayVertex) {\n          arrayVertices.add(adjacentVertex);\n        }\n      });\n    });\n    return arrayVertices;\n  }\n  correctInfiniteRangesDependenciesByRangeVertex(vertex) {\n    this.graph.getInfiniteRanges().forEach(({\n      id: infiniteRangeVertexId,\n      node: infiniteRangeVertex\n    }) => {\n      const intersection = vertex.range.intersectionWith(infiniteRangeVertex.range);\n      if (intersection === undefined) {\n        return;\n      }\n      intersection.addresses(this).forEach(address => {\n        const {\n          vertex,\n          id\n        } = this.fetchCellOrCreateEmpty(address);\n        this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, infiniteRangeVertexId);\n      });\n    });\n  }\n  cleanAddressMappingUnderArray(vertex) {\n    const arrayRange = vertex.getRange();\n    for (const address of arrayRange.addresses(this)) {\n      const oldValue = vertex.getArrayCellValue(address);\n      if (this.getCell(address) === vertex) {\n        if (vertex.isLeftCorner(address)) {\n          this.changes.addChange(new CellError(ErrorType.REF), address, oldValue);\n        } else {\n          this.addressMapping.removeCell(address);\n          this.changes.addChange(EmptyValue, address, oldValue);\n        }\n      } else {\n        this.changes.addChange(EmptyValue, address, oldValue);\n      }\n    }\n  }\n  *formulaDirectDependenciesToArray(vertex, array) {\n    var _a;\n    const [, formulaDependencies] = (_a = this.formulaDependencyQuery(vertex)) !== null && _a !== void 0 ? _a : [];\n    if (formulaDependencies === undefined) {\n      return;\n    }\n    for (const dependency of formulaDependencies) {\n      if (dependency instanceof NamedExpressionDependency || dependency instanceof AbsoluteCellRange) {\n        continue;\n      }\n      if (array.getRange().addressInRange(dependency)) {\n        const vertex = this.fetchCellOrCreateEmpty(dependency).vertex;\n        yield [dependency, vertex];\n      }\n    }\n  }\n  *rangeDirectDependenciesToArray(vertex, array) {\n    const {\n      restRange: range\n    } = this.rangeMapping.findSmallerRange(vertex.range);\n    for (const address of range.addresses(this)) {\n      if (array.getRange().addressInRange(address)) {\n        const cell = this.fetchCellOrCreateEmpty(address).vertex;\n        yield [address, cell];\n      }\n    }\n  }\n  *adjacentArrayVertices(vertex) {\n    const adjacentNodes = this.graph.adjacentNodes(vertex);\n    for (const item of adjacentNodes) {\n      if (item instanceof FormulaVertex || item instanceof RangeVertex) {\n        yield item;\n      }\n    }\n  }\n  addStructuralNodesToChangeSet() {\n    this.graph.markChangingWithStructureNodesAsDirty();\n  }\n  fixRangesWhenAddingRows(sheet, row, numberOfRows) {\n    const originalValues = Array.from(this.rangeMapping.rangesInSheet(sheet));\n    for (const rangeVertex of originalValues) {\n      if (rangeVertex.range.includesRow(row + numberOfRows)) {\n        if (rangeVertex.bruteForce) {\n          const addedSubrangeInThatRange = rangeVertex.range.rangeWithSameWidth(row, numberOfRows);\n          for (const address of addedSubrangeInThatRange.addresses(this)) {\n            const {\n              vertex,\n              id\n            } = this.fetchCellOrCreateEmpty(address);\n            this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, rangeVertex);\n          }\n        } else {\n          let currentRangeVertex = rangeVertex;\n          let find = this.rangeMapping.findSmallerRange(currentRangeVertex.range);\n          if (find.smallerRangeVertex !== undefined) {\n            continue;\n          }\n          while (find.smallerRangeVertex === undefined) {\n            const newRangeVertex = new RangeVertex(AbsoluteCellRange.spanFrom(currentRangeVertex.range.start, currentRangeVertex.range.width(), currentRangeVertex.range.height() - 1));\n            this.rangeMapping.setRange(newRangeVertex);\n            this.graph.addNodeAndReturnId(newRangeVertex);\n            const restRange = new AbsoluteCellRange(simpleCellAddress(currentRangeVertex.range.start.sheet, currentRangeVertex.range.start.col, currentRangeVertex.range.end.row), currentRangeVertex.range.end);\n            this.addAllFromRange(restRange, currentRangeVertex);\n            this.graph.addEdge(newRangeVertex, currentRangeVertex);\n            currentRangeVertex = newRangeVertex;\n            find = this.rangeMapping.findSmallerRange(currentRangeVertex.range);\n          }\n          this.graph.addEdge(find.smallerRangeVertex, currentRangeVertex);\n          this.addAllFromRange(find.restRange, currentRangeVertex);\n          this.graph.removeEdge(find.smallerRangeVertex, rangeVertex);\n        }\n      }\n    }\n  }\n  addAllFromRange(range, rangeVertex) {\n    for (const address of range.addresses(this)) {\n      const {\n        vertex,\n        id\n      } = this.fetchCellOrCreateEmpty(address);\n      this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, rangeVertex);\n    }\n  }\n  fixRangesWhenAddingColumns(sheet, column, numberOfColumns) {\n    for (const rangeVertex of this.rangeMapping.rangesInSheet(sheet)) {\n      if (rangeVertex.range.includesColumn(column + numberOfColumns)) {\n        let subrange;\n        if (rangeVertex.bruteForce) {\n          subrange = rangeVertex.range.rangeWithSameHeight(column, numberOfColumns);\n        } else {\n          subrange = AbsoluteCellRange.spanFrom(simpleCellAddress(sheet, column, rangeVertex.range.end.row), numberOfColumns, 1);\n        }\n        for (const address of subrange.addresses(this)) {\n          const {\n            vertex,\n            id\n          } = this.fetchCellOrCreateEmpty(address);\n          this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, rangeVertex);\n        }\n      }\n    }\n  }\n  exchangeOrAddFormulaVertex(vertex) {\n    const address = vertex.getAddress(this.lazilyTransformingAstService);\n    const range = AbsoluteCellRange.spanFrom(address, vertex.width, vertex.height);\n    const oldNode = this.shrinkPossibleArrayAndGetCell(address);\n    if (vertex instanceof ArrayVertex) {\n      this.setArray(range, vertex);\n    }\n    this.exchangeOrAddGraphNode(oldNode, vertex);\n    this.addressMapping.setCell(address, vertex);\n    if (vertex instanceof ArrayVertex) {\n      if (!this.isThereSpaceForArray(vertex)) {\n        return;\n      }\n      for (const cellAddress of range.addresses(this)) {\n        if (vertex.isLeftCorner(cellAddress)) {\n          continue;\n        }\n        const old = this.getCell(cellAddress);\n        this.exchangeOrAddGraphNode(old, vertex);\n      }\n    }\n    for (const cellAddress of range.addresses(this)) {\n      this.addressMapping.setCell(cellAddress, vertex);\n    }\n  }\n  setAddressMappingForArrayVertex(vertex, formulaAddress) {\n    this.addressMapping.setCell(formulaAddress, vertex);\n    if (!(vertex instanceof ArrayVertex)) {\n      return;\n    }\n    const range = AbsoluteCellRange.spanFromOrUndef(formulaAddress, vertex.width, vertex.height);\n    if (range === undefined) {\n      return;\n    }\n    this.setArray(range, vertex);\n    if (!this.isThereSpaceForArray(vertex)) {\n      return;\n    }\n    for (const address of range.addresses(this)) {\n      this.addressMapping.setCell(address, vertex);\n    }\n  }\n  truncateRanges(span, coordinate) {\n    const {\n      verticesToRemove,\n      verticesToMerge,\n      verticesWithChangedSize\n    } = this.rangeMapping.truncateRanges(span, coordinate);\n    for (const [existingVertex, mergedVertex] of verticesToMerge) {\n      this.mergeRangeVertices(existingVertex, mergedVertex);\n    }\n    for (const rangeVertex of verticesToRemove) {\n      this.removeVertexAndCleanupDependencies(rangeVertex);\n    }\n    return verticesWithChangedSize;\n  }\n  fixArraysAfterAddingRow(sheet, rowStart, numberOfRows) {\n    this.arrayMapping.moveArrayVerticesAfterRowByRows(sheet, rowStart, numberOfRows);\n    if (rowStart <= 0) {\n      return;\n    }\n    for (const [, array] of this.arrayMapping.arraysInRows(RowsSpan.fromRowStartAndEnd(sheet, rowStart - 1, rowStart - 1))) {\n      const arrayRange = array.getRange();\n      for (let col = arrayRange.start.col; col <= arrayRange.end.col; ++col) {\n        for (let row = rowStart; row <= arrayRange.end.row; ++row) {\n          const destination = simpleCellAddress(sheet, col, row);\n          const source = simpleCellAddress(sheet, col, row + numberOfRows);\n          const value = array.getArrayCellValue(destination);\n          this.addressMapping.moveCell(source, destination);\n          this.changes.addChange(EmptyValue, source, value);\n        }\n      }\n    }\n  }\n  fixArraysAfterRemovingRows(sheet, rowStart, numberOfRows) {\n    this.arrayMapping.moveArrayVerticesAfterRowByRows(sheet, rowStart, -numberOfRows);\n    if (rowStart <= 0) {\n      return;\n    }\n    for (const [, array] of this.arrayMapping.arraysInRows(RowsSpan.fromRowStartAndEnd(sheet, rowStart - 1, rowStart - 1))) {\n      if (this.isThereSpaceForArray(array)) {\n        for (const address of array.getRange().addresses(this)) {\n          this.addressMapping.setCell(address, array);\n        }\n      } else {\n        this.setNoSpaceIfArray(array);\n      }\n    }\n  }\n  fixArraysAfterAddingColumn(sheet, columnStart, numberOfColumns) {\n    this.arrayMapping.moveArrayVerticesAfterColumnByColumns(sheet, columnStart, numberOfColumns);\n    if (columnStart <= 0) {\n      return;\n    }\n    for (const [, array] of this.arrayMapping.arraysInCols(ColumnsSpan.fromColumnStartAndEnd(sheet, columnStart - 1, columnStart - 1))) {\n      const arrayRange = array.getRange();\n      for (let row = arrayRange.start.row; row <= arrayRange.end.row; ++row) {\n        for (let col = columnStart; col <= arrayRange.end.col; ++col) {\n          const destination = simpleCellAddress(sheet, col, row);\n          const source = simpleCellAddress(sheet, col + numberOfColumns, row);\n          const value = array.getArrayCellValue(destination);\n          this.addressMapping.moveCell(source, destination);\n          this.changes.addChange(EmptyValue, source, value);\n        }\n      }\n    }\n  }\n  fixArraysAfterRemovingColumns(sheet, columnStart, numberOfColumns) {\n    this.arrayMapping.moveArrayVerticesAfterColumnByColumns(sheet, columnStart, -numberOfColumns);\n    if (columnStart <= 0) {\n      return;\n    }\n    for (const [, array] of this.arrayMapping.arraysInCols(ColumnsSpan.fromColumnStartAndEnd(sheet, columnStart - 1, columnStart - 1))) {\n      if (this.isThereSpaceForArray(array)) {\n        for (const address of array.getRange().addresses(this)) {\n          this.addressMapping.setCell(address, array);\n        }\n      } else {\n        this.setNoSpaceIfArray(array);\n      }\n    }\n  }\n  shrinkPossibleArrayAndGetCell(address) {\n    const vertex = this.getCell(address);\n    if (!(vertex instanceof ArrayVertex)) {\n      return vertex;\n    }\n    this.setNoSpaceIfArray(vertex);\n    return this.getCell(address);\n  }\n  setNoSpaceIfArray(vertex) {\n    if (vertex instanceof ArrayVertex) {\n      this.shrinkArrayToCorner(vertex);\n      vertex.setNoSpace();\n    }\n  }\n  removeVertex(vertex) {\n    this.removeVertexAndCleanupDependencies(vertex);\n    if (vertex instanceof RangeVertex) {\n      this.rangeMapping.removeRange(vertex);\n    }\n  }\n  mergeRangeVertices(existingVertex, newVertex) {\n    const adjNodesStored = this.graph.adjacentNodes(newVertex);\n    this.removeVertexAndCleanupDependencies(newVertex);\n    this.graph.removeEdgeIfExists(existingVertex, newVertex);\n    adjNodesStored.forEach(adjacentNode => {\n      if (this.graph.hasNode(adjacentNode)) {\n        this.graph.addEdge(existingVertex, adjacentNode);\n      }\n    });\n  }\n  removeVertexAndCleanupDependencies(inputVertex) {\n    const dependencies = new Set(this.graph.removeNode(inputVertex));\n    while (dependencies.size > 0) {\n      const dependency = dependencies.values().next().value;\n      dependencies.delete(dependency);\n      const [address, vertex] = dependency;\n      if (this.graph.hasNode(vertex) && this.graph.adjacentNodesCount(vertex) === 0) {\n        if (vertex instanceof RangeVertex || vertex instanceof EmptyCellVertex) {\n          this.graph.removeNode(vertex).forEach(candidate => dependencies.add(candidate));\n        }\n        if (vertex instanceof RangeVertex) {\n          this.rangeMapping.removeRange(vertex);\n        } else if (vertex instanceof EmptyCellVertex) {\n          this.addressMapping.removeCell(address);\n        }\n      }\n    }\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}