{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { absolutizeDependencies } from \"./absolutizeDependencies.mjs\";\nimport { ArraySize } from \"./ArraySize.mjs\";\nimport { simpleCellAddress } from \"./Cell.mjs\";\nimport { CellContent } from \"./CellContentParser.mjs\";\nimport { ArrayVertex, FormulaCellVertex, ParsingErrorVertex, ValueCellVertex } from \"./DependencyGraph/index.mjs\";\nimport { getRawValue } from \"./interpreter/InterpreterValue.mjs\";\nimport { StatType } from \"./statistics/index.mjs\";\n/**\r\n * Service building the graph and mappings.\r\n */\nexport class GraphBuilder {\n  /**\r\n   * Configures the building service.\r\n   */\n  constructor(dependencyGraph, columnSearch, parser, cellContentParser, stats, arraySizePredictor) {\n    this.dependencyGraph = dependencyGraph;\n    this.columnSearch = columnSearch;\n    this.parser = parser;\n    this.cellContentParser = cellContentParser;\n    this.stats = stats;\n    this.arraySizePredictor = arraySizePredictor;\n    this.buildStrategy = new SimpleStrategy(dependencyGraph, columnSearch, parser, stats, cellContentParser, arraySizePredictor);\n  }\n  /**\r\n   * Builds graph.\r\n   */\n  buildGraph(sheets, stats) {\n    const dependencies = stats.measure(StatType.COLLECT_DEPENDENCIES, () => this.buildStrategy.run(sheets));\n    this.dependencyGraph.getAndClearContentChanges();\n    stats.measure(StatType.PROCESS_DEPENDENCIES, () => this.processDependencies(dependencies));\n  }\n  processDependencies(dependencies) {\n    dependencies.forEach((cellDependencies, endVertex) => {\n      this.dependencyGraph.processCellDependencies(cellDependencies, endVertex);\n    });\n  }\n}\nexport class SimpleStrategy {\n  constructor(dependencyGraph, columnIndex, parser, stats, cellContentParser, arraySizePredictor) {\n    this.dependencyGraph = dependencyGraph;\n    this.columnIndex = columnIndex;\n    this.parser = parser;\n    this.stats = stats;\n    this.cellContentParser = cellContentParser;\n    this.arraySizePredictor = arraySizePredictor;\n  }\n  run(sheets) {\n    const dependencies = new Map();\n    for (const sheetName in sheets) {\n      const sheetId = this.dependencyGraph.getSheetId(sheetName);\n      const sheet = sheets[sheetName];\n      for (let i = 0; i < sheet.length; ++i) {\n        const row = sheet[i];\n        for (let j = 0; j < row.length; ++j) {\n          const cellContent = row[j];\n          const address = simpleCellAddress(sheetId, j, i);\n          const parsedCellContent = this.cellContentParser.parse(cellContent);\n          if (parsedCellContent instanceof CellContent.Formula) {\n            const parseResult = this.stats.measure(StatType.PARSER, () => this.parser.parse(parsedCellContent.formula, address));\n            if (parseResult.errors.length > 0) {\n              this.shrinkArrayIfNeeded(address);\n              const vertex = new ParsingErrorVertex(parseResult.errors, parsedCellContent.formula);\n              this.dependencyGraph.addVertex(address, vertex);\n            } else {\n              this.shrinkArrayIfNeeded(address);\n              const size = this.arraySizePredictor.checkArraySize(parseResult.ast, address);\n              if (size.isScalar()) {\n                const vertex = new FormulaCellVertex(parseResult.ast, address, 0);\n                dependencies.set(vertex, absolutizeDependencies(parseResult.dependencies, address));\n                this.dependencyGraph.addVertex(address, vertex);\n                if (parseResult.hasVolatileFunction) {\n                  this.dependencyGraph.markAsVolatile(vertex);\n                }\n                if (parseResult.hasStructuralChangeFunction) {\n                  this.dependencyGraph.markAsDependentOnStructureChange(vertex);\n                }\n              } else {\n                const vertex = new ArrayVertex(parseResult.ast, address, new ArraySize(size.width, size.height));\n                dependencies.set(vertex, absolutizeDependencies(parseResult.dependencies, address));\n                this.dependencyGraph.addArrayVertex(address, vertex);\n              }\n            }\n          } else if (parsedCellContent instanceof CellContent.Empty) {\n            /* we don't care about empty cells here */\n          } else {\n            this.shrinkArrayIfNeeded(address);\n            const vertex = new ValueCellVertex(parsedCellContent.value, cellContent);\n            this.columnIndex.add(getRawValue(parsedCellContent.value), address);\n            this.dependencyGraph.addVertex(address, vertex);\n          }\n        }\n      }\n    }\n    return dependencies;\n  }\n  shrinkArrayIfNeeded(address) {\n    const vertex = this.dependencyGraph.getCell(address);\n    if (vertex instanceof ArrayVertex) {\n      this.dependencyGraph.shrinkArrayToCorner(vertex);\n    }\n  }\n}","map":{"version":3,"names":["absolutizeDependencies","ArraySize","simpleCellAddress","CellContent","ArrayVertex","FormulaCellVertex","ParsingErrorVertex","ValueCellVertex","getRawValue","StatType","GraphBuilder","constructor","dependencyGraph","columnSearch","parser","cellContentParser","stats","arraySizePredictor","buildStrategy","SimpleStrategy","buildGraph","sheets","dependencies","measure","COLLECT_DEPENDENCIES","run","getAndClearContentChanges","PROCESS_DEPENDENCIES","processDependencies","forEach","cellDependencies","endVertex","processCellDependencies","columnIndex","Map","sheetName","sheetId","getSheetId","sheet","i","length","row","j","cellContent","address","parsedCellContent","parse","Formula","parseResult","PARSER","formula","errors","shrinkArrayIfNeeded","vertex","addVertex","size","checkArraySize","ast","isScalar","set","hasVolatileFunction","markAsVolatile","hasStructuralChangeFunction","markAsDependentOnStructureChange","width","height","addArrayVertex","Empty","value","add","getCell","shrinkArrayToCorner"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/GraphBuilder.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { absolutizeDependencies } from \"./absolutizeDependencies.mjs\";\nimport { ArraySize } from \"./ArraySize.mjs\";\nimport { simpleCellAddress } from \"./Cell.mjs\";\nimport { CellContent } from \"./CellContentParser.mjs\";\nimport { ArrayVertex, FormulaCellVertex, ParsingErrorVertex, ValueCellVertex } from \"./DependencyGraph/index.mjs\";\nimport { getRawValue } from \"./interpreter/InterpreterValue.mjs\";\nimport { StatType } from \"./statistics/index.mjs\";\n/**\r\n * Service building the graph and mappings.\r\n */\nexport class GraphBuilder {\n  /**\r\n   * Configures the building service.\r\n   */\n  constructor(dependencyGraph, columnSearch, parser, cellContentParser, stats, arraySizePredictor) {\n    this.dependencyGraph = dependencyGraph;\n    this.columnSearch = columnSearch;\n    this.parser = parser;\n    this.cellContentParser = cellContentParser;\n    this.stats = stats;\n    this.arraySizePredictor = arraySizePredictor;\n    this.buildStrategy = new SimpleStrategy(dependencyGraph, columnSearch, parser, stats, cellContentParser, arraySizePredictor);\n  }\n  /**\r\n   * Builds graph.\r\n   */\n  buildGraph(sheets, stats) {\n    const dependencies = stats.measure(StatType.COLLECT_DEPENDENCIES, () => this.buildStrategy.run(sheets));\n    this.dependencyGraph.getAndClearContentChanges();\n    stats.measure(StatType.PROCESS_DEPENDENCIES, () => this.processDependencies(dependencies));\n  }\n  processDependencies(dependencies) {\n    dependencies.forEach((cellDependencies, endVertex) => {\n      this.dependencyGraph.processCellDependencies(cellDependencies, endVertex);\n    });\n  }\n}\nexport class SimpleStrategy {\n  constructor(dependencyGraph, columnIndex, parser, stats, cellContentParser, arraySizePredictor) {\n    this.dependencyGraph = dependencyGraph;\n    this.columnIndex = columnIndex;\n    this.parser = parser;\n    this.stats = stats;\n    this.cellContentParser = cellContentParser;\n    this.arraySizePredictor = arraySizePredictor;\n  }\n  run(sheets) {\n    const dependencies = new Map();\n    for (const sheetName in sheets) {\n      const sheetId = this.dependencyGraph.getSheetId(sheetName);\n      const sheet = sheets[sheetName];\n      for (let i = 0; i < sheet.length; ++i) {\n        const row = sheet[i];\n        for (let j = 0; j < row.length; ++j) {\n          const cellContent = row[j];\n          const address = simpleCellAddress(sheetId, j, i);\n          const parsedCellContent = this.cellContentParser.parse(cellContent);\n          if (parsedCellContent instanceof CellContent.Formula) {\n            const parseResult = this.stats.measure(StatType.PARSER, () => this.parser.parse(parsedCellContent.formula, address));\n            if (parseResult.errors.length > 0) {\n              this.shrinkArrayIfNeeded(address);\n              const vertex = new ParsingErrorVertex(parseResult.errors, parsedCellContent.formula);\n              this.dependencyGraph.addVertex(address, vertex);\n            } else {\n              this.shrinkArrayIfNeeded(address);\n              const size = this.arraySizePredictor.checkArraySize(parseResult.ast, address);\n              if (size.isScalar()) {\n                const vertex = new FormulaCellVertex(parseResult.ast, address, 0);\n                dependencies.set(vertex, absolutizeDependencies(parseResult.dependencies, address));\n                this.dependencyGraph.addVertex(address, vertex);\n                if (parseResult.hasVolatileFunction) {\n                  this.dependencyGraph.markAsVolatile(vertex);\n                }\n                if (parseResult.hasStructuralChangeFunction) {\n                  this.dependencyGraph.markAsDependentOnStructureChange(vertex);\n                }\n              } else {\n                const vertex = new ArrayVertex(parseResult.ast, address, new ArraySize(size.width, size.height));\n                dependencies.set(vertex, absolutizeDependencies(parseResult.dependencies, address));\n                this.dependencyGraph.addArrayVertex(address, vertex);\n              }\n            }\n          } else if (parsedCellContent instanceof CellContent.Empty) {\n            /* we don't care about empty cells here */\n          } else {\n            this.shrinkArrayIfNeeded(address);\n            const vertex = new ValueCellVertex(parsedCellContent.value, cellContent);\n            this.columnIndex.add(getRawValue(parsedCellContent.value), address);\n            this.dependencyGraph.addVertex(address, vertex);\n          }\n        }\n      }\n    }\n    return dependencies;\n  }\n  shrinkArrayIfNeeded(address) {\n    const vertex = this.dependencyGraph.getCell(address);\n    if (vertex instanceof ArrayVertex) {\n      this.dependencyGraph.shrinkArrayToCorner(vertex);\n    }\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}