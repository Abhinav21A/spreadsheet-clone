{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { CellError, ErrorType } from \"../../Cell.mjs\";\nimport { FormulaVertex } from \"../../DependencyGraph/FormulaCellVertex.mjs\";\nimport { ErrorMessage } from \"../../error-message.mjs\";\nimport { AstNodeType } from \"../../parser/index.mjs\";\nimport { EmptyValue, isExtendedNumber } from \"../InterpreterValue.mjs\";\nimport { SimpleRangeValue } from \"../../SimpleRangeValue.mjs\";\nimport { FunctionArgumentType, FunctionPlugin } from \"./FunctionPlugin.mjs\";\n/**\r\n * Interpreter plugin containing information functions\r\n */\nexport class InformationPlugin extends FunctionPlugin {\n  /**\r\n   * Corresponds to ISBINARY(value)\r\n   *\r\n   * Returns true if provided value is a valid binary number\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  isbinary(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISBINARY'), arg => /^[01]{1,10}$/.test(arg));\n  }\n  /**\r\n   * Corresponds to ISERR(value)\r\n   *\r\n   * Returns true if provided value is an error except #N/A!\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  iserr(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISERR'), arg => arg instanceof CellError && arg.type !== ErrorType.NA);\n  }\n  /**\r\n   * Corresponds to ISERROR(value)\r\n   *\r\n   * Checks whether provided value is an error\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  iserror(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISERROR'), arg => arg instanceof CellError);\n  }\n  /**\r\n   * Corresponds to ISFORMULA(value)\r\n   *\r\n   * Checks whether referenced cell is a formula\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  isformula(ast, state) {\n    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('ISFORMULA'), () => new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber), reference => {\n      const vertex = this.dependencyGraph.addressMapping.getCell(reference);\n      return vertex instanceof FormulaVertex;\n    });\n  }\n  /**\r\n   * Corresponds to ISBLANK(value)\r\n   *\r\n   * Checks whether provided cell reference is empty\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  isblank(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISBLANK'), arg => arg === EmptyValue);\n  }\n  /**\r\n   * Corresponds to ISNA(value)\r\n   *\r\n   * Returns true if provided value is #N/A! error\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  isna(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISNA'), arg => arg instanceof CellError && arg.type == ErrorType.NA);\n  }\n  /**\r\n   * Corresponds to ISNUMBER(value)\r\n   *\r\n   * Checks whether provided cell reference is a number\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  isnumber(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISNUMBER'), isExtendedNumber);\n  }\n  /**\r\n   * Corresponds to ISLOGICAL(value)\r\n   *\r\n   * Checks whether provided cell reference is of logical type\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  islogical(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISLOGICAL'), arg => typeof arg === 'boolean');\n  }\n  /**\r\n   * Corresponds to ISREF(value)\r\n   *\r\n   * Returns true if provided value is #REF! error\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  isref(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISREF'), arg => arg instanceof CellError && (arg.type == ErrorType.REF || arg.type == ErrorType.CYCLE));\n  }\n  /**\r\n   * Corresponds to ISTEXT(value)\r\n   *\r\n   * Checks whether provided cell reference is of logical type\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  istext(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISTEXT'), arg => typeof arg === 'string');\n  }\n  /**\r\n   * Corresponds to ISNONTEXT(value)\r\n   *\r\n   * Checks whether provided cell reference is of logical type\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  isnontext(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISNONTEXT'), arg => !(typeof arg === 'string'));\n  }\n  /**\r\n   * Corresponds to COLUMN(reference)\r\n   *\r\n   * Returns column number of a reference or a formula cell if reference not provided\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  column(ast, state) {\n    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('COLUMN'), () => state.formulaAddress.col + 1, reference => reference.col + 1);\n  }\n  /**\r\n   * Corresponds to COLUMNS(range)\r\n   *\r\n   * Returns number of columns in provided range of cells\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  columns(ast, state) {\n    if (ast.args.length !== 1) {\n      return new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);\n    }\n    if (ast.args.some(astIt => astIt.type === AstNodeType.EMPTY)) {\n      return new CellError(ErrorType.NUM, ErrorMessage.EmptyArg);\n    }\n    let argAst = ast.args[0];\n    while (argAst.type === AstNodeType.PARENTHESIS) {\n      argAst = argAst.expression;\n    }\n    if (argAst.type === AstNodeType.CELL_RANGE || argAst.type === AstNodeType.COLUMN_RANGE) {\n      return argAst.end.col - argAst.start.col + 1;\n    } else if (argAst.type === AstNodeType.CELL_REFERENCE) {\n      return 1;\n    } else if (argAst.type === AstNodeType.ROW_RANGE) {\n      return this.config.maxColumns;\n    } else {\n      const val = this.evaluateAst(argAst, state);\n      if (val instanceof SimpleRangeValue) {\n        return val.width();\n      } else if (val instanceof CellError) {\n        return val;\n      } else {\n        return 1;\n      }\n    }\n  }\n  /**\r\n   * Corresponds to ROW(reference)\r\n   *\r\n   * Returns row number of a reference or a formula cell if reference not provided\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  row(ast, state) {\n    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('ROW'), () => state.formulaAddress.row + 1, reference => reference.row + 1);\n  }\n  /**\r\n   * Corresponds to ROWS(range)\r\n   *\r\n   * Returns number of rows in provided range of cells\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  rows(ast, state) {\n    if (ast.args.length !== 1) {\n      return new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);\n    }\n    if (ast.args.some(astIt => astIt.type === AstNodeType.EMPTY)) {\n      return new CellError(ErrorType.NUM, ErrorMessage.EmptyArg);\n    }\n    let argAst = ast.args[0];\n    while (argAst.type === AstNodeType.PARENTHESIS) {\n      argAst = argAst.expression;\n    }\n    if (argAst.type === AstNodeType.CELL_RANGE || argAst.type === AstNodeType.ROW_RANGE) {\n      return argAst.end.row - argAst.start.row + 1;\n    } else if (argAst.type === AstNodeType.CELL_REFERENCE) {\n      return 1;\n    } else if (argAst.type === AstNodeType.COLUMN_RANGE) {\n      return this.config.maxRows;\n    } else {\n      const val = this.evaluateAst(argAst, state);\n      if (val instanceof SimpleRangeValue) {\n        return val.height();\n      } else if (val instanceof CellError) {\n        return val;\n      } else {\n        return 1;\n      }\n    }\n  }\n  /**\r\n   * Corresponds to INDEX\r\n   *\r\n   * Returns specific position in 2d array.\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  index(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('INDEX'), (rangeValue, row, col) => {\n      var _a, _b, _c, _d, _e, _f;\n      if (col < 1 || row < 1) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.LessThanOne);\n      }\n      if (col > rangeValue.width() || row > rangeValue.height()) {\n        return new CellError(ErrorType.NUM, ErrorMessage.ValueLarge);\n      }\n      return (_f = (_c = (_b = (_a = rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.data) === null || _a === void 0 ? void 0 : _a[row - 1]) === null || _b === void 0 ? void 0 : _b[col - 1]) !== null && _c !== void 0 ? _c : (_e = (_d = rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.data) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e[0]) !== null && _f !== void 0 ? _f : new CellError(ErrorType.VALUE, ErrorMessage.CellRangeExpected);\n    });\n  }\n  /**\r\n   * Corresponds to NA()\r\n   *\r\n   * Returns #N/A!\r\n   *\r\n   * @param _ast\r\n   * @param _state\r\n   */\n  na(_ast, _state) {\n    return new CellError(ErrorType.NA);\n  }\n  /**\r\n   * Corresponds to SHEET(value)\r\n   *\r\n   * Returns sheet number of a given value or a formula sheet number if no argument is provided\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  sheet(ast, state) {\n    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('SHEET'), () => state.formulaAddress.sheet + 1, reference => reference.sheet + 1, value => {\n      const sheetNumber = this.dependencyGraph.sheetMapping.get(value);\n      if (sheetNumber !== undefined) {\n        return sheetNumber + 1;\n      } else {\n        return new CellError(ErrorType.NA, ErrorMessage.SheetRef);\n      }\n    });\n  }\n  /**\r\n   * Corresponds to SHEETS(value)\r\n   *\r\n   * Returns number of sheet of a given reference or number of all sheets in workbook when no argument is provided.\r\n   * It returns always 1 for a valid reference as 3D references are not supported.\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  sheets(ast, state) {\n    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('SHEETS'), () => this.dependencyGraph.sheetMapping.numberOfSheets(),\n    // return number of sheets if no argument\n    () => 1,\n    // return 1 for valid reference\n    () => new CellError(ErrorType.VALUE, ErrorMessage.CellRefExpected) // error otherwise\n    );\n  }\n}\nInformationPlugin.implementedFunctions = {\n  'COLUMN': {\n    method: 'column',\n    parameters: [{\n      argumentType: FunctionArgumentType.NOERROR,\n      optionalArg: true\n    }],\n    isDependentOnSheetStructureChange: true,\n    doesNotNeedArgumentsToBeComputed: true,\n    vectorizationForbidden: true\n  },\n  'COLUMNS': {\n    method: 'columns',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }],\n    isDependentOnSheetStructureChange: true,\n    doesNotNeedArgumentsToBeComputed: true,\n    vectorizationForbidden: true\n  },\n  'ISBINARY': {\n    method: 'isbinary',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }]\n  },\n  'ISERR': {\n    method: 'iserr',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }]\n  },\n  'ISFORMULA': {\n    method: 'isformula',\n    parameters: [{\n      argumentType: FunctionArgumentType.NOERROR\n    }],\n    doesNotNeedArgumentsToBeComputed: true,\n    vectorizationForbidden: true\n  },\n  'ISNA': {\n    method: 'isna',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }]\n  },\n  'ISREF': {\n    method: 'isref',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }],\n    vectorizationForbidden: true\n  },\n  'ISERROR': {\n    method: 'iserror',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }]\n  },\n  'ISBLANK': {\n    method: 'isblank',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }]\n  },\n  'ISNUMBER': {\n    method: 'isnumber',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }]\n  },\n  'ISLOGICAL': {\n    method: 'islogical',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }]\n  },\n  'ISTEXT': {\n    method: 'istext',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }]\n  },\n  'ISNONTEXT': {\n    method: 'isnontext',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }]\n  },\n  'INDEX': {\n    method: 'index',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 1\n    }]\n  },\n  'NA': {\n    method: 'na',\n    parameters: []\n  },\n  'ROW': {\n    method: 'row',\n    parameters: [{\n      argumentType: FunctionArgumentType.NOERROR,\n      optionalArg: true\n    }],\n    isDependentOnSheetStructureChange: true,\n    doesNotNeedArgumentsToBeComputed: true,\n    vectorizationForbidden: true\n  },\n  'ROWS': {\n    method: 'rows',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }],\n    isDependentOnSheetStructureChange: true,\n    doesNotNeedArgumentsToBeComputed: true,\n    vectorizationForbidden: true\n  },\n  'SHEET': {\n    method: 'sheet',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }],\n    doesNotNeedArgumentsToBeComputed: true,\n    vectorizationForbidden: true\n  },\n  'SHEETS': {\n    method: 'sheets',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }],\n    doesNotNeedArgumentsToBeComputed: true,\n    vectorizationForbidden: true\n  }\n};","map":{"version":3,"names":["CellError","ErrorType","FormulaVertex","ErrorMessage","AstNodeType","EmptyValue","isExtendedNumber","SimpleRangeValue","FunctionArgumentType","FunctionPlugin","InformationPlugin","isbinary","ast","state","runFunction","args","metadata","arg","test","iserr","type","NA","iserror","isformula","runFunctionWithReferenceArgument","WrongArgNumber","reference","vertex","dependencyGraph","addressMapping","getCell","isblank","isna","isnumber","islogical","isref","REF","CYCLE","istext","isnontext","column","formulaAddress","col","columns","length","some","astIt","EMPTY","NUM","EmptyArg","argAst","PARENTHESIS","expression","CELL_RANGE","COLUMN_RANGE","end","start","CELL_REFERENCE","ROW_RANGE","config","maxColumns","val","evaluateAst","width","row","rows","maxRows","height","index","rangeValue","_a","_b","_c","_d","_e","_f","VALUE","LessThanOne","ValueLarge","data","CellRangeExpected","na","_ast","_state","sheet","value","sheetNumber","sheetMapping","get","undefined","SheetRef","sheets","numberOfSheets","CellRefExpected","implementedFunctions","method","parameters","argumentType","NOERROR","optionalArg","isDependentOnSheetStructureChange","doesNotNeedArgumentsToBeComputed","vectorizationForbidden","RANGE","STRING","SCALAR","NUMBER","defaultValue"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/interpreter/plugin/InformationPlugin.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { CellError, ErrorType } from \"../../Cell.mjs\";\nimport { FormulaVertex } from \"../../DependencyGraph/FormulaCellVertex.mjs\";\nimport { ErrorMessage } from \"../../error-message.mjs\";\nimport { AstNodeType } from \"../../parser/index.mjs\";\nimport { EmptyValue, isExtendedNumber } from \"../InterpreterValue.mjs\";\nimport { SimpleRangeValue } from \"../../SimpleRangeValue.mjs\";\nimport { FunctionArgumentType, FunctionPlugin } from \"./FunctionPlugin.mjs\";\n/**\r\n * Interpreter plugin containing information functions\r\n */\nexport class InformationPlugin extends FunctionPlugin {\n  /**\r\n   * Corresponds to ISBINARY(value)\r\n   *\r\n   * Returns true if provided value is a valid binary number\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  isbinary(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISBINARY'), arg => /^[01]{1,10}$/.test(arg));\n  }\n  /**\r\n   * Corresponds to ISERR(value)\r\n   *\r\n   * Returns true if provided value is an error except #N/A!\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  iserr(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISERR'), arg => arg instanceof CellError && arg.type !== ErrorType.NA);\n  }\n  /**\r\n   * Corresponds to ISERROR(value)\r\n   *\r\n   * Checks whether provided value is an error\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  iserror(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISERROR'), arg => arg instanceof CellError);\n  }\n  /**\r\n   * Corresponds to ISFORMULA(value)\r\n   *\r\n   * Checks whether referenced cell is a formula\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  isformula(ast, state) {\n    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('ISFORMULA'), () => new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber), reference => {\n      const vertex = this.dependencyGraph.addressMapping.getCell(reference);\n      return vertex instanceof FormulaVertex;\n    });\n  }\n  /**\r\n   * Corresponds to ISBLANK(value)\r\n   *\r\n   * Checks whether provided cell reference is empty\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  isblank(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISBLANK'), arg => arg === EmptyValue);\n  }\n  /**\r\n   * Corresponds to ISNA(value)\r\n   *\r\n   * Returns true if provided value is #N/A! error\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  isna(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISNA'), arg => arg instanceof CellError && arg.type == ErrorType.NA);\n  }\n  /**\r\n   * Corresponds to ISNUMBER(value)\r\n   *\r\n   * Checks whether provided cell reference is a number\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  isnumber(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISNUMBER'), isExtendedNumber);\n  }\n  /**\r\n   * Corresponds to ISLOGICAL(value)\r\n   *\r\n   * Checks whether provided cell reference is of logical type\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  islogical(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISLOGICAL'), arg => typeof arg === 'boolean');\n  }\n  /**\r\n   * Corresponds to ISREF(value)\r\n   *\r\n   * Returns true if provided value is #REF! error\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  isref(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISREF'), arg => arg instanceof CellError && (arg.type == ErrorType.REF || arg.type == ErrorType.CYCLE));\n  }\n  /**\r\n   * Corresponds to ISTEXT(value)\r\n   *\r\n   * Checks whether provided cell reference is of logical type\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  istext(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISTEXT'), arg => typeof arg === 'string');\n  }\n  /**\r\n   * Corresponds to ISNONTEXT(value)\r\n   *\r\n   * Checks whether provided cell reference is of logical type\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  isnontext(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISNONTEXT'), arg => !(typeof arg === 'string'));\n  }\n  /**\r\n   * Corresponds to COLUMN(reference)\r\n   *\r\n   * Returns column number of a reference or a formula cell if reference not provided\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  column(ast, state) {\n    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('COLUMN'), () => state.formulaAddress.col + 1, reference => reference.col + 1);\n  }\n  /**\r\n   * Corresponds to COLUMNS(range)\r\n   *\r\n   * Returns number of columns in provided range of cells\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  columns(ast, state) {\n    if (ast.args.length !== 1) {\n      return new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);\n    }\n    if (ast.args.some(astIt => astIt.type === AstNodeType.EMPTY)) {\n      return new CellError(ErrorType.NUM, ErrorMessage.EmptyArg);\n    }\n    let argAst = ast.args[0];\n    while (argAst.type === AstNodeType.PARENTHESIS) {\n      argAst = argAst.expression;\n    }\n    if (argAst.type === AstNodeType.CELL_RANGE || argAst.type === AstNodeType.COLUMN_RANGE) {\n      return argAst.end.col - argAst.start.col + 1;\n    } else if (argAst.type === AstNodeType.CELL_REFERENCE) {\n      return 1;\n    } else if (argAst.type === AstNodeType.ROW_RANGE) {\n      return this.config.maxColumns;\n    } else {\n      const val = this.evaluateAst(argAst, state);\n      if (val instanceof SimpleRangeValue) {\n        return val.width();\n      } else if (val instanceof CellError) {\n        return val;\n      } else {\n        return 1;\n      }\n    }\n  }\n  /**\r\n   * Corresponds to ROW(reference)\r\n   *\r\n   * Returns row number of a reference or a formula cell if reference not provided\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  row(ast, state) {\n    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('ROW'), () => state.formulaAddress.row + 1, reference => reference.row + 1);\n  }\n  /**\r\n   * Corresponds to ROWS(range)\r\n   *\r\n   * Returns number of rows in provided range of cells\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  rows(ast, state) {\n    if (ast.args.length !== 1) {\n      return new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);\n    }\n    if (ast.args.some(astIt => astIt.type === AstNodeType.EMPTY)) {\n      return new CellError(ErrorType.NUM, ErrorMessage.EmptyArg);\n    }\n    let argAst = ast.args[0];\n    while (argAst.type === AstNodeType.PARENTHESIS) {\n      argAst = argAst.expression;\n    }\n    if (argAst.type === AstNodeType.CELL_RANGE || argAst.type === AstNodeType.ROW_RANGE) {\n      return argAst.end.row - argAst.start.row + 1;\n    } else if (argAst.type === AstNodeType.CELL_REFERENCE) {\n      return 1;\n    } else if (argAst.type === AstNodeType.COLUMN_RANGE) {\n      return this.config.maxRows;\n    } else {\n      const val = this.evaluateAst(argAst, state);\n      if (val instanceof SimpleRangeValue) {\n        return val.height();\n      } else if (val instanceof CellError) {\n        return val;\n      } else {\n        return 1;\n      }\n    }\n  }\n  /**\r\n   * Corresponds to INDEX\r\n   *\r\n   * Returns specific position in 2d array.\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  index(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('INDEX'), (rangeValue, row, col) => {\n      var _a, _b, _c, _d, _e, _f;\n      if (col < 1 || row < 1) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.LessThanOne);\n      }\n      if (col > rangeValue.width() || row > rangeValue.height()) {\n        return new CellError(ErrorType.NUM, ErrorMessage.ValueLarge);\n      }\n      return (_f = (_c = (_b = (_a = rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.data) === null || _a === void 0 ? void 0 : _a[row - 1]) === null || _b === void 0 ? void 0 : _b[col - 1]) !== null && _c !== void 0 ? _c : (_e = (_d = rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.data) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e[0]) !== null && _f !== void 0 ? _f : new CellError(ErrorType.VALUE, ErrorMessage.CellRangeExpected);\n    });\n  }\n  /**\r\n   * Corresponds to NA()\r\n   *\r\n   * Returns #N/A!\r\n   *\r\n   * @param _ast\r\n   * @param _state\r\n   */\n  na(_ast, _state) {\n    return new CellError(ErrorType.NA);\n  }\n  /**\r\n   * Corresponds to SHEET(value)\r\n   *\r\n   * Returns sheet number of a given value or a formula sheet number if no argument is provided\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  sheet(ast, state) {\n    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('SHEET'), () => state.formulaAddress.sheet + 1, reference => reference.sheet + 1, value => {\n      const sheetNumber = this.dependencyGraph.sheetMapping.get(value);\n      if (sheetNumber !== undefined) {\n        return sheetNumber + 1;\n      } else {\n        return new CellError(ErrorType.NA, ErrorMessage.SheetRef);\n      }\n    });\n  }\n  /**\r\n   * Corresponds to SHEETS(value)\r\n   *\r\n   * Returns number of sheet of a given reference or number of all sheets in workbook when no argument is provided.\r\n   * It returns always 1 for a valid reference as 3D references are not supported.\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  sheets(ast, state) {\n    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('SHEETS'), () => this.dependencyGraph.sheetMapping.numberOfSheets(),\n    // return number of sheets if no argument\n    () => 1,\n    // return 1 for valid reference\n    () => new CellError(ErrorType.VALUE, ErrorMessage.CellRefExpected) // error otherwise\n    );\n  }\n}\nInformationPlugin.implementedFunctions = {\n  'COLUMN': {\n    method: 'column',\n    parameters: [{\n      argumentType: FunctionArgumentType.NOERROR,\n      optionalArg: true\n    }],\n    isDependentOnSheetStructureChange: true,\n    doesNotNeedArgumentsToBeComputed: true,\n    vectorizationForbidden: true\n  },\n  'COLUMNS': {\n    method: 'columns',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }],\n    isDependentOnSheetStructureChange: true,\n    doesNotNeedArgumentsToBeComputed: true,\n    vectorizationForbidden: true\n  },\n  'ISBINARY': {\n    method: 'isbinary',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }]\n  },\n  'ISERR': {\n    method: 'iserr',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }]\n  },\n  'ISFORMULA': {\n    method: 'isformula',\n    parameters: [{\n      argumentType: FunctionArgumentType.NOERROR\n    }],\n    doesNotNeedArgumentsToBeComputed: true,\n    vectorizationForbidden: true\n  },\n  'ISNA': {\n    method: 'isna',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }]\n  },\n  'ISREF': {\n    method: 'isref',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }],\n    vectorizationForbidden: true\n  },\n  'ISERROR': {\n    method: 'iserror',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }]\n  },\n  'ISBLANK': {\n    method: 'isblank',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }]\n  },\n  'ISNUMBER': {\n    method: 'isnumber',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }]\n  },\n  'ISLOGICAL': {\n    method: 'islogical',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }]\n  },\n  'ISTEXT': {\n    method: 'istext',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }]\n  },\n  'ISNONTEXT': {\n    method: 'isnontext',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }]\n  },\n  'INDEX': {\n    method: 'index',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 1\n    }]\n  },\n  'NA': {\n    method: 'na',\n    parameters: []\n  },\n  'ROW': {\n    method: 'row',\n    parameters: [{\n      argumentType: FunctionArgumentType.NOERROR,\n      optionalArg: true\n    }],\n    isDependentOnSheetStructureChange: true,\n    doesNotNeedArgumentsToBeComputed: true,\n    vectorizationForbidden: true\n  },\n  'ROWS': {\n    method: 'rows',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }],\n    isDependentOnSheetStructureChange: true,\n    doesNotNeedArgumentsToBeComputed: true,\n    vectorizationForbidden: true\n  },\n  'SHEET': {\n    method: 'sheet',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }],\n    doesNotNeedArgumentsToBeComputed: true,\n    vectorizationForbidden: true\n  },\n  'SHEETS': {\n    method: 'sheets',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }],\n    doesNotNeedArgumentsToBeComputed: true,\n    vectorizationForbidden: true\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}