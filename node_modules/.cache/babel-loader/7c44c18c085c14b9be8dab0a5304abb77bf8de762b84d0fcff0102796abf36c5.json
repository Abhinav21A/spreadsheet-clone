{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AliasAlreadyExisting, FunctionPluginValidationError, ProtectedFunctionError } from \"../errors.mjs\";\nimport { HyperFormula } from \"../HyperFormula.mjs\";\nimport { VersionPlugin } from \"./plugin/VersionPlugin.mjs\";\nfunction validateAndReturnMetadataFromName(functionId, plugin) {\n  var _a;\n  let entry = plugin.implementedFunctions[functionId];\n  const key = (_a = plugin.aliases) === null || _a === void 0 ? void 0 : _a[functionId];\n  if (key !== undefined) {\n    if (entry !== undefined) {\n      throw new AliasAlreadyExisting(functionId, plugin.name);\n    }\n    entry = plugin.implementedFunctions[key];\n  }\n  if (entry === undefined) {\n    throw FunctionPluginValidationError.functionNotDeclaredInPlugin(functionId, plugin.name);\n  }\n  return entry;\n}\nexport class FunctionRegistry {\n  constructor(config) {\n    this.config = config;\n    this.functions = new Map();\n    this.arraySizeFunctions = new Map();\n    this.volatileFunctions = new Set();\n    this.arrayFunctions = new Set();\n    this.structuralChangeFunctions = new Set();\n    this.functionsWhichDoesNotNeedArgumentsToBeComputed = new Set();\n    this.functionsMetadata = new Map();\n    this.doesFunctionNeedArgumentToBeComputed = functionId => this.functionsWhichDoesNotNeedArgumentsToBeComputed.has(functionId);\n    this.isFunctionVolatile = functionId => this.volatileFunctions.has(functionId);\n    this.isArrayFunction = functionId => this.arrayFunctions.has(functionId);\n    this.isFunctionDependentOnSheetStructureChange = functionId => this.structuralChangeFunctions.has(functionId);\n    if (config.functionPlugins.length > 0) {\n      this.instancePlugins = new Map();\n      for (const plugin of config.functionPlugins) {\n        FunctionRegistry.loadPluginFunctions(plugin, this.instancePlugins);\n      }\n    } else {\n      this.instancePlugins = new Map(FunctionRegistry.plugins);\n    }\n    for (const [functionId, plugin] of FunctionRegistry.protectedFunctions()) {\n      FunctionRegistry.loadFunctionUnprotected(plugin, functionId, this.instancePlugins);\n    }\n    for (const [functionId, plugin] of this.instancePlugins.entries()) {\n      this.categorizeFunction(functionId, validateAndReturnMetadataFromName(functionId, plugin));\n    }\n  }\n  static registerFunctionPlugin(plugin, translations) {\n    this.loadPluginFunctions(plugin, this.plugins);\n    if (translations !== undefined) {\n      this.loadTranslations(translations);\n    }\n  }\n  static registerFunction(functionId, plugin, translations) {\n    this.loadPluginFunction(plugin, functionId, this.plugins);\n    if (translations !== undefined) {\n      this.loadTranslations(translations);\n    }\n  }\n  static unregisterFunction(functionId) {\n    if (this.functionIsProtected(functionId)) {\n      throw ProtectedFunctionError.cannotUnregisterFunctionWithId(functionId);\n    }\n    this.plugins.delete(functionId);\n  }\n  static unregisterFunctionPlugin(plugin) {\n    for (const protectedPlugin of this.protectedPlugins()) {\n      if (protectedPlugin === plugin) {\n        throw ProtectedFunctionError.cannotUnregisterProtectedPlugin();\n      }\n    }\n    for (const [functionId, registeredPlugin] of this.plugins.entries()) {\n      if (registeredPlugin === plugin) {\n        this.plugins.delete(functionId);\n      }\n    }\n  }\n  static unregisterAll() {\n    this.plugins.clear();\n  }\n  static getRegisteredFunctionIds() {\n    return [...Array.from(this.plugins.keys()), ...Array.from(this._protectedPlugins.keys())];\n  }\n  static getPlugins() {\n    return Array.from(new Set(this.plugins.values()).values());\n  }\n  static getFunctionPlugin(functionId) {\n    if (this.functionIsProtected(functionId)) {\n      return undefined;\n    } else {\n      return this.plugins.get(functionId);\n    }\n  }\n  static functionIsProtected(functionId) {\n    return this._protectedPlugins.has(functionId);\n  }\n  static loadTranslations(translations) {\n    const registeredLanguages = new Set(HyperFormula.getRegisteredLanguagesCodes());\n    Object.keys(translations).forEach(code => {\n      if (registeredLanguages.has(code)) {\n        HyperFormula.getLanguage(code).extendFunctions(translations[code]);\n      }\n    });\n  }\n  static loadPluginFunctions(plugin, registry) {\n    Object.keys(plugin.implementedFunctions).forEach(functionName => {\n      this.loadPluginFunction(plugin, functionName, registry);\n    });\n    if (plugin.aliases !== undefined) {\n      Object.keys(plugin.aliases).forEach(functionName => {\n        this.loadPluginFunction(plugin, functionName, registry);\n      });\n    }\n  }\n  static loadPluginFunction(plugin, functionId, registry) {\n    if (this.functionIsProtected(functionId)) {\n      throw ProtectedFunctionError.cannotRegisterFunctionWithId(functionId);\n    } else {\n      this.loadFunctionUnprotected(plugin, functionId, registry);\n    }\n  }\n  static loadFunctionUnprotected(plugin, functionId, registry) {\n    const methodName = validateAndReturnMetadataFromName(functionId, plugin).method;\n    if (Object.prototype.hasOwnProperty.call(plugin.prototype, methodName)) {\n      registry.set(functionId, plugin);\n    } else {\n      throw FunctionPluginValidationError.functionMethodNotFound(methodName, plugin.name);\n    }\n  }\n  static *protectedFunctions() {\n    for (const [functionId, plugin] of this._protectedPlugins) {\n      if (plugin !== undefined) {\n        yield [functionId, plugin];\n      }\n    }\n  }\n  static *protectedPlugins() {\n    for (const [, plugin] of this._protectedPlugins) {\n      if (plugin !== undefined) {\n        yield plugin;\n      }\n    }\n  }\n  initializePlugins(interpreter) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const instances = [];\n    for (const [functionId, plugin] of this.instancePlugins.entries()) {\n      let foundPluginInstance = instances.find(pluginInstance => pluginInstance instanceof plugin);\n      if (foundPluginInstance === undefined) {\n        foundPluginInstance = new plugin(interpreter);\n        instances.push(foundPluginInstance);\n      }\n      const metadata = validateAndReturnMetadataFromName(functionId, plugin);\n      const methodName = metadata.method;\n      this.functions.set(functionId, [methodName, foundPluginInstance]);\n      const arraySizeMethodName = metadata.arraySizeMethod;\n      if (arraySizeMethodName !== undefined) {\n        this.arraySizeFunctions.set(functionId, [arraySizeMethodName, foundPluginInstance]);\n      }\n    }\n  }\n  getFunctionPlugin(functionId) {\n    if (FunctionRegistry.functionIsProtected(functionId)) {\n      return undefined;\n    }\n    return this.instancePlugins.get(functionId);\n  }\n  getFunction(functionId) {\n    const pluginEntry = this.functions.get(functionId);\n    if (pluginEntry !== undefined && this.config.translationPackage.isFunctionTranslated(functionId)) {\n      const [pluginFunction, pluginInstance] = pluginEntry;\n      return (ast, state) => pluginInstance[pluginFunction](ast, state);\n    } else {\n      return undefined;\n    }\n  }\n  getArraySizeFunction(functionId) {\n    const pluginEntry = this.arraySizeFunctions.get(functionId);\n    if (pluginEntry !== undefined && this.config.translationPackage.isFunctionTranslated(functionId)) {\n      const [pluginArraySizeFunction, pluginInstance] = pluginEntry;\n      return (ast, state) => pluginInstance[pluginArraySizeFunction](ast, state);\n    } else {\n      return undefined;\n    }\n  }\n  getMetadata(functionId) {\n    return this.functionsMetadata.get(functionId);\n  }\n  getPlugins() {\n    const plugins = new Set();\n    for (const [functionId, plugin] of this.instancePlugins) {\n      if (!FunctionRegistry.functionIsProtected(functionId)) {\n        plugins.add(plugin);\n      }\n    }\n    return Array.from(plugins);\n  }\n  getRegisteredFunctionIds() {\n    return Array.from(this.functions.keys());\n  }\n  categorizeFunction(functionId, functionMetadata) {\n    if (functionMetadata.isVolatile) {\n      this.volatileFunctions.add(functionId);\n    }\n    if (functionMetadata.arrayFunction) {\n      this.arrayFunctions.add(functionId);\n    }\n    if (functionMetadata.doesNotNeedArgumentsToBeComputed) {\n      this.functionsWhichDoesNotNeedArgumentsToBeComputed.add(functionId);\n    }\n    if (functionMetadata.isDependentOnSheetStructureChange) {\n      this.structuralChangeFunctions.add(functionId);\n    }\n    this.functionsMetadata.set(functionId, functionMetadata);\n  }\n}\nFunctionRegistry.plugins = new Map();\nFunctionRegistry._protectedPlugins = new Map([['VERSION', VersionPlugin], ['OFFSET', undefined]]);","map":{"version":3,"names":["AliasAlreadyExisting","FunctionPluginValidationError","ProtectedFunctionError","HyperFormula","VersionPlugin","validateAndReturnMetadataFromName","functionId","plugin","_a","entry","implementedFunctions","key","aliases","undefined","name","functionNotDeclaredInPlugin","FunctionRegistry","constructor","config","functions","Map","arraySizeFunctions","volatileFunctions","Set","arrayFunctions","structuralChangeFunctions","functionsWhichDoesNotNeedArgumentsToBeComputed","functionsMetadata","doesFunctionNeedArgumentToBeComputed","has","isFunctionVolatile","isArrayFunction","isFunctionDependentOnSheetStructureChange","functionPlugins","length","instancePlugins","loadPluginFunctions","plugins","protectedFunctions","loadFunctionUnprotected","entries","categorizeFunction","registerFunctionPlugin","translations","loadTranslations","registerFunction","loadPluginFunction","unregisterFunction","functionIsProtected","cannotUnregisterFunctionWithId","delete","unregisterFunctionPlugin","protectedPlugin","protectedPlugins","cannotUnregisterProtectedPlugin","registeredPlugin","unregisterAll","clear","getRegisteredFunctionIds","Array","from","keys","_protectedPlugins","getPlugins","values","getFunctionPlugin","get","registeredLanguages","getRegisteredLanguagesCodes","Object","forEach","code","getLanguage","extendFunctions","registry","functionName","cannotRegisterFunctionWithId","methodName","method","prototype","hasOwnProperty","call","set","functionMethodNotFound","initializePlugins","interpreter","instances","foundPluginInstance","find","pluginInstance","push","metadata","arraySizeMethodName","arraySizeMethod","getFunction","pluginEntry","translationPackage","isFunctionTranslated","pluginFunction","ast","state","getArraySizeFunction","pluginArraySizeFunction","getMetadata","add","functionMetadata","isVolatile","arrayFunction","doesNotNeedArgumentsToBeComputed","isDependentOnSheetStructureChange"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/interpreter/FunctionRegistry.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AliasAlreadyExisting, FunctionPluginValidationError, ProtectedFunctionError } from \"../errors.mjs\";\nimport { HyperFormula } from \"../HyperFormula.mjs\";\nimport { VersionPlugin } from \"./plugin/VersionPlugin.mjs\";\nfunction validateAndReturnMetadataFromName(functionId, plugin) {\n  var _a;\n  let entry = plugin.implementedFunctions[functionId];\n  const key = (_a = plugin.aliases) === null || _a === void 0 ? void 0 : _a[functionId];\n  if (key !== undefined) {\n    if (entry !== undefined) {\n      throw new AliasAlreadyExisting(functionId, plugin.name);\n    }\n    entry = plugin.implementedFunctions[key];\n  }\n  if (entry === undefined) {\n    throw FunctionPluginValidationError.functionNotDeclaredInPlugin(functionId, plugin.name);\n  }\n  return entry;\n}\nexport class FunctionRegistry {\n  constructor(config) {\n    this.config = config;\n    this.functions = new Map();\n    this.arraySizeFunctions = new Map();\n    this.volatileFunctions = new Set();\n    this.arrayFunctions = new Set();\n    this.structuralChangeFunctions = new Set();\n    this.functionsWhichDoesNotNeedArgumentsToBeComputed = new Set();\n    this.functionsMetadata = new Map();\n    this.doesFunctionNeedArgumentToBeComputed = functionId => this.functionsWhichDoesNotNeedArgumentsToBeComputed.has(functionId);\n    this.isFunctionVolatile = functionId => this.volatileFunctions.has(functionId);\n    this.isArrayFunction = functionId => this.arrayFunctions.has(functionId);\n    this.isFunctionDependentOnSheetStructureChange = functionId => this.structuralChangeFunctions.has(functionId);\n    if (config.functionPlugins.length > 0) {\n      this.instancePlugins = new Map();\n      for (const plugin of config.functionPlugins) {\n        FunctionRegistry.loadPluginFunctions(plugin, this.instancePlugins);\n      }\n    } else {\n      this.instancePlugins = new Map(FunctionRegistry.plugins);\n    }\n    for (const [functionId, plugin] of FunctionRegistry.protectedFunctions()) {\n      FunctionRegistry.loadFunctionUnprotected(plugin, functionId, this.instancePlugins);\n    }\n    for (const [functionId, plugin] of this.instancePlugins.entries()) {\n      this.categorizeFunction(functionId, validateAndReturnMetadataFromName(functionId, plugin));\n    }\n  }\n  static registerFunctionPlugin(plugin, translations) {\n    this.loadPluginFunctions(plugin, this.plugins);\n    if (translations !== undefined) {\n      this.loadTranslations(translations);\n    }\n  }\n  static registerFunction(functionId, plugin, translations) {\n    this.loadPluginFunction(plugin, functionId, this.plugins);\n    if (translations !== undefined) {\n      this.loadTranslations(translations);\n    }\n  }\n  static unregisterFunction(functionId) {\n    if (this.functionIsProtected(functionId)) {\n      throw ProtectedFunctionError.cannotUnregisterFunctionWithId(functionId);\n    }\n    this.plugins.delete(functionId);\n  }\n  static unregisterFunctionPlugin(plugin) {\n    for (const protectedPlugin of this.protectedPlugins()) {\n      if (protectedPlugin === plugin) {\n        throw ProtectedFunctionError.cannotUnregisterProtectedPlugin();\n      }\n    }\n    for (const [functionId, registeredPlugin] of this.plugins.entries()) {\n      if (registeredPlugin === plugin) {\n        this.plugins.delete(functionId);\n      }\n    }\n  }\n  static unregisterAll() {\n    this.plugins.clear();\n  }\n  static getRegisteredFunctionIds() {\n    return [...Array.from(this.plugins.keys()), ...Array.from(this._protectedPlugins.keys())];\n  }\n  static getPlugins() {\n    return Array.from(new Set(this.plugins.values()).values());\n  }\n  static getFunctionPlugin(functionId) {\n    if (this.functionIsProtected(functionId)) {\n      return undefined;\n    } else {\n      return this.plugins.get(functionId);\n    }\n  }\n  static functionIsProtected(functionId) {\n    return this._protectedPlugins.has(functionId);\n  }\n  static loadTranslations(translations) {\n    const registeredLanguages = new Set(HyperFormula.getRegisteredLanguagesCodes());\n    Object.keys(translations).forEach(code => {\n      if (registeredLanguages.has(code)) {\n        HyperFormula.getLanguage(code).extendFunctions(translations[code]);\n      }\n    });\n  }\n  static loadPluginFunctions(plugin, registry) {\n    Object.keys(plugin.implementedFunctions).forEach(functionName => {\n      this.loadPluginFunction(plugin, functionName, registry);\n    });\n    if (plugin.aliases !== undefined) {\n      Object.keys(plugin.aliases).forEach(functionName => {\n        this.loadPluginFunction(plugin, functionName, registry);\n      });\n    }\n  }\n  static loadPluginFunction(plugin, functionId, registry) {\n    if (this.functionIsProtected(functionId)) {\n      throw ProtectedFunctionError.cannotRegisterFunctionWithId(functionId);\n    } else {\n      this.loadFunctionUnprotected(plugin, functionId, registry);\n    }\n  }\n  static loadFunctionUnprotected(plugin, functionId, registry) {\n    const methodName = validateAndReturnMetadataFromName(functionId, plugin).method;\n    if (Object.prototype.hasOwnProperty.call(plugin.prototype, methodName)) {\n      registry.set(functionId, plugin);\n    } else {\n      throw FunctionPluginValidationError.functionMethodNotFound(methodName, plugin.name);\n    }\n  }\n  static *protectedFunctions() {\n    for (const [functionId, plugin] of this._protectedPlugins) {\n      if (plugin !== undefined) {\n        yield [functionId, plugin];\n      }\n    }\n  }\n  static *protectedPlugins() {\n    for (const [, plugin] of this._protectedPlugins) {\n      if (plugin !== undefined) {\n        yield plugin;\n      }\n    }\n  }\n  initializePlugins(interpreter) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const instances = [];\n    for (const [functionId, plugin] of this.instancePlugins.entries()) {\n      let foundPluginInstance = instances.find(pluginInstance => pluginInstance instanceof plugin);\n      if (foundPluginInstance === undefined) {\n        foundPluginInstance = new plugin(interpreter);\n        instances.push(foundPluginInstance);\n      }\n      const metadata = validateAndReturnMetadataFromName(functionId, plugin);\n      const methodName = metadata.method;\n      this.functions.set(functionId, [methodName, foundPluginInstance]);\n      const arraySizeMethodName = metadata.arraySizeMethod;\n      if (arraySizeMethodName !== undefined) {\n        this.arraySizeFunctions.set(functionId, [arraySizeMethodName, foundPluginInstance]);\n      }\n    }\n  }\n  getFunctionPlugin(functionId) {\n    if (FunctionRegistry.functionIsProtected(functionId)) {\n      return undefined;\n    }\n    return this.instancePlugins.get(functionId);\n  }\n  getFunction(functionId) {\n    const pluginEntry = this.functions.get(functionId);\n    if (pluginEntry !== undefined && this.config.translationPackage.isFunctionTranslated(functionId)) {\n      const [pluginFunction, pluginInstance] = pluginEntry;\n      return (ast, state) => pluginInstance[pluginFunction](ast, state);\n    } else {\n      return undefined;\n    }\n  }\n  getArraySizeFunction(functionId) {\n    const pluginEntry = this.arraySizeFunctions.get(functionId);\n    if (pluginEntry !== undefined && this.config.translationPackage.isFunctionTranslated(functionId)) {\n      const [pluginArraySizeFunction, pluginInstance] = pluginEntry;\n      return (ast, state) => pluginInstance[pluginArraySizeFunction](ast, state);\n    } else {\n      return undefined;\n    }\n  }\n  getMetadata(functionId) {\n    return this.functionsMetadata.get(functionId);\n  }\n  getPlugins() {\n    const plugins = new Set();\n    for (const [functionId, plugin] of this.instancePlugins) {\n      if (!FunctionRegistry.functionIsProtected(functionId)) {\n        plugins.add(plugin);\n      }\n    }\n    return Array.from(plugins);\n  }\n  getRegisteredFunctionIds() {\n    return Array.from(this.functions.keys());\n  }\n  categorizeFunction(functionId, functionMetadata) {\n    if (functionMetadata.isVolatile) {\n      this.volatileFunctions.add(functionId);\n    }\n    if (functionMetadata.arrayFunction) {\n      this.arrayFunctions.add(functionId);\n    }\n    if (functionMetadata.doesNotNeedArgumentsToBeComputed) {\n      this.functionsWhichDoesNotNeedArgumentsToBeComputed.add(functionId);\n    }\n    if (functionMetadata.isDependentOnSheetStructureChange) {\n      this.structuralChangeFunctions.add(functionId);\n    }\n    this.functionsMetadata.set(functionId, functionMetadata);\n  }\n}\nFunctionRegistry.plugins = new Map();\nFunctionRegistry._protectedPlugins = new Map([['VERSION', VersionPlugin], ['OFFSET', undefined]]);"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,oBAAoB,EAAEC,6BAA6B,EAAEC,sBAAsB,QAAQ,eAAe;AAC3G,SAASC,YAAY,QAAQ,qBAAqB;AAClD,SAASC,aAAa,QAAQ,4BAA4B;AAC1D,SAASC,iCAAiCA,CAACC,UAAU,EAAEC,MAAM,EAAE;EAC7D,IAAIC,EAAE;EACN,IAAIC,KAAK,GAAGF,MAAM,CAACG,oBAAoB,CAACJ,UAAU,CAAC;EACnD,MAAMK,GAAG,GAAG,CAACH,EAAE,GAAGD,MAAM,CAACK,OAAO,MAAM,IAAI,IAAIJ,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACF,UAAU,CAAC;EACrF,IAAIK,GAAG,KAAKE,SAAS,EAAE;IACrB,IAAIJ,KAAK,KAAKI,SAAS,EAAE;MACvB,MAAM,IAAIb,oBAAoB,CAACM,UAAU,EAAEC,MAAM,CAACO,IAAI,CAAC;IACzD;IACAL,KAAK,GAAGF,MAAM,CAACG,oBAAoB,CAACC,GAAG,CAAC;EAC1C;EACA,IAAIF,KAAK,KAAKI,SAAS,EAAE;IACvB,MAAMZ,6BAA6B,CAACc,2BAA2B,CAACT,UAAU,EAAEC,MAAM,CAACO,IAAI,CAAC;EAC1F;EACA,OAAOL,KAAK;AACd;AACA,OAAO,MAAMO,gBAAgB,CAAC;EAC5BC,WAAWA,CAACC,MAAM,EAAE;IAClB,IAAI,CAACA,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,SAAS,GAAG,IAAIC,GAAG,CAAC,CAAC;IAC1B,IAAI,CAACC,kBAAkB,GAAG,IAAID,GAAG,CAAC,CAAC;IACnC,IAAI,CAACE,iBAAiB,GAAG,IAAIC,GAAG,CAAC,CAAC;IAClC,IAAI,CAACC,cAAc,GAAG,IAAID,GAAG,CAAC,CAAC;IAC/B,IAAI,CAACE,yBAAyB,GAAG,IAAIF,GAAG,CAAC,CAAC;IAC1C,IAAI,CAACG,8CAA8C,GAAG,IAAIH,GAAG,CAAC,CAAC;IAC/D,IAAI,CAACI,iBAAiB,GAAG,IAAIP,GAAG,CAAC,CAAC;IAClC,IAAI,CAACQ,oCAAoC,GAAGtB,UAAU,IAAI,IAAI,CAACoB,8CAA8C,CAACG,GAAG,CAACvB,UAAU,CAAC;IAC7H,IAAI,CAACwB,kBAAkB,GAAGxB,UAAU,IAAI,IAAI,CAACgB,iBAAiB,CAACO,GAAG,CAACvB,UAAU,CAAC;IAC9E,IAAI,CAACyB,eAAe,GAAGzB,UAAU,IAAI,IAAI,CAACkB,cAAc,CAACK,GAAG,CAACvB,UAAU,CAAC;IACxE,IAAI,CAAC0B,yCAAyC,GAAG1B,UAAU,IAAI,IAAI,CAACmB,yBAAyB,CAACI,GAAG,CAACvB,UAAU,CAAC;IAC7G,IAAIY,MAAM,CAACe,eAAe,CAACC,MAAM,GAAG,CAAC,EAAE;MACrC,IAAI,CAACC,eAAe,GAAG,IAAIf,GAAG,CAAC,CAAC;MAChC,KAAK,MAAMb,MAAM,IAAIW,MAAM,CAACe,eAAe,EAAE;QAC3CjB,gBAAgB,CAACoB,mBAAmB,CAAC7B,MAAM,EAAE,IAAI,CAAC4B,eAAe,CAAC;MACpE;IACF,CAAC,MAAM;MACL,IAAI,CAACA,eAAe,GAAG,IAAIf,GAAG,CAACJ,gBAAgB,CAACqB,OAAO,CAAC;IAC1D;IACA,KAAK,MAAM,CAAC/B,UAAU,EAAEC,MAAM,CAAC,IAAIS,gBAAgB,CAACsB,kBAAkB,CAAC,CAAC,EAAE;MACxEtB,gBAAgB,CAACuB,uBAAuB,CAAChC,MAAM,EAAED,UAAU,EAAE,IAAI,CAAC6B,eAAe,CAAC;IACpF;IACA,KAAK,MAAM,CAAC7B,UAAU,EAAEC,MAAM,CAAC,IAAI,IAAI,CAAC4B,eAAe,CAACK,OAAO,CAAC,CAAC,EAAE;MACjE,IAAI,CAACC,kBAAkB,CAACnC,UAAU,EAAED,iCAAiC,CAACC,UAAU,EAAEC,MAAM,CAAC,CAAC;IAC5F;EACF;EACA,OAAOmC,sBAAsBA,CAACnC,MAAM,EAAEoC,YAAY,EAAE;IAClD,IAAI,CAACP,mBAAmB,CAAC7B,MAAM,EAAE,IAAI,CAAC8B,OAAO,CAAC;IAC9C,IAAIM,YAAY,KAAK9B,SAAS,EAAE;MAC9B,IAAI,CAAC+B,gBAAgB,CAACD,YAAY,CAAC;IACrC;EACF;EACA,OAAOE,gBAAgBA,CAACvC,UAAU,EAAEC,MAAM,EAAEoC,YAAY,EAAE;IACxD,IAAI,CAACG,kBAAkB,CAACvC,MAAM,EAAED,UAAU,EAAE,IAAI,CAAC+B,OAAO,CAAC;IACzD,IAAIM,YAAY,KAAK9B,SAAS,EAAE;MAC9B,IAAI,CAAC+B,gBAAgB,CAACD,YAAY,CAAC;IACrC;EACF;EACA,OAAOI,kBAAkBA,CAACzC,UAAU,EAAE;IACpC,IAAI,IAAI,CAAC0C,mBAAmB,CAAC1C,UAAU,CAAC,EAAE;MACxC,MAAMJ,sBAAsB,CAAC+C,8BAA8B,CAAC3C,UAAU,CAAC;IACzE;IACA,IAAI,CAAC+B,OAAO,CAACa,MAAM,CAAC5C,UAAU,CAAC;EACjC;EACA,OAAO6C,wBAAwBA,CAAC5C,MAAM,EAAE;IACtC,KAAK,MAAM6C,eAAe,IAAI,IAAI,CAACC,gBAAgB,CAAC,CAAC,EAAE;MACrD,IAAID,eAAe,KAAK7C,MAAM,EAAE;QAC9B,MAAML,sBAAsB,CAACoD,+BAA+B,CAAC,CAAC;MAChE;IACF;IACA,KAAK,MAAM,CAAChD,UAAU,EAAEiD,gBAAgB,CAAC,IAAI,IAAI,CAAClB,OAAO,CAACG,OAAO,CAAC,CAAC,EAAE;MACnE,IAAIe,gBAAgB,KAAKhD,MAAM,EAAE;QAC/B,IAAI,CAAC8B,OAAO,CAACa,MAAM,CAAC5C,UAAU,CAAC;MACjC;IACF;EACF;EACA,OAAOkD,aAAaA,CAAA,EAAG;IACrB,IAAI,CAACnB,OAAO,CAACoB,KAAK,CAAC,CAAC;EACtB;EACA,OAAOC,wBAAwBA,CAAA,EAAG;IAChC,OAAO,CAAC,GAAGC,KAAK,CAACC,IAAI,CAAC,IAAI,CAACvB,OAAO,CAACwB,IAAI,CAAC,CAAC,CAAC,EAAE,GAAGF,KAAK,CAACC,IAAI,CAAC,IAAI,CAACE,iBAAiB,CAACD,IAAI,CAAC,CAAC,CAAC,CAAC;EAC3F;EACA,OAAOE,UAAUA,CAAA,EAAG;IAClB,OAAOJ,KAAK,CAACC,IAAI,CAAC,IAAIrC,GAAG,CAAC,IAAI,CAACc,OAAO,CAAC2B,MAAM,CAAC,CAAC,CAAC,CAACA,MAAM,CAAC,CAAC,CAAC;EAC5D;EACA,OAAOC,iBAAiBA,CAAC3D,UAAU,EAAE;IACnC,IAAI,IAAI,CAAC0C,mBAAmB,CAAC1C,UAAU,CAAC,EAAE;MACxC,OAAOO,SAAS;IAClB,CAAC,MAAM;MACL,OAAO,IAAI,CAACwB,OAAO,CAAC6B,GAAG,CAAC5D,UAAU,CAAC;IACrC;EACF;EACA,OAAO0C,mBAAmBA,CAAC1C,UAAU,EAAE;IACrC,OAAO,IAAI,CAACwD,iBAAiB,CAACjC,GAAG,CAACvB,UAAU,CAAC;EAC/C;EACA,OAAOsC,gBAAgBA,CAACD,YAAY,EAAE;IACpC,MAAMwB,mBAAmB,GAAG,IAAI5C,GAAG,CAACpB,YAAY,CAACiE,2BAA2B,CAAC,CAAC,CAAC;IAC/EC,MAAM,CAACR,IAAI,CAAClB,YAAY,CAAC,CAAC2B,OAAO,CAACC,IAAI,IAAI;MACxC,IAAIJ,mBAAmB,CAACtC,GAAG,CAAC0C,IAAI,CAAC,EAAE;QACjCpE,YAAY,CAACqE,WAAW,CAACD,IAAI,CAAC,CAACE,eAAe,CAAC9B,YAAY,CAAC4B,IAAI,CAAC,CAAC;MACpE;IACF,CAAC,CAAC;EACJ;EACA,OAAOnC,mBAAmBA,CAAC7B,MAAM,EAAEmE,QAAQ,EAAE;IAC3CL,MAAM,CAACR,IAAI,CAACtD,MAAM,CAACG,oBAAoB,CAAC,CAAC4D,OAAO,CAACK,YAAY,IAAI;MAC/D,IAAI,CAAC7B,kBAAkB,CAACvC,MAAM,EAAEoE,YAAY,EAAED,QAAQ,CAAC;IACzD,CAAC,CAAC;IACF,IAAInE,MAAM,CAACK,OAAO,KAAKC,SAAS,EAAE;MAChCwD,MAAM,CAACR,IAAI,CAACtD,MAAM,CAACK,OAAO,CAAC,CAAC0D,OAAO,CAACK,YAAY,IAAI;QAClD,IAAI,CAAC7B,kBAAkB,CAACvC,MAAM,EAAEoE,YAAY,EAAED,QAAQ,CAAC;MACzD,CAAC,CAAC;IACJ;EACF;EACA,OAAO5B,kBAAkBA,CAACvC,MAAM,EAAED,UAAU,EAAEoE,QAAQ,EAAE;IACtD,IAAI,IAAI,CAAC1B,mBAAmB,CAAC1C,UAAU,CAAC,EAAE;MACxC,MAAMJ,sBAAsB,CAAC0E,4BAA4B,CAACtE,UAAU,CAAC;IACvE,CAAC,MAAM;MACL,IAAI,CAACiC,uBAAuB,CAAChC,MAAM,EAAED,UAAU,EAAEoE,QAAQ,CAAC;IAC5D;EACF;EACA,OAAOnC,uBAAuBA,CAAChC,MAAM,EAAED,UAAU,EAAEoE,QAAQ,EAAE;IAC3D,MAAMG,UAAU,GAAGxE,iCAAiC,CAACC,UAAU,EAAEC,MAAM,CAAC,CAACuE,MAAM;IAC/E,IAAIT,MAAM,CAACU,SAAS,CAACC,cAAc,CAACC,IAAI,CAAC1E,MAAM,CAACwE,SAAS,EAAEF,UAAU,CAAC,EAAE;MACtEH,QAAQ,CAACQ,GAAG,CAAC5E,UAAU,EAAEC,MAAM,CAAC;IAClC,CAAC,MAAM;MACL,MAAMN,6BAA6B,CAACkF,sBAAsB,CAACN,UAAU,EAAEtE,MAAM,CAACO,IAAI,CAAC;IACrF;EACF;EACA,QAAQwB,kBAAkBA,CAAA,EAAG;IAC3B,KAAK,MAAM,CAAChC,UAAU,EAAEC,MAAM,CAAC,IAAI,IAAI,CAACuD,iBAAiB,EAAE;MACzD,IAAIvD,MAAM,KAAKM,SAAS,EAAE;QACxB,MAAM,CAACP,UAAU,EAAEC,MAAM,CAAC;MAC5B;IACF;EACF;EACA,QAAQ8C,gBAAgBA,CAAA,EAAG;IACzB,KAAK,MAAM,GAAG9C,MAAM,CAAC,IAAI,IAAI,CAACuD,iBAAiB,EAAE;MAC/C,IAAIvD,MAAM,KAAKM,SAAS,EAAE;QACxB,MAAMN,MAAM;MACd;IACF;EACF;EACA6E,iBAAiBA,CAACC,WAAW,EAAE;IAC7B;IACA,MAAMC,SAAS,GAAG,EAAE;IACpB,KAAK,MAAM,CAAChF,UAAU,EAAEC,MAAM,CAAC,IAAI,IAAI,CAAC4B,eAAe,CAACK,OAAO,CAAC,CAAC,EAAE;MACjE,IAAI+C,mBAAmB,GAAGD,SAAS,CAACE,IAAI,CAACC,cAAc,IAAIA,cAAc,YAAYlF,MAAM,CAAC;MAC5F,IAAIgF,mBAAmB,KAAK1E,SAAS,EAAE;QACrC0E,mBAAmB,GAAG,IAAIhF,MAAM,CAAC8E,WAAW,CAAC;QAC7CC,SAAS,CAACI,IAAI,CAACH,mBAAmB,CAAC;MACrC;MACA,MAAMI,QAAQ,GAAGtF,iCAAiC,CAACC,UAAU,EAAEC,MAAM,CAAC;MACtE,MAAMsE,UAAU,GAAGc,QAAQ,CAACb,MAAM;MAClC,IAAI,CAAC3D,SAAS,CAAC+D,GAAG,CAAC5E,UAAU,EAAE,CAACuE,UAAU,EAAEU,mBAAmB,CAAC,CAAC;MACjE,MAAMK,mBAAmB,GAAGD,QAAQ,CAACE,eAAe;MACpD,IAAID,mBAAmB,KAAK/E,SAAS,EAAE;QACrC,IAAI,CAACQ,kBAAkB,CAAC6D,GAAG,CAAC5E,UAAU,EAAE,CAACsF,mBAAmB,EAAEL,mBAAmB,CAAC,CAAC;MACrF;IACF;EACF;EACAtB,iBAAiBA,CAAC3D,UAAU,EAAE;IAC5B,IAAIU,gBAAgB,CAACgC,mBAAmB,CAAC1C,UAAU,CAAC,EAAE;MACpD,OAAOO,SAAS;IAClB;IACA,OAAO,IAAI,CAACsB,eAAe,CAAC+B,GAAG,CAAC5D,UAAU,CAAC;EAC7C;EACAwF,WAAWA,CAACxF,UAAU,EAAE;IACtB,MAAMyF,WAAW,GAAG,IAAI,CAAC5E,SAAS,CAAC+C,GAAG,CAAC5D,UAAU,CAAC;IAClD,IAAIyF,WAAW,KAAKlF,SAAS,IAAI,IAAI,CAACK,MAAM,CAAC8E,kBAAkB,CAACC,oBAAoB,CAAC3F,UAAU,CAAC,EAAE;MAChG,MAAM,CAAC4F,cAAc,EAAET,cAAc,CAAC,GAAGM,WAAW;MACpD,OAAO,CAACI,GAAG,EAAEC,KAAK,KAAKX,cAAc,CAACS,cAAc,CAAC,CAACC,GAAG,EAAEC,KAAK,CAAC;IACnE,CAAC,MAAM;MACL,OAAOvF,SAAS;IAClB;EACF;EACAwF,oBAAoBA,CAAC/F,UAAU,EAAE;IAC/B,MAAMyF,WAAW,GAAG,IAAI,CAAC1E,kBAAkB,CAAC6C,GAAG,CAAC5D,UAAU,CAAC;IAC3D,IAAIyF,WAAW,KAAKlF,SAAS,IAAI,IAAI,CAACK,MAAM,CAAC8E,kBAAkB,CAACC,oBAAoB,CAAC3F,UAAU,CAAC,EAAE;MAChG,MAAM,CAACgG,uBAAuB,EAAEb,cAAc,CAAC,GAAGM,WAAW;MAC7D,OAAO,CAACI,GAAG,EAAEC,KAAK,KAAKX,cAAc,CAACa,uBAAuB,CAAC,CAACH,GAAG,EAAEC,KAAK,CAAC;IAC5E,CAAC,MAAM;MACL,OAAOvF,SAAS;IAClB;EACF;EACA0F,WAAWA,CAACjG,UAAU,EAAE;IACtB,OAAO,IAAI,CAACqB,iBAAiB,CAACuC,GAAG,CAAC5D,UAAU,CAAC;EAC/C;EACAyD,UAAUA,CAAA,EAAG;IACX,MAAM1B,OAAO,GAAG,IAAId,GAAG,CAAC,CAAC;IACzB,KAAK,MAAM,CAACjB,UAAU,EAAEC,MAAM,CAAC,IAAI,IAAI,CAAC4B,eAAe,EAAE;MACvD,IAAI,CAACnB,gBAAgB,CAACgC,mBAAmB,CAAC1C,UAAU,CAAC,EAAE;QACrD+B,OAAO,CAACmE,GAAG,CAACjG,MAAM,CAAC;MACrB;IACF;IACA,OAAOoD,KAAK,CAACC,IAAI,CAACvB,OAAO,CAAC;EAC5B;EACAqB,wBAAwBA,CAAA,EAAG;IACzB,OAAOC,KAAK,CAACC,IAAI,CAAC,IAAI,CAACzC,SAAS,CAAC0C,IAAI,CAAC,CAAC,CAAC;EAC1C;EACApB,kBAAkBA,CAACnC,UAAU,EAAEmG,gBAAgB,EAAE;IAC/C,IAAIA,gBAAgB,CAACC,UAAU,EAAE;MAC/B,IAAI,CAACpF,iBAAiB,CAACkF,GAAG,CAAClG,UAAU,CAAC;IACxC;IACA,IAAImG,gBAAgB,CAACE,aAAa,EAAE;MAClC,IAAI,CAACnF,cAAc,CAACgF,GAAG,CAAClG,UAAU,CAAC;IACrC;IACA,IAAImG,gBAAgB,CAACG,gCAAgC,EAAE;MACrD,IAAI,CAAClF,8CAA8C,CAAC8E,GAAG,CAAClG,UAAU,CAAC;IACrE;IACA,IAAImG,gBAAgB,CAACI,iCAAiC,EAAE;MACtD,IAAI,CAACpF,yBAAyB,CAAC+E,GAAG,CAAClG,UAAU,CAAC;IAChD;IACA,IAAI,CAACqB,iBAAiB,CAACuD,GAAG,CAAC5E,UAAU,EAAEmG,gBAAgB,CAAC;EAC1D;AACF;AACAzF,gBAAgB,CAACqB,OAAO,GAAG,IAAIjB,GAAG,CAAC,CAAC;AACpCJ,gBAAgB,CAAC8C,iBAAiB,GAAG,IAAI1C,GAAG,CAAC,CAAC,CAAC,SAAS,EAAEhB,aAAa,CAAC,EAAE,CAAC,QAAQ,EAAES,SAAS,CAAC,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}