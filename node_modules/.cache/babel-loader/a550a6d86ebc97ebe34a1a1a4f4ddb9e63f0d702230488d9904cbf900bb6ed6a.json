{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { tokenMatcher } from 'chevrotain';\nimport { ErrorType } from \"../Cell.mjs\";\nimport { AstNodeType, buildParsingErrorAst, CellAddress, collectDependencies } from \".//index.mjs\";\nimport { cellAddressFromString, columnAddressFromString, rowAddressFromString } from \"./addressRepresentationConverters.mjs\";\nimport { imageWithWhitespace, ParsingErrorType, RangeSheetReferenceType } from \"./Ast.mjs\";\nimport { binaryOpTokenMap } from \"./binaryOpTokenMap.mjs\";\nimport { Cache } from \"./Cache.mjs\";\nimport { FormulaLexer, FormulaParser } from \"./FormulaParser.mjs\";\nimport { buildLexerConfig, CellReference, ColumnRange, ProcedureName, RowRange } from \"./LexerConfig.mjs\";\nimport { formatNumber } from \"./Unparser.mjs\";\nimport { ColumnAddress } from \"./ColumnAddress.mjs\";\nimport { RowAddress } from \"./RowAddress.mjs\";\n/**\r\n * Parses formula using caching if feasible.\r\n */\nexport class ParserWithCaching {\n  constructor(config, functionRegistry, sheetMapping) {\n    this.config = config;\n    this.functionRegistry = functionRegistry;\n    this.sheetMapping = sheetMapping;\n    this.statsCacheUsed = 0;\n    this.lexerConfig = buildLexerConfig(config);\n    this.lexer = new FormulaLexer(this.lexerConfig);\n    this.formulaParser = new FormulaParser(this.lexerConfig, this.sheetMapping);\n    this.cache = new Cache(this.functionRegistry);\n  }\n  /**\r\n   * Parses a formula.\r\n   *\r\n   * @param text - formula to parse\r\n   * @param formulaAddress - address with regard to which formula should be parsed. Impacts computed addresses in R0C0 format.\r\n   */\n  parse(text, formulaAddress) {\n    this.formulaAddress = formulaAddress;\n    const lexerResult = this.tokenizeFormula(text);\n    if (lexerResult.errors.length > 0) {\n      const errors = lexerResult.errors.map(e => ({\n        type: ParsingErrorType.LexingError,\n        message: e.message\n      }));\n      return {\n        ast: buildParsingErrorAst(),\n        errors,\n        hasVolatileFunction: false,\n        hasStructuralChangeFunction: false,\n        dependencies: []\n      };\n    }\n    const hash = this.computeHashFromTokens(lexerResult.tokens, formulaAddress);\n    let cacheResult = this.cache.get(hash);\n    if (cacheResult !== undefined) {\n      ++this.statsCacheUsed;\n    } else {\n      const processedTokens = this.bindWhitespacesToTokens(lexerResult.tokens);\n      const parsingResult = this.formulaParser.parseFromTokens(processedTokens, formulaAddress);\n      if (parsingResult.errors.length > 0) {\n        return Object.assign(Object.assign({}, parsingResult), {\n          hasVolatileFunction: false,\n          hasStructuralChangeFunction: false,\n          dependencies: []\n        });\n      } else {\n        cacheResult = this.cache.set(hash, parsingResult.ast);\n      }\n    }\n    const {\n      ast,\n      hasVolatileFunction,\n      hasStructuralChangeFunction\n    } = cacheResult;\n    const astWithNoReversedRanges = this.convertReversedRangesToRegularRanges(ast);\n    const dependencies = collectDependencies(astWithNoReversedRanges, this.functionRegistry);\n    return {\n      ast: astWithNoReversedRanges,\n      errors: [],\n      hasVolatileFunction,\n      hasStructuralChangeFunction,\n      dependencies\n    };\n  }\n  convertReversedRangesToRegularRanges(ast) {\n    switch (ast.type) {\n      case AstNodeType.EMPTY:\n      case AstNodeType.NUMBER:\n      case AstNodeType.STRING:\n      case AstNodeType.ERROR:\n      case AstNodeType.ERROR_WITH_RAW_INPUT:\n      case AstNodeType.CELL_REFERENCE:\n      case AstNodeType.NAMED_EXPRESSION:\n        return ast;\n      case AstNodeType.CELL_RANGE:\n        {\n          const {\n            start,\n            end\n          } = ast;\n          const orderedEnds = this.orderCellRangeEnds(start, end);\n          return Object.assign(Object.assign({}, ast), {\n            start: orderedEnds.start,\n            end: orderedEnds.end\n          });\n        }\n      case AstNodeType.COLUMN_RANGE:\n        {\n          const {\n            start,\n            end\n          } = ast;\n          const orderedEnds = this.orderColumnRangeEnds(start, end);\n          return Object.assign(Object.assign({}, ast), {\n            start: orderedEnds.start,\n            end: orderedEnds.end\n          });\n        }\n      case AstNodeType.ROW_RANGE:\n        {\n          const {\n            start,\n            end\n          } = ast;\n          const orderedEnds = this.orderRowRangeEnds(start, end);\n          return Object.assign(Object.assign({}, ast), {\n            start: orderedEnds.start,\n            end: orderedEnds.end\n          });\n        }\n      case AstNodeType.PERCENT_OP:\n      case AstNodeType.PLUS_UNARY_OP:\n      case AstNodeType.MINUS_UNARY_OP:\n        {\n          const valueFixed = this.convertReversedRangesToRegularRanges(ast.value);\n          return Object.assign(Object.assign({}, ast), {\n            value: valueFixed\n          });\n        }\n      case AstNodeType.CONCATENATE_OP:\n      case AstNodeType.EQUALS_OP:\n      case AstNodeType.NOT_EQUAL_OP:\n      case AstNodeType.LESS_THAN_OP:\n      case AstNodeType.GREATER_THAN_OP:\n      case AstNodeType.LESS_THAN_OR_EQUAL_OP:\n      case AstNodeType.GREATER_THAN_OR_EQUAL_OP:\n      case AstNodeType.MINUS_OP:\n      case AstNodeType.PLUS_OP:\n      case AstNodeType.TIMES_OP:\n      case AstNodeType.DIV_OP:\n      case AstNodeType.POWER_OP:\n        {\n          const leftFixed = this.convertReversedRangesToRegularRanges(ast.left);\n          const rightFixed = this.convertReversedRangesToRegularRanges(ast.right);\n          return Object.assign(Object.assign({}, ast), {\n            left: leftFixed,\n            right: rightFixed\n          });\n        }\n      case AstNodeType.PARENTHESIS:\n        {\n          const exprFixed = this.convertReversedRangesToRegularRanges(ast.expression);\n          return Object.assign(Object.assign({}, ast), {\n            expression: exprFixed\n          });\n        }\n      case AstNodeType.FUNCTION_CALL:\n        {\n          const argsFixed = ast.args.map(arg => this.convertReversedRangesToRegularRanges(arg));\n          return Object.assign(Object.assign({}, ast), {\n            args: argsFixed\n          });\n        }\n      case AstNodeType.ARRAY:\n        {\n          const argsFixed = ast.args.map(argsRow => argsRow.map(arg => this.convertReversedRangesToRegularRanges(arg)));\n          return Object.assign(Object.assign({}, ast), {\n            args: argsFixed\n          });\n        }\n    }\n  }\n  orderCellRangeEnds(endA, endB) {\n    const ends = [endA, endB];\n    const [startCol, endCol] = ends.map(e => e.toColumnAddress()).sort(ColumnAddress.compareByAbsoluteAddress(this.formulaAddress));\n    const [startRow, endRow] = ends.map(e => e.toRowAddress()).sort(RowAddress.compareByAbsoluteAddress(this.formulaAddress));\n    const [startSheet, endSheet] = ends.map(e => e.sheet).sort(ParserWithCaching.compareSheetIds.bind(this));\n    return {\n      start: CellAddress.fromColAndRow(startCol, startRow, startSheet),\n      end: CellAddress.fromColAndRow(endCol, endRow, endSheet)\n    };\n  }\n  orderColumnRangeEnds(endA, endB) {\n    const ends = [endA, endB];\n    const [startCol, endCol] = ends.sort(ColumnAddress.compareByAbsoluteAddress(this.formulaAddress));\n    const [startSheet, endSheet] = ends.map(e => e.sheet).sort(ParserWithCaching.compareSheetIds.bind(this));\n    return {\n      start: new ColumnAddress(startCol.type, startCol.col, startSheet),\n      end: new ColumnAddress(endCol.type, endCol.col, endSheet)\n    };\n  }\n  orderRowRangeEnds(endA, endB) {\n    const ends = [endA, endB];\n    const [startRow, endRow] = ends.sort(RowAddress.compareByAbsoluteAddress(this.formulaAddress));\n    const [startSheet, endSheet] = ends.map(e => e.sheet).sort(ParserWithCaching.compareSheetIds.bind(this));\n    return {\n      start: new RowAddress(startRow.type, startRow.row, startSheet),\n      end: new RowAddress(endRow.type, endRow.row, endSheet)\n    };\n  }\n  static compareSheetIds(sheetA, sheetB) {\n    sheetA = sheetA != null ? sheetA : Infinity;\n    sheetB = sheetB != null ? sheetB : Infinity;\n    return sheetA - sheetB;\n  }\n  fetchCachedResultForAst(ast) {\n    const hash = this.computeHashFromAst(ast);\n    return this.fetchCachedResult(hash);\n  }\n  fetchCachedResult(hash) {\n    const cacheResult = this.cache.get(hash);\n    if (cacheResult === undefined) {\n      throw new Error('There is no AST with such key in the cache');\n    } else {\n      const {\n        ast,\n        hasVolatileFunction,\n        hasStructuralChangeFunction,\n        relativeDependencies\n      } = cacheResult;\n      return {\n        ast,\n        errors: [],\n        hasVolatileFunction,\n        hasStructuralChangeFunction,\n        dependencies: relativeDependencies\n      };\n    }\n  }\n  computeHashFromTokens(tokens, baseAddress) {\n    var _a;\n    let hash = '';\n    let idx = 0;\n    while (idx < tokens.length) {\n      const token = tokens[idx];\n      if (tokenMatcher(token, CellReference)) {\n        const cellAddress = cellAddressFromString(this.sheetMapping, token.image, baseAddress);\n        if (cellAddress === undefined) {\n          hash = hash.concat(token.image);\n        } else {\n          hash = hash.concat(cellAddress.hash(true));\n        }\n      } else if (tokenMatcher(token, ProcedureName)) {\n        const procedureName = token.image.toUpperCase().slice(0, -1);\n        const canonicalProcedureName = (_a = this.lexerConfig.functionMapping[procedureName]) !== null && _a !== void 0 ? _a : procedureName;\n        hash = hash.concat(canonicalProcedureName, '(');\n      } else if (tokenMatcher(token, ColumnRange)) {\n        const [start, end] = token.image.split(':');\n        const startAddress = columnAddressFromString(this.sheetMapping, start, baseAddress);\n        const endAddress = columnAddressFromString(this.sheetMapping, end, baseAddress);\n        if (startAddress === undefined || endAddress === undefined) {\n          hash = hash.concat('!REF');\n        } else {\n          hash = hash.concat(startAddress.hash(true), ':', endAddress.hash(true));\n        }\n      } else if (tokenMatcher(token, RowRange)) {\n        const [start, end] = token.image.split(':');\n        const startAddress = rowAddressFromString(this.sheetMapping, start, baseAddress);\n        const endAddress = rowAddressFromString(this.sheetMapping, end, baseAddress);\n        if (startAddress === undefined || endAddress === undefined) {\n          hash = hash.concat('!REF');\n        } else {\n          hash = hash.concat(startAddress.hash(true), ':', endAddress.hash(true));\n        }\n      } else {\n        hash = hash.concat(token.image);\n      }\n      idx++;\n    }\n    return hash;\n  }\n  rememberNewAst(ast) {\n    const hash = this.computeHashFromAst(ast);\n    return this.cache.maybeSetAndThenGet(hash, ast);\n  }\n  computeHashFromAst(ast) {\n    return '=' + this.computeHashOfAstNode(ast);\n  }\n  computeHashOfAstNode(ast) {\n    switch (ast.type) {\n      case AstNodeType.EMPTY:\n        {\n          return ast.leadingWhitespace || '';\n        }\n      case AstNodeType.NUMBER:\n        {\n          return imageWithWhitespace(formatNumber(ast.value, this.config.decimalSeparator), ast.leadingWhitespace);\n        }\n      case AstNodeType.STRING:\n        {\n          return imageWithWhitespace('\"' + ast.value + '\"', ast.leadingWhitespace);\n        }\n      case AstNodeType.NAMED_EXPRESSION:\n        {\n          return imageWithWhitespace(ast.expressionName, ast.leadingWhitespace);\n        }\n      case AstNodeType.FUNCTION_CALL:\n        {\n          const args = ast.args.map(arg => this.computeHashOfAstNode(arg)).join(this.config.functionArgSeparator);\n          const rightPart = ast.procedureName + '(' + args + imageWithWhitespace(')', ast.internalWhitespace);\n          return imageWithWhitespace(rightPart, ast.leadingWhitespace);\n        }\n      case AstNodeType.CELL_REFERENCE:\n        {\n          return imageWithWhitespace(ast.reference.hash(true), ast.leadingWhitespace);\n        }\n      case AstNodeType.COLUMN_RANGE:\n      case AstNodeType.ROW_RANGE:\n      case AstNodeType.CELL_RANGE:\n        {\n          const start = ast.start.hash(ast.sheetReferenceType !== RangeSheetReferenceType.RELATIVE);\n          const end = ast.end.hash(ast.sheetReferenceType === RangeSheetReferenceType.BOTH_ABSOLUTE);\n          return imageWithWhitespace(start + ':' + end, ast.leadingWhitespace);\n        }\n      case AstNodeType.MINUS_UNARY_OP:\n        {\n          return imageWithWhitespace('-' + this.computeHashOfAstNode(ast.value), ast.leadingWhitespace);\n        }\n      case AstNodeType.PLUS_UNARY_OP:\n        {\n          return imageWithWhitespace('+' + this.computeHashOfAstNode(ast.value), ast.leadingWhitespace);\n        }\n      case AstNodeType.PERCENT_OP:\n        {\n          return this.computeHashOfAstNode(ast.value) + imageWithWhitespace('%', ast.leadingWhitespace);\n        }\n      case AstNodeType.ERROR:\n        {\n          const image = this.config.translationPackage.getErrorTranslation(ast.error ? ast.error.type : ErrorType.ERROR);\n          return imageWithWhitespace(image, ast.leadingWhitespace);\n        }\n      case AstNodeType.ERROR_WITH_RAW_INPUT:\n        {\n          return imageWithWhitespace(ast.rawInput, ast.leadingWhitespace);\n        }\n      case AstNodeType.ARRAY:\n        {\n          const args = ast.args.map(row => row.map(val => this.computeHashOfAstNode(val)).join(',')).join(';');\n          return imageWithWhitespace('{' + args + imageWithWhitespace('}', ast.internalWhitespace), ast.leadingWhitespace);\n        }\n      case AstNodeType.PARENTHESIS:\n        {\n          const expression = this.computeHashOfAstNode(ast.expression);\n          const rightPart = '(' + expression + imageWithWhitespace(')', ast.internalWhitespace);\n          return imageWithWhitespace(rightPart, ast.leadingWhitespace);\n        }\n      default:\n        {\n          return this.computeHashOfAstNode(ast.left) + imageWithWhitespace(binaryOpTokenMap[ast.type], ast.leadingWhitespace) + this.computeHashOfAstNode(ast.right);\n        }\n    }\n  }\n  bindWhitespacesToTokens(tokens) {\n    const processedTokens = [];\n    const first = tokens[0];\n    if (!tokenMatcher(first, this.lexerConfig.WhiteSpace)) {\n      processedTokens.push(first);\n    }\n    for (let i = 1; i < tokens.length; ++i) {\n      const current = tokens[i];\n      if (tokenMatcher(current, this.lexerConfig.WhiteSpace)) {\n        continue;\n      }\n      const previous = tokens[i - 1];\n      if (tokenMatcher(previous, this.lexerConfig.WhiteSpace)) {\n        current.leadingWhitespace = previous;\n      }\n      processedTokens.push(current);\n    }\n    return processedTokens;\n  }\n  tokenizeFormula(text) {\n    return this.lexer.tokenizeFormula(text);\n  }\n}","map":{"version":3,"names":["tokenMatcher","ErrorType","AstNodeType","buildParsingErrorAst","CellAddress","collectDependencies","cellAddressFromString","columnAddressFromString","rowAddressFromString","imageWithWhitespace","ParsingErrorType","RangeSheetReferenceType","binaryOpTokenMap","Cache","FormulaLexer","FormulaParser","buildLexerConfig","CellReference","ColumnRange","ProcedureName","RowRange","formatNumber","ColumnAddress","RowAddress","ParserWithCaching","constructor","config","functionRegistry","sheetMapping","statsCacheUsed","lexerConfig","lexer","formulaParser","cache","parse","text","formulaAddress","lexerResult","tokenizeFormula","errors","length","map","e","type","LexingError","message","ast","hasVolatileFunction","hasStructuralChangeFunction","dependencies","hash","computeHashFromTokens","tokens","cacheResult","get","undefined","processedTokens","bindWhitespacesToTokens","parsingResult","parseFromTokens","Object","assign","set","astWithNoReversedRanges","convertReversedRangesToRegularRanges","EMPTY","NUMBER","STRING","ERROR","ERROR_WITH_RAW_INPUT","CELL_REFERENCE","NAMED_EXPRESSION","CELL_RANGE","start","end","orderedEnds","orderCellRangeEnds","COLUMN_RANGE","orderColumnRangeEnds","ROW_RANGE","orderRowRangeEnds","PERCENT_OP","PLUS_UNARY_OP","MINUS_UNARY_OP","valueFixed","value","CONCATENATE_OP","EQUALS_OP","NOT_EQUAL_OP","LESS_THAN_OP","GREATER_THAN_OP","LESS_THAN_OR_EQUAL_OP","GREATER_THAN_OR_EQUAL_OP","MINUS_OP","PLUS_OP","TIMES_OP","DIV_OP","POWER_OP","leftFixed","left","rightFixed","right","PARENTHESIS","exprFixed","expression","FUNCTION_CALL","argsFixed","args","arg","ARRAY","argsRow","endA","endB","ends","startCol","endCol","toColumnAddress","sort","compareByAbsoluteAddress","startRow","endRow","toRowAddress","startSheet","endSheet","sheet","compareSheetIds","bind","fromColAndRow","col","row","sheetA","sheetB","Infinity","fetchCachedResultForAst","computeHashFromAst","fetchCachedResult","Error","relativeDependencies","baseAddress","_a","idx","token","cellAddress","image","concat","procedureName","toUpperCase","slice","canonicalProcedureName","functionMapping","split","startAddress","endAddress","rememberNewAst","maybeSetAndThenGet","computeHashOfAstNode","leadingWhitespace","decimalSeparator","expressionName","join","functionArgSeparator","rightPart","internalWhitespace","reference","sheetReferenceType","RELATIVE","BOTH_ABSOLUTE","translationPackage","getErrorTranslation","error","rawInput","val","first","WhiteSpace","push","i","current","previous"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/parser/ParserWithCaching.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { tokenMatcher } from 'chevrotain';\nimport { ErrorType } from \"../Cell.mjs\";\nimport { AstNodeType, buildParsingErrorAst, CellAddress, collectDependencies } from \".//index.mjs\";\nimport { cellAddressFromString, columnAddressFromString, rowAddressFromString } from \"./addressRepresentationConverters.mjs\";\nimport { imageWithWhitespace, ParsingErrorType, RangeSheetReferenceType } from \"./Ast.mjs\";\nimport { binaryOpTokenMap } from \"./binaryOpTokenMap.mjs\";\nimport { Cache } from \"./Cache.mjs\";\nimport { FormulaLexer, FormulaParser } from \"./FormulaParser.mjs\";\nimport { buildLexerConfig, CellReference, ColumnRange, ProcedureName, RowRange } from \"./LexerConfig.mjs\";\nimport { formatNumber } from \"./Unparser.mjs\";\nimport { ColumnAddress } from \"./ColumnAddress.mjs\";\nimport { RowAddress } from \"./RowAddress.mjs\";\n/**\r\n * Parses formula using caching if feasible.\r\n */\nexport class ParserWithCaching {\n  constructor(config, functionRegistry, sheetMapping) {\n    this.config = config;\n    this.functionRegistry = functionRegistry;\n    this.sheetMapping = sheetMapping;\n    this.statsCacheUsed = 0;\n    this.lexerConfig = buildLexerConfig(config);\n    this.lexer = new FormulaLexer(this.lexerConfig);\n    this.formulaParser = new FormulaParser(this.lexerConfig, this.sheetMapping);\n    this.cache = new Cache(this.functionRegistry);\n  }\n  /**\r\n   * Parses a formula.\r\n   *\r\n   * @param text - formula to parse\r\n   * @param formulaAddress - address with regard to which formula should be parsed. Impacts computed addresses in R0C0 format.\r\n   */\n  parse(text, formulaAddress) {\n    this.formulaAddress = formulaAddress;\n    const lexerResult = this.tokenizeFormula(text);\n    if (lexerResult.errors.length > 0) {\n      const errors = lexerResult.errors.map(e => ({\n        type: ParsingErrorType.LexingError,\n        message: e.message\n      }));\n      return {\n        ast: buildParsingErrorAst(),\n        errors,\n        hasVolatileFunction: false,\n        hasStructuralChangeFunction: false,\n        dependencies: []\n      };\n    }\n    const hash = this.computeHashFromTokens(lexerResult.tokens, formulaAddress);\n    let cacheResult = this.cache.get(hash);\n    if (cacheResult !== undefined) {\n      ++this.statsCacheUsed;\n    } else {\n      const processedTokens = this.bindWhitespacesToTokens(lexerResult.tokens);\n      const parsingResult = this.formulaParser.parseFromTokens(processedTokens, formulaAddress);\n      if (parsingResult.errors.length > 0) {\n        return Object.assign(Object.assign({}, parsingResult), {\n          hasVolatileFunction: false,\n          hasStructuralChangeFunction: false,\n          dependencies: []\n        });\n      } else {\n        cacheResult = this.cache.set(hash, parsingResult.ast);\n      }\n    }\n    const {\n      ast,\n      hasVolatileFunction,\n      hasStructuralChangeFunction\n    } = cacheResult;\n    const astWithNoReversedRanges = this.convertReversedRangesToRegularRanges(ast);\n    const dependencies = collectDependencies(astWithNoReversedRanges, this.functionRegistry);\n    return {\n      ast: astWithNoReversedRanges,\n      errors: [],\n      hasVolatileFunction,\n      hasStructuralChangeFunction,\n      dependencies\n    };\n  }\n  convertReversedRangesToRegularRanges(ast) {\n    switch (ast.type) {\n      case AstNodeType.EMPTY:\n      case AstNodeType.NUMBER:\n      case AstNodeType.STRING:\n      case AstNodeType.ERROR:\n      case AstNodeType.ERROR_WITH_RAW_INPUT:\n      case AstNodeType.CELL_REFERENCE:\n      case AstNodeType.NAMED_EXPRESSION:\n        return ast;\n      case AstNodeType.CELL_RANGE:\n        {\n          const {\n            start,\n            end\n          } = ast;\n          const orderedEnds = this.orderCellRangeEnds(start, end);\n          return Object.assign(Object.assign({}, ast), {\n            start: orderedEnds.start,\n            end: orderedEnds.end\n          });\n        }\n      case AstNodeType.COLUMN_RANGE:\n        {\n          const {\n            start,\n            end\n          } = ast;\n          const orderedEnds = this.orderColumnRangeEnds(start, end);\n          return Object.assign(Object.assign({}, ast), {\n            start: orderedEnds.start,\n            end: orderedEnds.end\n          });\n        }\n      case AstNodeType.ROW_RANGE:\n        {\n          const {\n            start,\n            end\n          } = ast;\n          const orderedEnds = this.orderRowRangeEnds(start, end);\n          return Object.assign(Object.assign({}, ast), {\n            start: orderedEnds.start,\n            end: orderedEnds.end\n          });\n        }\n      case AstNodeType.PERCENT_OP:\n      case AstNodeType.PLUS_UNARY_OP:\n      case AstNodeType.MINUS_UNARY_OP:\n        {\n          const valueFixed = this.convertReversedRangesToRegularRanges(ast.value);\n          return Object.assign(Object.assign({}, ast), {\n            value: valueFixed\n          });\n        }\n      case AstNodeType.CONCATENATE_OP:\n      case AstNodeType.EQUALS_OP:\n      case AstNodeType.NOT_EQUAL_OP:\n      case AstNodeType.LESS_THAN_OP:\n      case AstNodeType.GREATER_THAN_OP:\n      case AstNodeType.LESS_THAN_OR_EQUAL_OP:\n      case AstNodeType.GREATER_THAN_OR_EQUAL_OP:\n      case AstNodeType.MINUS_OP:\n      case AstNodeType.PLUS_OP:\n      case AstNodeType.TIMES_OP:\n      case AstNodeType.DIV_OP:\n      case AstNodeType.POWER_OP:\n        {\n          const leftFixed = this.convertReversedRangesToRegularRanges(ast.left);\n          const rightFixed = this.convertReversedRangesToRegularRanges(ast.right);\n          return Object.assign(Object.assign({}, ast), {\n            left: leftFixed,\n            right: rightFixed\n          });\n        }\n      case AstNodeType.PARENTHESIS:\n        {\n          const exprFixed = this.convertReversedRangesToRegularRanges(ast.expression);\n          return Object.assign(Object.assign({}, ast), {\n            expression: exprFixed\n          });\n        }\n      case AstNodeType.FUNCTION_CALL:\n        {\n          const argsFixed = ast.args.map(arg => this.convertReversedRangesToRegularRanges(arg));\n          return Object.assign(Object.assign({}, ast), {\n            args: argsFixed\n          });\n        }\n      case AstNodeType.ARRAY:\n        {\n          const argsFixed = ast.args.map(argsRow => argsRow.map(arg => this.convertReversedRangesToRegularRanges(arg)));\n          return Object.assign(Object.assign({}, ast), {\n            args: argsFixed\n          });\n        }\n    }\n  }\n  orderCellRangeEnds(endA, endB) {\n    const ends = [endA, endB];\n    const [startCol, endCol] = ends.map(e => e.toColumnAddress()).sort(ColumnAddress.compareByAbsoluteAddress(this.formulaAddress));\n    const [startRow, endRow] = ends.map(e => e.toRowAddress()).sort(RowAddress.compareByAbsoluteAddress(this.formulaAddress));\n    const [startSheet, endSheet] = ends.map(e => e.sheet).sort(ParserWithCaching.compareSheetIds.bind(this));\n    return {\n      start: CellAddress.fromColAndRow(startCol, startRow, startSheet),\n      end: CellAddress.fromColAndRow(endCol, endRow, endSheet)\n    };\n  }\n  orderColumnRangeEnds(endA, endB) {\n    const ends = [endA, endB];\n    const [startCol, endCol] = ends.sort(ColumnAddress.compareByAbsoluteAddress(this.formulaAddress));\n    const [startSheet, endSheet] = ends.map(e => e.sheet).sort(ParserWithCaching.compareSheetIds.bind(this));\n    return {\n      start: new ColumnAddress(startCol.type, startCol.col, startSheet),\n      end: new ColumnAddress(endCol.type, endCol.col, endSheet)\n    };\n  }\n  orderRowRangeEnds(endA, endB) {\n    const ends = [endA, endB];\n    const [startRow, endRow] = ends.sort(RowAddress.compareByAbsoluteAddress(this.formulaAddress));\n    const [startSheet, endSheet] = ends.map(e => e.sheet).sort(ParserWithCaching.compareSheetIds.bind(this));\n    return {\n      start: new RowAddress(startRow.type, startRow.row, startSheet),\n      end: new RowAddress(endRow.type, endRow.row, endSheet)\n    };\n  }\n  static compareSheetIds(sheetA, sheetB) {\n    sheetA = sheetA != null ? sheetA : Infinity;\n    sheetB = sheetB != null ? sheetB : Infinity;\n    return sheetA - sheetB;\n  }\n  fetchCachedResultForAst(ast) {\n    const hash = this.computeHashFromAst(ast);\n    return this.fetchCachedResult(hash);\n  }\n  fetchCachedResult(hash) {\n    const cacheResult = this.cache.get(hash);\n    if (cacheResult === undefined) {\n      throw new Error('There is no AST with such key in the cache');\n    } else {\n      const {\n        ast,\n        hasVolatileFunction,\n        hasStructuralChangeFunction,\n        relativeDependencies\n      } = cacheResult;\n      return {\n        ast,\n        errors: [],\n        hasVolatileFunction,\n        hasStructuralChangeFunction,\n        dependencies: relativeDependencies\n      };\n    }\n  }\n  computeHashFromTokens(tokens, baseAddress) {\n    var _a;\n    let hash = '';\n    let idx = 0;\n    while (idx < tokens.length) {\n      const token = tokens[idx];\n      if (tokenMatcher(token, CellReference)) {\n        const cellAddress = cellAddressFromString(this.sheetMapping, token.image, baseAddress);\n        if (cellAddress === undefined) {\n          hash = hash.concat(token.image);\n        } else {\n          hash = hash.concat(cellAddress.hash(true));\n        }\n      } else if (tokenMatcher(token, ProcedureName)) {\n        const procedureName = token.image.toUpperCase().slice(0, -1);\n        const canonicalProcedureName = (_a = this.lexerConfig.functionMapping[procedureName]) !== null && _a !== void 0 ? _a : procedureName;\n        hash = hash.concat(canonicalProcedureName, '(');\n      } else if (tokenMatcher(token, ColumnRange)) {\n        const [start, end] = token.image.split(':');\n        const startAddress = columnAddressFromString(this.sheetMapping, start, baseAddress);\n        const endAddress = columnAddressFromString(this.sheetMapping, end, baseAddress);\n        if (startAddress === undefined || endAddress === undefined) {\n          hash = hash.concat('!REF');\n        } else {\n          hash = hash.concat(startAddress.hash(true), ':', endAddress.hash(true));\n        }\n      } else if (tokenMatcher(token, RowRange)) {\n        const [start, end] = token.image.split(':');\n        const startAddress = rowAddressFromString(this.sheetMapping, start, baseAddress);\n        const endAddress = rowAddressFromString(this.sheetMapping, end, baseAddress);\n        if (startAddress === undefined || endAddress === undefined) {\n          hash = hash.concat('!REF');\n        } else {\n          hash = hash.concat(startAddress.hash(true), ':', endAddress.hash(true));\n        }\n      } else {\n        hash = hash.concat(token.image);\n      }\n      idx++;\n    }\n    return hash;\n  }\n  rememberNewAst(ast) {\n    const hash = this.computeHashFromAst(ast);\n    return this.cache.maybeSetAndThenGet(hash, ast);\n  }\n  computeHashFromAst(ast) {\n    return '=' + this.computeHashOfAstNode(ast);\n  }\n  computeHashOfAstNode(ast) {\n    switch (ast.type) {\n      case AstNodeType.EMPTY:\n        {\n          return ast.leadingWhitespace || '';\n        }\n      case AstNodeType.NUMBER:\n        {\n          return imageWithWhitespace(formatNumber(ast.value, this.config.decimalSeparator), ast.leadingWhitespace);\n        }\n      case AstNodeType.STRING:\n        {\n          return imageWithWhitespace('\"' + ast.value + '\"', ast.leadingWhitespace);\n        }\n      case AstNodeType.NAMED_EXPRESSION:\n        {\n          return imageWithWhitespace(ast.expressionName, ast.leadingWhitespace);\n        }\n      case AstNodeType.FUNCTION_CALL:\n        {\n          const args = ast.args.map(arg => this.computeHashOfAstNode(arg)).join(this.config.functionArgSeparator);\n          const rightPart = ast.procedureName + '(' + args + imageWithWhitespace(')', ast.internalWhitespace);\n          return imageWithWhitespace(rightPart, ast.leadingWhitespace);\n        }\n      case AstNodeType.CELL_REFERENCE:\n        {\n          return imageWithWhitespace(ast.reference.hash(true), ast.leadingWhitespace);\n        }\n      case AstNodeType.COLUMN_RANGE:\n      case AstNodeType.ROW_RANGE:\n      case AstNodeType.CELL_RANGE:\n        {\n          const start = ast.start.hash(ast.sheetReferenceType !== RangeSheetReferenceType.RELATIVE);\n          const end = ast.end.hash(ast.sheetReferenceType === RangeSheetReferenceType.BOTH_ABSOLUTE);\n          return imageWithWhitespace(start + ':' + end, ast.leadingWhitespace);\n        }\n      case AstNodeType.MINUS_UNARY_OP:\n        {\n          return imageWithWhitespace('-' + this.computeHashOfAstNode(ast.value), ast.leadingWhitespace);\n        }\n      case AstNodeType.PLUS_UNARY_OP:\n        {\n          return imageWithWhitespace('+' + this.computeHashOfAstNode(ast.value), ast.leadingWhitespace);\n        }\n      case AstNodeType.PERCENT_OP:\n        {\n          return this.computeHashOfAstNode(ast.value) + imageWithWhitespace('%', ast.leadingWhitespace);\n        }\n      case AstNodeType.ERROR:\n        {\n          const image = this.config.translationPackage.getErrorTranslation(ast.error ? ast.error.type : ErrorType.ERROR);\n          return imageWithWhitespace(image, ast.leadingWhitespace);\n        }\n      case AstNodeType.ERROR_WITH_RAW_INPUT:\n        {\n          return imageWithWhitespace(ast.rawInput, ast.leadingWhitespace);\n        }\n      case AstNodeType.ARRAY:\n        {\n          const args = ast.args.map(row => row.map(val => this.computeHashOfAstNode(val)).join(',')).join(';');\n          return imageWithWhitespace('{' + args + imageWithWhitespace('}', ast.internalWhitespace), ast.leadingWhitespace);\n        }\n      case AstNodeType.PARENTHESIS:\n        {\n          const expression = this.computeHashOfAstNode(ast.expression);\n          const rightPart = '(' + expression + imageWithWhitespace(')', ast.internalWhitespace);\n          return imageWithWhitespace(rightPart, ast.leadingWhitespace);\n        }\n      default:\n        {\n          return this.computeHashOfAstNode(ast.left) + imageWithWhitespace(binaryOpTokenMap[ast.type], ast.leadingWhitespace) + this.computeHashOfAstNode(ast.right);\n        }\n    }\n  }\n  bindWhitespacesToTokens(tokens) {\n    const processedTokens = [];\n    const first = tokens[0];\n    if (!tokenMatcher(first, this.lexerConfig.WhiteSpace)) {\n      processedTokens.push(first);\n    }\n    for (let i = 1; i < tokens.length; ++i) {\n      const current = tokens[i];\n      if (tokenMatcher(current, this.lexerConfig.WhiteSpace)) {\n        continue;\n      }\n      const previous = tokens[i - 1];\n      if (tokenMatcher(previous, this.lexerConfig.WhiteSpace)) {\n        current.leadingWhitespace = previous;\n      }\n      processedTokens.push(current);\n    }\n    return processedTokens;\n  }\n  tokenizeFormula(text) {\n    return this.lexer.tokenizeFormula(text);\n  }\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,YAAY,QAAQ,YAAY;AACzC,SAASC,SAAS,QAAQ,aAAa;AACvC,SAASC,WAAW,EAAEC,oBAAoB,EAAEC,WAAW,EAAEC,mBAAmB,QAAQ,cAAc;AAClG,SAASC,qBAAqB,EAAEC,uBAAuB,EAAEC,oBAAoB,QAAQ,uCAAuC;AAC5H,SAASC,mBAAmB,EAAEC,gBAAgB,EAAEC,uBAAuB,QAAQ,WAAW;AAC1F,SAASC,gBAAgB,QAAQ,wBAAwB;AACzD,SAASC,KAAK,QAAQ,aAAa;AACnC,SAASC,YAAY,EAAEC,aAAa,QAAQ,qBAAqB;AACjE,SAASC,gBAAgB,EAAEC,aAAa,EAAEC,WAAW,EAAEC,aAAa,EAAEC,QAAQ,QAAQ,mBAAmB;AACzG,SAASC,YAAY,QAAQ,gBAAgB;AAC7C,SAASC,aAAa,QAAQ,qBAAqB;AACnD,SAASC,UAAU,QAAQ,kBAAkB;AAC7C;AACA;AACA;AACA,OAAO,MAAMC,iBAAiB,CAAC;EAC7BC,WAAWA,CAACC,MAAM,EAAEC,gBAAgB,EAAEC,YAAY,EAAE;IAClD,IAAI,CAACF,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACC,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACC,cAAc,GAAG,CAAC;IACvB,IAAI,CAACC,WAAW,GAAGd,gBAAgB,CAACU,MAAM,CAAC;IAC3C,IAAI,CAACK,KAAK,GAAG,IAAIjB,YAAY,CAAC,IAAI,CAACgB,WAAW,CAAC;IAC/C,IAAI,CAACE,aAAa,GAAG,IAAIjB,aAAa,CAAC,IAAI,CAACe,WAAW,EAAE,IAAI,CAACF,YAAY,CAAC;IAC3E,IAAI,CAACK,KAAK,GAAG,IAAIpB,KAAK,CAAC,IAAI,CAACc,gBAAgB,CAAC;EAC/C;EACA;AACF;AACA;AACA;AACA;AACA;EACEO,KAAKA,CAACC,IAAI,EAAEC,cAAc,EAAE;IAC1B,IAAI,CAACA,cAAc,GAAGA,cAAc;IACpC,MAAMC,WAAW,GAAG,IAAI,CAACC,eAAe,CAACH,IAAI,CAAC;IAC9C,IAAIE,WAAW,CAACE,MAAM,CAACC,MAAM,GAAG,CAAC,EAAE;MACjC,MAAMD,MAAM,GAAGF,WAAW,CAACE,MAAM,CAACE,GAAG,CAACC,CAAC,KAAK;QAC1CC,IAAI,EAAEjC,gBAAgB,CAACkC,WAAW;QAClCC,OAAO,EAAEH,CAAC,CAACG;MACb,CAAC,CAAC,CAAC;MACH,OAAO;QACLC,GAAG,EAAE3C,oBAAoB,CAAC,CAAC;QAC3BoC,MAAM;QACNQ,mBAAmB,EAAE,KAAK;QAC1BC,2BAA2B,EAAE,KAAK;QAClCC,YAAY,EAAE;MAChB,CAAC;IACH;IACA,MAAMC,IAAI,GAAG,IAAI,CAACC,qBAAqB,CAACd,WAAW,CAACe,MAAM,EAAEhB,cAAc,CAAC;IAC3E,IAAIiB,WAAW,GAAG,IAAI,CAACpB,KAAK,CAACqB,GAAG,CAACJ,IAAI,CAAC;IACtC,IAAIG,WAAW,KAAKE,SAAS,EAAE;MAC7B,EAAE,IAAI,CAAC1B,cAAc;IACvB,CAAC,MAAM;MACL,MAAM2B,eAAe,GAAG,IAAI,CAACC,uBAAuB,CAACpB,WAAW,CAACe,MAAM,CAAC;MACxE,MAAMM,aAAa,GAAG,IAAI,CAAC1B,aAAa,CAAC2B,eAAe,CAACH,eAAe,EAAEpB,cAAc,CAAC;MACzF,IAAIsB,aAAa,CAACnB,MAAM,CAACC,MAAM,GAAG,CAAC,EAAE;QACnC,OAAOoB,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEH,aAAa,CAAC,EAAE;UACrDX,mBAAmB,EAAE,KAAK;UAC1BC,2BAA2B,EAAE,KAAK;UAClCC,YAAY,EAAE;QAChB,CAAC,CAAC;MACJ,CAAC,MAAM;QACLI,WAAW,GAAG,IAAI,CAACpB,KAAK,CAAC6B,GAAG,CAACZ,IAAI,EAAEQ,aAAa,CAACZ,GAAG,CAAC;MACvD;IACF;IACA,MAAM;MACJA,GAAG;MACHC,mBAAmB;MACnBC;IACF,CAAC,GAAGK,WAAW;IACf,MAAMU,uBAAuB,GAAG,IAAI,CAACC,oCAAoC,CAAClB,GAAG,CAAC;IAC9E,MAAMG,YAAY,GAAG5C,mBAAmB,CAAC0D,uBAAuB,EAAE,IAAI,CAACpC,gBAAgB,CAAC;IACxF,OAAO;MACLmB,GAAG,EAAEiB,uBAAuB;MAC5BxB,MAAM,EAAE,EAAE;MACVQ,mBAAmB;MACnBC,2BAA2B;MAC3BC;IACF,CAAC;EACH;EACAe,oCAAoCA,CAAClB,GAAG,EAAE;IACxC,QAAQA,GAAG,CAACH,IAAI;MACd,KAAKzC,WAAW,CAAC+D,KAAK;MACtB,KAAK/D,WAAW,CAACgE,MAAM;MACvB,KAAKhE,WAAW,CAACiE,MAAM;MACvB,KAAKjE,WAAW,CAACkE,KAAK;MACtB,KAAKlE,WAAW,CAACmE,oBAAoB;MACrC,KAAKnE,WAAW,CAACoE,cAAc;MAC/B,KAAKpE,WAAW,CAACqE,gBAAgB;QAC/B,OAAOzB,GAAG;MACZ,KAAK5C,WAAW,CAACsE,UAAU;QACzB;UACE,MAAM;YACJC,KAAK;YACLC;UACF,CAAC,GAAG5B,GAAG;UACP,MAAM6B,WAAW,GAAG,IAAI,CAACC,kBAAkB,CAACH,KAAK,EAAEC,GAAG,CAAC;UACvD,OAAOd,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEf,GAAG,CAAC,EAAE;YAC3C2B,KAAK,EAAEE,WAAW,CAACF,KAAK;YACxBC,GAAG,EAAEC,WAAW,CAACD;UACnB,CAAC,CAAC;QACJ;MACF,KAAKxE,WAAW,CAAC2E,YAAY;QAC3B;UACE,MAAM;YACJJ,KAAK;YACLC;UACF,CAAC,GAAG5B,GAAG;UACP,MAAM6B,WAAW,GAAG,IAAI,CAACG,oBAAoB,CAACL,KAAK,EAAEC,GAAG,CAAC;UACzD,OAAOd,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEf,GAAG,CAAC,EAAE;YAC3C2B,KAAK,EAAEE,WAAW,CAACF,KAAK;YACxBC,GAAG,EAAEC,WAAW,CAACD;UACnB,CAAC,CAAC;QACJ;MACF,KAAKxE,WAAW,CAAC6E,SAAS;QACxB;UACE,MAAM;YACJN,KAAK;YACLC;UACF,CAAC,GAAG5B,GAAG;UACP,MAAM6B,WAAW,GAAG,IAAI,CAACK,iBAAiB,CAACP,KAAK,EAAEC,GAAG,CAAC;UACtD,OAAOd,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEf,GAAG,CAAC,EAAE;YAC3C2B,KAAK,EAAEE,WAAW,CAACF,KAAK;YACxBC,GAAG,EAAEC,WAAW,CAACD;UACnB,CAAC,CAAC;QACJ;MACF,KAAKxE,WAAW,CAAC+E,UAAU;MAC3B,KAAK/E,WAAW,CAACgF,aAAa;MAC9B,KAAKhF,WAAW,CAACiF,cAAc;QAC7B;UACE,MAAMC,UAAU,GAAG,IAAI,CAACpB,oCAAoC,CAAClB,GAAG,CAACuC,KAAK,CAAC;UACvE,OAAOzB,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEf,GAAG,CAAC,EAAE;YAC3CuC,KAAK,EAAED;UACT,CAAC,CAAC;QACJ;MACF,KAAKlF,WAAW,CAACoF,cAAc;MAC/B,KAAKpF,WAAW,CAACqF,SAAS;MAC1B,KAAKrF,WAAW,CAACsF,YAAY;MAC7B,KAAKtF,WAAW,CAACuF,YAAY;MAC7B,KAAKvF,WAAW,CAACwF,eAAe;MAChC,KAAKxF,WAAW,CAACyF,qBAAqB;MACtC,KAAKzF,WAAW,CAAC0F,wBAAwB;MACzC,KAAK1F,WAAW,CAAC2F,QAAQ;MACzB,KAAK3F,WAAW,CAAC4F,OAAO;MACxB,KAAK5F,WAAW,CAAC6F,QAAQ;MACzB,KAAK7F,WAAW,CAAC8F,MAAM;MACvB,KAAK9F,WAAW,CAAC+F,QAAQ;QACvB;UACE,MAAMC,SAAS,GAAG,IAAI,CAAClC,oCAAoC,CAAClB,GAAG,CAACqD,IAAI,CAAC;UACrE,MAAMC,UAAU,GAAG,IAAI,CAACpC,oCAAoC,CAAClB,GAAG,CAACuD,KAAK,CAAC;UACvE,OAAOzC,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEf,GAAG,CAAC,EAAE;YAC3CqD,IAAI,EAAED,SAAS;YACfG,KAAK,EAAED;UACT,CAAC,CAAC;QACJ;MACF,KAAKlG,WAAW,CAACoG,WAAW;QAC1B;UACE,MAAMC,SAAS,GAAG,IAAI,CAACvC,oCAAoC,CAAClB,GAAG,CAAC0D,UAAU,CAAC;UAC3E,OAAO5C,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEf,GAAG,CAAC,EAAE;YAC3C0D,UAAU,EAAED;UACd,CAAC,CAAC;QACJ;MACF,KAAKrG,WAAW,CAACuG,aAAa;QAC5B;UACE,MAAMC,SAAS,GAAG5D,GAAG,CAAC6D,IAAI,CAAClE,GAAG,CAACmE,GAAG,IAAI,IAAI,CAAC5C,oCAAoC,CAAC4C,GAAG,CAAC,CAAC;UACrF,OAAOhD,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEf,GAAG,CAAC,EAAE;YAC3C6D,IAAI,EAAED;UACR,CAAC,CAAC;QACJ;MACF,KAAKxG,WAAW,CAAC2G,KAAK;QACpB;UACE,MAAMH,SAAS,GAAG5D,GAAG,CAAC6D,IAAI,CAAClE,GAAG,CAACqE,OAAO,IAAIA,OAAO,CAACrE,GAAG,CAACmE,GAAG,IAAI,IAAI,CAAC5C,oCAAoC,CAAC4C,GAAG,CAAC,CAAC,CAAC;UAC7G,OAAOhD,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEf,GAAG,CAAC,EAAE;YAC3C6D,IAAI,EAAED;UACR,CAAC,CAAC;QACJ;IACJ;EACF;EACA9B,kBAAkBA,CAACmC,IAAI,EAAEC,IAAI,EAAE;IAC7B,MAAMC,IAAI,GAAG,CAACF,IAAI,EAAEC,IAAI,CAAC;IACzB,MAAM,CAACE,QAAQ,EAAEC,MAAM,CAAC,GAAGF,IAAI,CAACxE,GAAG,CAACC,CAAC,IAAIA,CAAC,CAAC0E,eAAe,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC/F,aAAa,CAACgG,wBAAwB,CAAC,IAAI,CAAClF,cAAc,CAAC,CAAC;IAC/H,MAAM,CAACmF,QAAQ,EAAEC,MAAM,CAAC,GAAGP,IAAI,CAACxE,GAAG,CAACC,CAAC,IAAIA,CAAC,CAAC+E,YAAY,CAAC,CAAC,CAAC,CAACJ,IAAI,CAAC9F,UAAU,CAAC+F,wBAAwB,CAAC,IAAI,CAAClF,cAAc,CAAC,CAAC;IACzH,MAAM,CAACsF,UAAU,EAAEC,QAAQ,CAAC,GAAGV,IAAI,CAACxE,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACkF,KAAK,CAAC,CAACP,IAAI,CAAC7F,iBAAiB,CAACqG,eAAe,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;IACxG,OAAO;MACLrD,KAAK,EAAErE,WAAW,CAAC2H,aAAa,CAACb,QAAQ,EAAEK,QAAQ,EAAEG,UAAU,CAAC;MAChEhD,GAAG,EAAEtE,WAAW,CAAC2H,aAAa,CAACZ,MAAM,EAAEK,MAAM,EAAEG,QAAQ;IACzD,CAAC;EACH;EACA7C,oBAAoBA,CAACiC,IAAI,EAAEC,IAAI,EAAE;IAC/B,MAAMC,IAAI,GAAG,CAACF,IAAI,EAAEC,IAAI,CAAC;IACzB,MAAM,CAACE,QAAQ,EAAEC,MAAM,CAAC,GAAGF,IAAI,CAACI,IAAI,CAAC/F,aAAa,CAACgG,wBAAwB,CAAC,IAAI,CAAClF,cAAc,CAAC,CAAC;IACjG,MAAM,CAACsF,UAAU,EAAEC,QAAQ,CAAC,GAAGV,IAAI,CAACxE,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACkF,KAAK,CAAC,CAACP,IAAI,CAAC7F,iBAAiB,CAACqG,eAAe,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;IACxG,OAAO;MACLrD,KAAK,EAAE,IAAInD,aAAa,CAAC4F,QAAQ,CAACvE,IAAI,EAAEuE,QAAQ,CAACc,GAAG,EAAEN,UAAU,CAAC;MACjEhD,GAAG,EAAE,IAAIpD,aAAa,CAAC6F,MAAM,CAACxE,IAAI,EAAEwE,MAAM,CAACa,GAAG,EAAEL,QAAQ;IAC1D,CAAC;EACH;EACA3C,iBAAiBA,CAAC+B,IAAI,EAAEC,IAAI,EAAE;IAC5B,MAAMC,IAAI,GAAG,CAACF,IAAI,EAAEC,IAAI,CAAC;IACzB,MAAM,CAACO,QAAQ,EAAEC,MAAM,CAAC,GAAGP,IAAI,CAACI,IAAI,CAAC9F,UAAU,CAAC+F,wBAAwB,CAAC,IAAI,CAAClF,cAAc,CAAC,CAAC;IAC9F,MAAM,CAACsF,UAAU,EAAEC,QAAQ,CAAC,GAAGV,IAAI,CAACxE,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACkF,KAAK,CAAC,CAACP,IAAI,CAAC7F,iBAAiB,CAACqG,eAAe,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;IACxG,OAAO;MACLrD,KAAK,EAAE,IAAIlD,UAAU,CAACgG,QAAQ,CAAC5E,IAAI,EAAE4E,QAAQ,CAACU,GAAG,EAAEP,UAAU,CAAC;MAC9DhD,GAAG,EAAE,IAAInD,UAAU,CAACiG,MAAM,CAAC7E,IAAI,EAAE6E,MAAM,CAACS,GAAG,EAAEN,QAAQ;IACvD,CAAC;EACH;EACA,OAAOE,eAAeA,CAACK,MAAM,EAAEC,MAAM,EAAE;IACrCD,MAAM,GAAGA,MAAM,IAAI,IAAI,GAAGA,MAAM,GAAGE,QAAQ;IAC3CD,MAAM,GAAGA,MAAM,IAAI,IAAI,GAAGA,MAAM,GAAGC,QAAQ;IAC3C,OAAOF,MAAM,GAAGC,MAAM;EACxB;EACAE,uBAAuBA,CAACvF,GAAG,EAAE;IAC3B,MAAMI,IAAI,GAAG,IAAI,CAACoF,kBAAkB,CAACxF,GAAG,CAAC;IACzC,OAAO,IAAI,CAACyF,iBAAiB,CAACrF,IAAI,CAAC;EACrC;EACAqF,iBAAiBA,CAACrF,IAAI,EAAE;IACtB,MAAMG,WAAW,GAAG,IAAI,CAACpB,KAAK,CAACqB,GAAG,CAACJ,IAAI,CAAC;IACxC,IAAIG,WAAW,KAAKE,SAAS,EAAE;MAC7B,MAAM,IAAIiF,KAAK,CAAC,4CAA4C,CAAC;IAC/D,CAAC,MAAM;MACL,MAAM;QACJ1F,GAAG;QACHC,mBAAmB;QACnBC,2BAA2B;QAC3ByF;MACF,CAAC,GAAGpF,WAAW;MACf,OAAO;QACLP,GAAG;QACHP,MAAM,EAAE,EAAE;QACVQ,mBAAmB;QACnBC,2BAA2B;QAC3BC,YAAY,EAAEwF;MAChB,CAAC;IACH;EACF;EACAtF,qBAAqBA,CAACC,MAAM,EAAEsF,WAAW,EAAE;IACzC,IAAIC,EAAE;IACN,IAAIzF,IAAI,GAAG,EAAE;IACb,IAAI0F,GAAG,GAAG,CAAC;IACX,OAAOA,GAAG,GAAGxF,MAAM,CAACZ,MAAM,EAAE;MAC1B,MAAMqG,KAAK,GAAGzF,MAAM,CAACwF,GAAG,CAAC;MACzB,IAAI5I,YAAY,CAAC6I,KAAK,EAAE5H,aAAa,CAAC,EAAE;QACtC,MAAM6H,WAAW,GAAGxI,qBAAqB,CAAC,IAAI,CAACsB,YAAY,EAAEiH,KAAK,CAACE,KAAK,EAAEL,WAAW,CAAC;QACtF,IAAII,WAAW,KAAKvF,SAAS,EAAE;UAC7BL,IAAI,GAAGA,IAAI,CAAC8F,MAAM,CAACH,KAAK,CAACE,KAAK,CAAC;QACjC,CAAC,MAAM;UACL7F,IAAI,GAAGA,IAAI,CAAC8F,MAAM,CAACF,WAAW,CAAC5F,IAAI,CAAC,IAAI,CAAC,CAAC;QAC5C;MACF,CAAC,MAAM,IAAIlD,YAAY,CAAC6I,KAAK,EAAE1H,aAAa,CAAC,EAAE;QAC7C,MAAM8H,aAAa,GAAGJ,KAAK,CAACE,KAAK,CAACG,WAAW,CAAC,CAAC,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC5D,MAAMC,sBAAsB,GAAG,CAACT,EAAE,GAAG,IAAI,CAAC7G,WAAW,CAACuH,eAAe,CAACJ,aAAa,CAAC,MAAM,IAAI,IAAIN,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAGM,aAAa;QACpI/F,IAAI,GAAGA,IAAI,CAAC8F,MAAM,CAACI,sBAAsB,EAAE,GAAG,CAAC;MACjD,CAAC,MAAM,IAAIpJ,YAAY,CAAC6I,KAAK,EAAE3H,WAAW,CAAC,EAAE;QAC3C,MAAM,CAACuD,KAAK,EAAEC,GAAG,CAAC,GAAGmE,KAAK,CAACE,KAAK,CAACO,KAAK,CAAC,GAAG,CAAC;QAC3C,MAAMC,YAAY,GAAGhJ,uBAAuB,CAAC,IAAI,CAACqB,YAAY,EAAE6C,KAAK,EAAEiE,WAAW,CAAC;QACnF,MAAMc,UAAU,GAAGjJ,uBAAuB,CAAC,IAAI,CAACqB,YAAY,EAAE8C,GAAG,EAAEgE,WAAW,CAAC;QAC/E,IAAIa,YAAY,KAAKhG,SAAS,IAAIiG,UAAU,KAAKjG,SAAS,EAAE;UAC1DL,IAAI,GAAGA,IAAI,CAAC8F,MAAM,CAAC,MAAM,CAAC;QAC5B,CAAC,MAAM;UACL9F,IAAI,GAAGA,IAAI,CAAC8F,MAAM,CAACO,YAAY,CAACrG,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,EAAEsG,UAAU,CAACtG,IAAI,CAAC,IAAI,CAAC,CAAC;QACzE;MACF,CAAC,MAAM,IAAIlD,YAAY,CAAC6I,KAAK,EAAEzH,QAAQ,CAAC,EAAE;QACxC,MAAM,CAACqD,KAAK,EAAEC,GAAG,CAAC,GAAGmE,KAAK,CAACE,KAAK,CAACO,KAAK,CAAC,GAAG,CAAC;QAC3C,MAAMC,YAAY,GAAG/I,oBAAoB,CAAC,IAAI,CAACoB,YAAY,EAAE6C,KAAK,EAAEiE,WAAW,CAAC;QAChF,MAAMc,UAAU,GAAGhJ,oBAAoB,CAAC,IAAI,CAACoB,YAAY,EAAE8C,GAAG,EAAEgE,WAAW,CAAC;QAC5E,IAAIa,YAAY,KAAKhG,SAAS,IAAIiG,UAAU,KAAKjG,SAAS,EAAE;UAC1DL,IAAI,GAAGA,IAAI,CAAC8F,MAAM,CAAC,MAAM,CAAC;QAC5B,CAAC,MAAM;UACL9F,IAAI,GAAGA,IAAI,CAAC8F,MAAM,CAACO,YAAY,CAACrG,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,EAAEsG,UAAU,CAACtG,IAAI,CAAC,IAAI,CAAC,CAAC;QACzE;MACF,CAAC,MAAM;QACLA,IAAI,GAAGA,IAAI,CAAC8F,MAAM,CAACH,KAAK,CAACE,KAAK,CAAC;MACjC;MACAH,GAAG,EAAE;IACP;IACA,OAAO1F,IAAI;EACb;EACAuG,cAAcA,CAAC3G,GAAG,EAAE;IAClB,MAAMI,IAAI,GAAG,IAAI,CAACoF,kBAAkB,CAACxF,GAAG,CAAC;IACzC,OAAO,IAAI,CAACb,KAAK,CAACyH,kBAAkB,CAACxG,IAAI,EAAEJ,GAAG,CAAC;EACjD;EACAwF,kBAAkBA,CAACxF,GAAG,EAAE;IACtB,OAAO,GAAG,GAAG,IAAI,CAAC6G,oBAAoB,CAAC7G,GAAG,CAAC;EAC7C;EACA6G,oBAAoBA,CAAC7G,GAAG,EAAE;IACxB,QAAQA,GAAG,CAACH,IAAI;MACd,KAAKzC,WAAW,CAAC+D,KAAK;QACpB;UACE,OAAOnB,GAAG,CAAC8G,iBAAiB,IAAI,EAAE;QACpC;MACF,KAAK1J,WAAW,CAACgE,MAAM;QACrB;UACE,OAAOzD,mBAAmB,CAACY,YAAY,CAACyB,GAAG,CAACuC,KAAK,EAAE,IAAI,CAAC3D,MAAM,CAACmI,gBAAgB,CAAC,EAAE/G,GAAG,CAAC8G,iBAAiB,CAAC;QAC1G;MACF,KAAK1J,WAAW,CAACiE,MAAM;QACrB;UACE,OAAO1D,mBAAmB,CAAC,GAAG,GAAGqC,GAAG,CAACuC,KAAK,GAAG,GAAG,EAAEvC,GAAG,CAAC8G,iBAAiB,CAAC;QAC1E;MACF,KAAK1J,WAAW,CAACqE,gBAAgB;QAC/B;UACE,OAAO9D,mBAAmB,CAACqC,GAAG,CAACgH,cAAc,EAAEhH,GAAG,CAAC8G,iBAAiB,CAAC;QACvE;MACF,KAAK1J,WAAW,CAACuG,aAAa;QAC5B;UACE,MAAME,IAAI,GAAG7D,GAAG,CAAC6D,IAAI,CAAClE,GAAG,CAACmE,GAAG,IAAI,IAAI,CAAC+C,oBAAoB,CAAC/C,GAAG,CAAC,CAAC,CAACmD,IAAI,CAAC,IAAI,CAACrI,MAAM,CAACsI,oBAAoB,CAAC;UACvG,MAAMC,SAAS,GAAGnH,GAAG,CAACmG,aAAa,GAAG,GAAG,GAAGtC,IAAI,GAAGlG,mBAAmB,CAAC,GAAG,EAAEqC,GAAG,CAACoH,kBAAkB,CAAC;UACnG,OAAOzJ,mBAAmB,CAACwJ,SAAS,EAAEnH,GAAG,CAAC8G,iBAAiB,CAAC;QAC9D;MACF,KAAK1J,WAAW,CAACoE,cAAc;QAC7B;UACE,OAAO7D,mBAAmB,CAACqC,GAAG,CAACqH,SAAS,CAACjH,IAAI,CAAC,IAAI,CAAC,EAAEJ,GAAG,CAAC8G,iBAAiB,CAAC;QAC7E;MACF,KAAK1J,WAAW,CAAC2E,YAAY;MAC7B,KAAK3E,WAAW,CAAC6E,SAAS;MAC1B,KAAK7E,WAAW,CAACsE,UAAU;QACzB;UACE,MAAMC,KAAK,GAAG3B,GAAG,CAAC2B,KAAK,CAACvB,IAAI,CAACJ,GAAG,CAACsH,kBAAkB,KAAKzJ,uBAAuB,CAAC0J,QAAQ,CAAC;UACzF,MAAM3F,GAAG,GAAG5B,GAAG,CAAC4B,GAAG,CAACxB,IAAI,CAACJ,GAAG,CAACsH,kBAAkB,KAAKzJ,uBAAuB,CAAC2J,aAAa,CAAC;UAC1F,OAAO7J,mBAAmB,CAACgE,KAAK,GAAG,GAAG,GAAGC,GAAG,EAAE5B,GAAG,CAAC8G,iBAAiB,CAAC;QACtE;MACF,KAAK1J,WAAW,CAACiF,cAAc;QAC7B;UACE,OAAO1E,mBAAmB,CAAC,GAAG,GAAG,IAAI,CAACkJ,oBAAoB,CAAC7G,GAAG,CAACuC,KAAK,CAAC,EAAEvC,GAAG,CAAC8G,iBAAiB,CAAC;QAC/F;MACF,KAAK1J,WAAW,CAACgF,aAAa;QAC5B;UACE,OAAOzE,mBAAmB,CAAC,GAAG,GAAG,IAAI,CAACkJ,oBAAoB,CAAC7G,GAAG,CAACuC,KAAK,CAAC,EAAEvC,GAAG,CAAC8G,iBAAiB,CAAC;QAC/F;MACF,KAAK1J,WAAW,CAAC+E,UAAU;QACzB;UACE,OAAO,IAAI,CAAC0E,oBAAoB,CAAC7G,GAAG,CAACuC,KAAK,CAAC,GAAG5E,mBAAmB,CAAC,GAAG,EAAEqC,GAAG,CAAC8G,iBAAiB,CAAC;QAC/F;MACF,KAAK1J,WAAW,CAACkE,KAAK;QACpB;UACE,MAAM2E,KAAK,GAAG,IAAI,CAACrH,MAAM,CAAC6I,kBAAkB,CAACC,mBAAmB,CAAC1H,GAAG,CAAC2H,KAAK,GAAG3H,GAAG,CAAC2H,KAAK,CAAC9H,IAAI,GAAG1C,SAAS,CAACmE,KAAK,CAAC;UAC9G,OAAO3D,mBAAmB,CAACsI,KAAK,EAAEjG,GAAG,CAAC8G,iBAAiB,CAAC;QAC1D;MACF,KAAK1J,WAAW,CAACmE,oBAAoB;QACnC;UACE,OAAO5D,mBAAmB,CAACqC,GAAG,CAAC4H,QAAQ,EAAE5H,GAAG,CAAC8G,iBAAiB,CAAC;QACjE;MACF,KAAK1J,WAAW,CAAC2G,KAAK;QACpB;UACE,MAAMF,IAAI,GAAG7D,GAAG,CAAC6D,IAAI,CAAClE,GAAG,CAACwF,GAAG,IAAIA,GAAG,CAACxF,GAAG,CAACkI,GAAG,IAAI,IAAI,CAAChB,oBAAoB,CAACgB,GAAG,CAAC,CAAC,CAACZ,IAAI,CAAC,GAAG,CAAC,CAAC,CAACA,IAAI,CAAC,GAAG,CAAC;UACpG,OAAOtJ,mBAAmB,CAAC,GAAG,GAAGkG,IAAI,GAAGlG,mBAAmB,CAAC,GAAG,EAAEqC,GAAG,CAACoH,kBAAkB,CAAC,EAAEpH,GAAG,CAAC8G,iBAAiB,CAAC;QAClH;MACF,KAAK1J,WAAW,CAACoG,WAAW;QAC1B;UACE,MAAME,UAAU,GAAG,IAAI,CAACmD,oBAAoB,CAAC7G,GAAG,CAAC0D,UAAU,CAAC;UAC5D,MAAMyD,SAAS,GAAG,GAAG,GAAGzD,UAAU,GAAG/F,mBAAmB,CAAC,GAAG,EAAEqC,GAAG,CAACoH,kBAAkB,CAAC;UACrF,OAAOzJ,mBAAmB,CAACwJ,SAAS,EAAEnH,GAAG,CAAC8G,iBAAiB,CAAC;QAC9D;MACF;QACE;UACE,OAAO,IAAI,CAACD,oBAAoB,CAAC7G,GAAG,CAACqD,IAAI,CAAC,GAAG1F,mBAAmB,CAACG,gBAAgB,CAACkC,GAAG,CAACH,IAAI,CAAC,EAAEG,GAAG,CAAC8G,iBAAiB,CAAC,GAAG,IAAI,CAACD,oBAAoB,CAAC7G,GAAG,CAACuD,KAAK,CAAC;QAC5J;IACJ;EACF;EACA5C,uBAAuBA,CAACL,MAAM,EAAE;IAC9B,MAAMI,eAAe,GAAG,EAAE;IAC1B,MAAMoH,KAAK,GAAGxH,MAAM,CAAC,CAAC,CAAC;IACvB,IAAI,CAACpD,YAAY,CAAC4K,KAAK,EAAE,IAAI,CAAC9I,WAAW,CAAC+I,UAAU,CAAC,EAAE;MACrDrH,eAAe,CAACsH,IAAI,CAACF,KAAK,CAAC;IAC7B;IACA,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG3H,MAAM,CAACZ,MAAM,EAAE,EAAEuI,CAAC,EAAE;MACtC,MAAMC,OAAO,GAAG5H,MAAM,CAAC2H,CAAC,CAAC;MACzB,IAAI/K,YAAY,CAACgL,OAAO,EAAE,IAAI,CAAClJ,WAAW,CAAC+I,UAAU,CAAC,EAAE;QACtD;MACF;MACA,MAAMI,QAAQ,GAAG7H,MAAM,CAAC2H,CAAC,GAAG,CAAC,CAAC;MAC9B,IAAI/K,YAAY,CAACiL,QAAQ,EAAE,IAAI,CAACnJ,WAAW,CAAC+I,UAAU,CAAC,EAAE;QACvDG,OAAO,CAACpB,iBAAiB,GAAGqB,QAAQ;MACtC;MACAzH,eAAe,CAACsH,IAAI,CAACE,OAAO,CAAC;IAC/B;IACA,OAAOxH,eAAe;EACxB;EACAlB,eAAeA,CAACH,IAAI,EAAE;IACpB,OAAO,IAAI,CAACJ,KAAK,CAACO,eAAe,CAACH,IAAI,CAAC;EACzC;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}