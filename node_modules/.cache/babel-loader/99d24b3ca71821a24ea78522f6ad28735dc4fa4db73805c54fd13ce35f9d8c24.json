{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from \"./AbsoluteCellRange.mjs\";\nimport { invalidSimpleCellAddress, simpleCellAddress } from \"./Cell.mjs\";\nimport { CellContent } from \"./CellContentParser.mjs\";\nimport { InvalidAddressError, InvalidArgumentsError, NamedExpressionDoesNotExistError, NamedExpressionNameIsAlreadyTakenError, NamedExpressionNameIsInvalidError, NoOperationToRedoError, NoOperationToUndoError, NoRelativeAddressesAllowedError, NoSheetWithIdError, NothingToPasteError, SheetNameAlreadyTakenError, SheetSizeLimitExceededError, SourceLocationHasArrayError, TargetLocationHasArrayError } from \"./errors.mjs\";\nimport { doesContainRelativeReferences } from \"./NamedExpressions.mjs\";\nimport { AddColumnsCommand, AddRowsCommand, RemoveColumnsCommand, RemoveRowsCommand } from \"./Operations.mjs\";\nimport { findBoundaries, validateAsSheet } from \"./Sheet.mjs\";\nimport { ColumnsSpan, RowsSpan } from \"./Span.mjs\";\nimport { AddColumnsUndoEntry, AddNamedExpressionUndoEntry, AddRowsUndoEntry, AddSheetUndoEntry, ChangeNamedExpressionUndoEntry, ClearSheetUndoEntry, MoveCellsUndoEntry, MoveColumnsUndoEntry, MoveRowsUndoEntry, PasteUndoEntry, RemoveColumnsUndoEntry, RemoveNamedExpressionUndoEntry, RemoveRowsUndoEntry, RemoveSheetUndoEntry, RenameSheetUndoEntry, SetCellContentsUndoEntry, SetColumnOrderUndoEntry, SetRowOrderUndoEntry, SetSheetContentUndoEntry } from \"./UndoRedo.mjs\";\nexport class CrudOperations {\n  constructor(config, operations, undoRedo, clipboardOperations, dependencyGraph, columnSearch, parser, cellContentParser, lazilyTransformingAstService, namedExpressions) {\n    this.operations = operations;\n    this.undoRedo = undoRedo;\n    this.clipboardOperations = clipboardOperations;\n    this.dependencyGraph = dependencyGraph;\n    this.columnSearch = columnSearch;\n    this.parser = parser;\n    this.cellContentParser = cellContentParser;\n    this.lazilyTransformingAstService = lazilyTransformingAstService;\n    this.namedExpressions = namedExpressions;\n    this.maxRows = config.maxRows;\n    this.maxColumns = config.maxColumns;\n  }\n  get sheetMapping() {\n    return this.dependencyGraph.sheetMapping;\n  }\n  addRows(sheet, ...indexes) {\n    const addRowsCommand = new AddRowsCommand(sheet, indexes);\n    this.ensureItIsPossibleToAddRows(sheet, ...indexes);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    this.operations.addRows(addRowsCommand);\n    this.undoRedo.saveOperation(new AddRowsUndoEntry(addRowsCommand));\n  }\n  removeRows(sheet, ...indexes) {\n    const removeRowsCommand = new RemoveRowsCommand(sheet, indexes);\n    this.ensureItIsPossibleToRemoveRows(sheet, ...indexes);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const rowsRemovals = this.operations.removeRows(removeRowsCommand);\n    this.undoRedo.saveOperation(new RemoveRowsUndoEntry(removeRowsCommand, rowsRemovals));\n  }\n  addColumns(sheet, ...indexes) {\n    const addColumnsCommand = new AddColumnsCommand(sheet, indexes);\n    this.ensureItIsPossibleToAddColumns(sheet, ...indexes);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    this.operations.addColumns(addColumnsCommand);\n    this.undoRedo.saveOperation(new AddColumnsUndoEntry(addColumnsCommand));\n  }\n  removeColumns(sheet, ...indexes) {\n    const removeColumnsCommand = new RemoveColumnsCommand(sheet, indexes);\n    this.ensureItIsPossibleToRemoveColumns(sheet, ...indexes);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const columnsRemovals = this.operations.removeColumns(removeColumnsCommand);\n    this.undoRedo.saveOperation(new RemoveColumnsUndoEntry(removeColumnsCommand, columnsRemovals));\n  }\n  moveCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const {\n      version,\n      overwrittenCellsData,\n      addedGlobalNamedExpressions\n    } = this.operations.moveCells(sourceLeftCorner, width, height, destinationLeftCorner);\n    this.undoRedo.saveOperation(new MoveCellsUndoEntry(sourceLeftCorner, width, height, destinationLeftCorner, overwrittenCellsData, addedGlobalNamedExpressions, version));\n  }\n  moveRows(sheet, startRow, numberOfRows, targetRow) {\n    this.ensureItIsPossibleToMoveRows(sheet, startRow, numberOfRows, targetRow);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const version = this.operations.moveRows(sheet, startRow, numberOfRows, targetRow);\n    this.undoRedo.saveOperation(new MoveRowsUndoEntry(sheet, startRow, numberOfRows, targetRow, version));\n  }\n  moveColumns(sheet, startColumn, numberOfColumns, targetColumn) {\n    this.ensureItIsPossibleToMoveColumns(sheet, startColumn, numberOfColumns, targetColumn);\n    this.undoRedo.clearRedoStack();\n    const version = this.operations.moveColumns(sheet, startColumn, numberOfColumns, targetColumn);\n    this.undoRedo.saveOperation(new MoveColumnsUndoEntry(sheet, startColumn, numberOfColumns, targetColumn, version));\n  }\n  cut(sourceLeftCorner, width, height) {\n    this.clipboardOperations.cut(sourceLeftCorner, width, height);\n  }\n  ensureItIsPossibleToCopy(sourceLeftCorner, width, height) {\n    if (!isPositiveInteger(width)) {\n      throw new InvalidArgumentsError('width to be positive integer.');\n    }\n    if (!isPositiveInteger(height)) {\n      throw new InvalidArgumentsError('height to be positive integer.');\n    }\n  }\n  copy(sourceLeftCorner, width, height) {\n    this.ensureItIsPossibleToCopy(sourceLeftCorner, width, height);\n    this.clipboardOperations.copy(sourceLeftCorner, width, height);\n  }\n  paste(targetLeftCorner) {\n    const clipboard = this.clipboardOperations.clipboard;\n    if (clipboard === undefined) {\n      throw new NothingToPasteError();\n    } else if (this.clipboardOperations.isCutClipboard()) {\n      this.moveCells(clipboard.sourceLeftCorner, clipboard.width, clipboard.height, targetLeftCorner);\n    } else if (this.clipboardOperations.isCopyClipboard()) {\n      this.clipboardOperations.ensureItIsPossibleToCopyPaste(targetLeftCorner);\n      const targetRange = AbsoluteCellRange.spanFrom(targetLeftCorner, clipboard.width, clipboard.height);\n      const oldContent = this.operations.getRangeClipboardCells(targetRange);\n      this.undoRedo.clearRedoStack();\n      const addedGlobalNamedExpressions = this.operations.restoreClipboardCells(clipboard.sourceLeftCorner.sheet, clipboard.getContent(targetLeftCorner));\n      this.undoRedo.saveOperation(new PasteUndoEntry(targetLeftCorner, oldContent, clipboard.content, addedGlobalNamedExpressions));\n    }\n  }\n  beginUndoRedoBatchMode() {\n    this.undoRedo.beginBatchMode();\n  }\n  commitUndoRedoBatchMode() {\n    this.undoRedo.commitBatchMode();\n  }\n  isClipboardEmpty() {\n    return this.clipboardOperations.clipboard === undefined;\n  }\n  clearClipboard() {\n    this.clipboardOperations.clear();\n  }\n  addSheet(name) {\n    if (name !== undefined) {\n      this.ensureItIsPossibleToAddSheet(name);\n    }\n    this.undoRedo.clearRedoStack();\n    const addedSheetName = this.operations.addSheet(name);\n    this.undoRedo.saveOperation(new AddSheetUndoEntry(addedSheetName));\n    return addedSheetName;\n  }\n  removeSheet(sheetId) {\n    this.ensureScopeIdIsValid(sheetId);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const originalName = this.sheetMapping.fetchDisplayName(sheetId);\n    const oldSheetContent = this.operations.getSheetClipboardCells(sheetId);\n    const {\n      version,\n      scopedNamedExpressions\n    } = this.operations.removeSheet(sheetId);\n    this.undoRedo.saveOperation(new RemoveSheetUndoEntry(originalName, sheetId, oldSheetContent, scopedNamedExpressions, version));\n  }\n  renameSheet(sheetId, newName) {\n    this.ensureItIsPossibleToRenameSheet(sheetId, newName);\n    const oldName = this.operations.renameSheet(sheetId, newName);\n    if (oldName !== undefined) {\n      this.undoRedo.clearRedoStack();\n      this.undoRedo.saveOperation(new RenameSheetUndoEntry(sheetId, oldName, newName));\n    }\n    return oldName;\n  }\n  clearSheet(sheetId) {\n    this.ensureScopeIdIsValid(sheetId);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const oldSheetContent = this.operations.getSheetClipboardCells(sheetId);\n    this.operations.clearSheet(sheetId);\n    this.undoRedo.saveOperation(new ClearSheetUndoEntry(sheetId, oldSheetContent));\n  }\n  setCellContents(topLeftCornerAddress, cellContents) {\n    if (!(cellContents instanceof Array)) {\n      cellContents = [[cellContents]];\n    } else {\n      for (let i = 0; i < cellContents.length; i++) {\n        if (!(cellContents[i] instanceof Array)) {\n          throw new InvalidArgumentsError('an array of arrays or a raw cell value.');\n        }\n      }\n    }\n    this.ensureItIsPossibleToChangeCellContents(topLeftCornerAddress, cellContents);\n    this.undoRedo.clearRedoStack();\n    const oldContents = [];\n    for (let i = 0; i < cellContents.length; i++) {\n      for (let j = 0; j < cellContents[i].length; j++) {\n        const address = {\n          sheet: topLeftCornerAddress.sheet,\n          row: topLeftCornerAddress.row + i,\n          col: topLeftCornerAddress.col + j\n        };\n        const newContent = cellContents[i][j];\n        this.clipboardOperations.abortCut();\n        const oldContent = this.operations.setCellContent(address, newContent);\n        oldContents.push({\n          address,\n          newContent,\n          oldContent\n        });\n      }\n    }\n    this.undoRedo.saveOperation(new SetCellContentsUndoEntry(oldContents));\n  }\n  setSheetContent(sheetId, values) {\n    this.ensureScopeIdIsValid(sheetId);\n    this.ensureItIsPossibleToChangeSheetContents(sheetId, values);\n    validateAsSheet(values);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const oldSheetContent = this.operations.getSheetClipboardCells(sheetId);\n    this.operations.setSheetContent(sheetId, values);\n    this.undoRedo.saveOperation(new SetSheetContentUndoEntry(sheetId, oldSheetContent, values));\n  }\n  setRowOrder(sheetId, rowMapping) {\n    this.validateSwapRowIndexes(sheetId, rowMapping);\n    this.testRowOrderForArrays(sheetId, rowMapping);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const oldContent = this.operations.setRowOrder(sheetId, rowMapping);\n    this.undoRedo.saveOperation(new SetRowOrderUndoEntry(sheetId, rowMapping, oldContent));\n  }\n  validateSwapRowIndexes(sheetId, rowMapping) {\n    if (!this.sheetMapping.hasSheetWithId(sheetId)) {\n      throw new NoSheetWithIdError(sheetId);\n    }\n    this.validateRowOrColumnMapping(sheetId, rowMapping, 'row');\n  }\n  testColumnOrderForArrays(sheetId, columnMapping) {\n    for (const [source, target] of columnMapping) {\n      if (source !== target) {\n        const rowRange = AbsoluteCellRange.spanFrom({\n          sheet: sheetId,\n          col: source,\n          row: 0\n        }, 1, Infinity);\n        if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(rowRange)) {\n          throw new SourceLocationHasArrayError();\n        }\n      }\n    }\n  }\n  setColumnOrder(sheetId, columnMapping) {\n    this.validateSwapColumnIndexes(sheetId, columnMapping);\n    this.testColumnOrderForArrays(sheetId, columnMapping);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const oldContent = this.operations.setColumnOrder(sheetId, columnMapping);\n    this.undoRedo.saveOperation(new SetColumnOrderUndoEntry(sheetId, columnMapping, oldContent));\n  }\n  validateSwapColumnIndexes(sheetId, columnMapping) {\n    if (!this.sheetMapping.hasSheetWithId(sheetId)) {\n      throw new NoSheetWithIdError(sheetId);\n    }\n    this.validateRowOrColumnMapping(sheetId, columnMapping, 'column');\n  }\n  testRowOrderForArrays(sheetId, rowMapping) {\n    for (const [source, target] of rowMapping) {\n      if (source !== target) {\n        const rowRange = AbsoluteCellRange.spanFrom({\n          sheet: sheetId,\n          col: 0,\n          row: source\n        }, Infinity, 1);\n        if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(rowRange)) {\n          throw new SourceLocationHasArrayError();\n        }\n      }\n    }\n  }\n  mappingFromOrder(sheetId, newOrder, rowOrColumn) {\n    if (!this.sheetMapping.hasSheetWithId(sheetId)) {\n      throw new NoSheetWithIdError(sheetId);\n    }\n    const limit = rowOrColumn === 'row' ? this.dependencyGraph.getSheetHeight(sheetId) : this.dependencyGraph.getSheetWidth(sheetId);\n    if (newOrder.length !== limit) {\n      throw new InvalidArgumentsError(`number of ${rowOrColumn}s provided to be sheet ${rowOrColumn === 'row' ? 'height' : 'width'}.`);\n    }\n    const ret = [];\n    for (let i = 0; i < limit; i++) {\n      if (newOrder[i] !== i) {\n        ret.push([i, newOrder[i]]);\n      }\n    }\n    return ret;\n  }\n  undo() {\n    if (this.undoRedo.isUndoStackEmpty()) {\n      throw new NoOperationToUndoError();\n    }\n    this.clipboardOperations.abortCut();\n    this.undoRedo.undo();\n  }\n  redo() {\n    if (this.undoRedo.isRedoStackEmpty()) {\n      throw new NoOperationToRedoError();\n    }\n    this.clipboardOperations.abortCut();\n    this.undoRedo.redo();\n  }\n  addNamedExpression(expressionName, expression, sheetId, options) {\n    this.ensureItIsPossibleToAddNamedExpression(expressionName, expression, sheetId);\n    this.operations.addNamedExpression(expressionName, expression, sheetId, options);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    this.undoRedo.saveOperation(new AddNamedExpressionUndoEntry(expressionName, expression, sheetId, options));\n  }\n  changeNamedExpressionExpression(expressionName, sheetId, newExpression, options) {\n    this.ensureItIsPossibleToChangeNamedExpression(expressionName, newExpression, sheetId);\n    const [oldNamedExpression, content] = this.operations.changeNamedExpressionExpression(expressionName, newExpression, sheetId, options);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    this.undoRedo.saveOperation(new ChangeNamedExpressionUndoEntry(oldNamedExpression, newExpression, content, sheetId, options));\n  }\n  removeNamedExpression(expressionName, sheetId) {\n    this.ensureScopeIdIsValid(sheetId);\n    const [namedExpression, content] = this.operations.removeNamedExpression(expressionName, sheetId);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    this.undoRedo.saveOperation(new RemoveNamedExpressionUndoEntry(namedExpression, content, sheetId));\n    return namedExpression;\n  }\n  ensureItIsPossibleToAddNamedExpression(expressionName, expression, sheetId) {\n    this.ensureScopeIdIsValid(sheetId);\n    this.ensureNamedExpressionNameIsValid(expressionName, sheetId);\n    this.ensureNamedExpressionIsValid(expression);\n  }\n  ensureItIsPossibleToChangeNamedExpression(expressionName, expression, sheetId) {\n    this.ensureScopeIdIsValid(sheetId);\n    if (this.namedExpressions.namedExpressionForScope(expressionName, sheetId) === undefined) {\n      throw new NamedExpressionDoesNotExistError(expressionName);\n    }\n    this.ensureNamedExpressionIsValid(expression);\n  }\n  isItPossibleToRemoveNamedExpression(expressionName, sheetId) {\n    this.ensureScopeIdIsValid(sheetId);\n    if (this.namedExpressions.namedExpressionForScope(expressionName, sheetId) === undefined) {\n      throw new NamedExpressionDoesNotExistError(expressionName);\n    }\n  }\n  ensureItIsPossibleToAddRows(sheet, ...indexes) {\n    if (!this.sheetMapping.hasSheetWithId(sheet)) {\n      throw new NoSheetWithIdError(sheet);\n    }\n    const sheetHeight = this.dependencyGraph.getSheetHeight(sheet);\n    const newRowsCount = indexes.map(index => index[1]).reduce((a, b) => a + b, 0);\n    if (sheetHeight + newRowsCount > this.maxRows) {\n      throw new SheetSizeLimitExceededError();\n    }\n    for (const [row, numberOfRowsToAdd] of indexes) {\n      if (!isNonnegativeInteger(row) || !isPositiveInteger(numberOfRowsToAdd)) {\n        throw new InvalidArgumentsError('row number to be nonnegative and number of rows to add to be positive.');\n      }\n    }\n  }\n  ensureItIsPossibleToRemoveRows(sheet, ...indexes) {\n    for (const [rowStart, numberOfRows] of indexes) {\n      const rowEnd = rowStart + numberOfRows - 1;\n      if (!isNonnegativeInteger(rowStart) || !isNonnegativeInteger(rowEnd)) {\n        throw new InvalidArgumentsError('starting and ending row to be nonnegative.');\n      }\n      if (rowEnd < rowStart) {\n        throw new InvalidArgumentsError('starting row to be smaller than the ending row.');\n      }\n      if (!this.sheetMapping.hasSheetWithId(sheet)) {\n        throw new NoSheetWithIdError(sheet);\n      }\n    }\n  }\n  ensureItIsPossibleToAddColumns(sheet, ...indexes) {\n    if (!this.sheetMapping.hasSheetWithId(sheet)) {\n      throw new NoSheetWithIdError(sheet);\n    }\n    const sheetWidth = this.dependencyGraph.getSheetWidth(sheet);\n    const newColumnsCount = indexes.map(index => index[1]).reduce((a, b) => a + b, 0);\n    if (sheetWidth + newColumnsCount > this.maxColumns) {\n      throw new SheetSizeLimitExceededError();\n    }\n    for (const [column, numberOfColumnsToAdd] of indexes) {\n      if (!isNonnegativeInteger(column) || !isPositiveInteger(numberOfColumnsToAdd)) {\n        throw new InvalidArgumentsError('column number to be nonnegative and number of columns to add to be positive.');\n      }\n    }\n  }\n  ensureItIsPossibleToRemoveColumns(sheet, ...indexes) {\n    for (const [columnStart, numberOfColumns] of indexes) {\n      const columnEnd = columnStart + numberOfColumns - 1;\n      if (!isNonnegativeInteger(columnStart) || !isNonnegativeInteger(columnEnd)) {\n        throw new InvalidArgumentsError('starting and ending column to be nonnegative.');\n      }\n      if (columnEnd < columnStart) {\n        throw new InvalidArgumentsError('starting column to be smaller than the ending column.');\n      }\n      if (!this.sheetMapping.hasSheetWithId(sheet)) {\n        throw new NoSheetWithIdError(sheet);\n      }\n    }\n  }\n  ensureItIsPossibleToMoveRows(sheet, startRow, numberOfRows, targetRow) {\n    this.ensureItIsPossibleToAddRows(sheet, [targetRow, numberOfRows]);\n    const sourceStart = simpleCellAddress(sheet, 0, startRow);\n    const targetStart = simpleCellAddress(sheet, 0, targetRow);\n    if (!this.sheetMapping.hasSheetWithId(sheet) || invalidSimpleCellAddress(sourceStart) || invalidSimpleCellAddress(targetStart) || !isPositiveInteger(numberOfRows) || targetRow <= startRow + numberOfRows && targetRow >= startRow) {\n      throw new InvalidArgumentsError('a valid range of rows to move.');\n    }\n    const width = this.dependencyGraph.getSheetWidth(sheet);\n    const sourceRange = AbsoluteCellRange.spanFrom(sourceStart, width, numberOfRows);\n    if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(sourceRange)) {\n      throw new SourceLocationHasArrayError();\n    }\n    if (targetRow > 0 && this.dependencyGraph.arrayMapping.isFormulaArrayInAllRows(RowsSpan.fromNumberOfRows(sheet, targetRow - 1, 2))) {\n      throw new TargetLocationHasArrayError();\n    }\n  }\n  ensureItIsPossibleToMoveColumns(sheet, startColumn, numberOfColumns, targetColumn) {\n    this.ensureItIsPossibleToAddColumns(sheet, [targetColumn, numberOfColumns]);\n    const sourceStart = simpleCellAddress(sheet, startColumn, 0);\n    const targetStart = simpleCellAddress(sheet, targetColumn, 0);\n    if (!this.sheetMapping.hasSheetWithId(sheet) || invalidSimpleCellAddress(sourceStart) || invalidSimpleCellAddress(targetStart) || !isPositiveInteger(numberOfColumns) || targetColumn <= startColumn + numberOfColumns && targetColumn >= startColumn) {\n      throw new InvalidArgumentsError('a valid range of columns to move.');\n    }\n    const sheetHeight = this.dependencyGraph.getSheetHeight(sheet);\n    const sourceRange = AbsoluteCellRange.spanFrom(sourceStart, numberOfColumns, sheetHeight);\n    if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(sourceRange)) {\n      throw new SourceLocationHasArrayError();\n    }\n    if (targetColumn > 0 && this.dependencyGraph.arrayMapping.isFormulaArrayInAllColumns(ColumnsSpan.fromNumberOfColumns(sheet, targetColumn - 1, 2))) {\n      throw new TargetLocationHasArrayError();\n    }\n  }\n  ensureItIsPossibleToAddSheet(name) {\n    if (this.sheetMapping.hasSheetWithName(name)) {\n      throw new SheetNameAlreadyTakenError(name);\n    }\n  }\n  ensureItIsPossibleToRenameSheet(sheetId, name) {\n    if (!this.sheetMapping.hasSheetWithId(sheetId)) {\n      throw new NoSheetWithIdError(sheetId);\n    }\n    const existingSheetId = this.sheetMapping.get(name);\n    if (existingSheetId !== undefined && existingSheetId !== sheetId) {\n      throw new SheetNameAlreadyTakenError(name);\n    }\n  }\n  ensureItIsPossibleToChangeContent(address) {\n    if (invalidSimpleCellAddress(address)) {\n      throw new InvalidAddressError(address);\n    }\n    if (!this.sheetMapping.hasSheetWithId(address.sheet)) {\n      throw new NoSheetWithIdError(address.sheet);\n    }\n  }\n  ensureItIsPossibleToChangeCellContents(inputAddress, content) {\n    const boundaries = findBoundaries(content);\n    const targetRange = AbsoluteCellRange.spanFrom(inputAddress, boundaries.width, boundaries.height);\n    this.ensureRangeInSizeLimits(targetRange);\n    for (const address of targetRange.addresses(this.dependencyGraph)) {\n      this.ensureItIsPossibleToChangeContent(address);\n    }\n  }\n  ensureItIsPossibleToChangeSheetContents(sheetId, content) {\n    const boundaries = findBoundaries(content);\n    const targetRange = AbsoluteCellRange.spanFrom(simpleCellAddress(sheetId, 0, 0), boundaries.width, boundaries.height);\n    this.ensureRangeInSizeLimits(targetRange);\n  }\n  ensureRangeInSizeLimits(range) {\n    if (range.exceedsSheetSizeLimits(this.maxColumns, this.maxRows)) {\n      throw new SheetSizeLimitExceededError();\n    }\n  }\n  isThereSomethingToUndo() {\n    return !this.undoRedo.isUndoStackEmpty();\n  }\n  isThereSomethingToRedo() {\n    return !this.undoRedo.isRedoStackEmpty();\n  }\n  getAndClearContentChanges() {\n    return this.operations.getAndClearContentChanges();\n  }\n  ensureScopeIdIsValid(scopeId) {\n    if (scopeId !== undefined && !this.sheetMapping.hasSheetWithId(scopeId)) {\n      throw new NoSheetWithIdError(scopeId);\n    }\n  }\n  validateRowOrColumnMapping(sheetId, rowMapping, rowOrColumn) {\n    const limit = rowOrColumn === 'row' ? this.dependencyGraph.getSheetHeight(sheetId) : this.dependencyGraph.getSheetWidth(sheetId);\n    const sources = rowMapping.map(([a, _]) => a).sort((a, b) => a - b);\n    const targets = rowMapping.map(([_, b]) => b).sort((a, b) => a - b);\n    for (let i = 0; i < sources.length; i++) {\n      if (!isNonnegativeInteger(sources[i]) || sources[i] >= limit) {\n        throw new InvalidArgumentsError(`${rowOrColumn} numbers to be nonnegative integers and less than sheet ${rowOrColumn === 'row' ? 'height' : 'width'}.`);\n      }\n      if (sources[i] === sources[i + 1]) {\n        throw new InvalidArgumentsError(`source ${rowOrColumn} numbers to be unique.`);\n      }\n      if (sources[i] !== targets[i]) {\n        throw new InvalidArgumentsError(`target ${rowOrColumn} numbers to be permutation of source ${rowOrColumn} numbers.`);\n      }\n    }\n  }\n  ensureNamedExpressionNameIsValid(expressionName, sheetId) {\n    if (!this.namedExpressions.isNameValid(expressionName)) {\n      throw new NamedExpressionNameIsInvalidError(expressionName);\n    }\n    if (!this.namedExpressions.isNameAvailable(expressionName, sheetId)) {\n      throw new NamedExpressionNameIsAlreadyTakenError(expressionName);\n    }\n  }\n  ensureNamedExpressionIsValid(expression) {\n    const parsedExpression = this.cellContentParser.parse(expression);\n    if (parsedExpression instanceof CellContent.Formula) {\n      const parsingResult = this.parser.parse(parsedExpression.formula, simpleCellAddress(-1, 0, 0));\n      if (doesContainRelativeReferences(parsingResult.ast)) {\n        throw new NoRelativeAddressesAllowedError();\n      }\n    }\n  }\n}\nfunction isPositiveInteger(x) {\n  return Number.isInteger(x) && x > 0;\n}\nfunction isNonnegativeInteger(x) {\n  return Number.isInteger(x) && x >= 0;\n}","map":{"version":3,"names":["AbsoluteCellRange","invalidSimpleCellAddress","simpleCellAddress","CellContent","InvalidAddressError","InvalidArgumentsError","NamedExpressionDoesNotExistError","NamedExpressionNameIsAlreadyTakenError","NamedExpressionNameIsInvalidError","NoOperationToRedoError","NoOperationToUndoError","NoRelativeAddressesAllowedError","NoSheetWithIdError","NothingToPasteError","SheetNameAlreadyTakenError","SheetSizeLimitExceededError","SourceLocationHasArrayError","TargetLocationHasArrayError","doesContainRelativeReferences","AddColumnsCommand","AddRowsCommand","RemoveColumnsCommand","RemoveRowsCommand","findBoundaries","validateAsSheet","ColumnsSpan","RowsSpan","AddColumnsUndoEntry","AddNamedExpressionUndoEntry","AddRowsUndoEntry","AddSheetUndoEntry","ChangeNamedExpressionUndoEntry","ClearSheetUndoEntry","MoveCellsUndoEntry","MoveColumnsUndoEntry","MoveRowsUndoEntry","PasteUndoEntry","RemoveColumnsUndoEntry","RemoveNamedExpressionUndoEntry","RemoveRowsUndoEntry","RemoveSheetUndoEntry","RenameSheetUndoEntry","SetCellContentsUndoEntry","SetColumnOrderUndoEntry","SetRowOrderUndoEntry","SetSheetContentUndoEntry","CrudOperations","constructor","config","operations","undoRedo","clipboardOperations","dependencyGraph","columnSearch","parser","cellContentParser","lazilyTransformingAstService","namedExpressions","maxRows","maxColumns","sheetMapping","addRows","sheet","indexes","addRowsCommand","ensureItIsPossibleToAddRows","clearRedoStack","abortCut","saveOperation","removeRows","removeRowsCommand","ensureItIsPossibleToRemoveRows","rowsRemovals","addColumns","addColumnsCommand","ensureItIsPossibleToAddColumns","removeColumns","removeColumnsCommand","ensureItIsPossibleToRemoveColumns","columnsRemovals","moveCells","sourceLeftCorner","width","height","destinationLeftCorner","version","overwrittenCellsData","addedGlobalNamedExpressions","moveRows","startRow","numberOfRows","targetRow","ensureItIsPossibleToMoveRows","moveColumns","startColumn","numberOfColumns","targetColumn","ensureItIsPossibleToMoveColumns","cut","ensureItIsPossibleToCopy","isPositiveInteger","copy","paste","targetLeftCorner","clipboard","undefined","isCutClipboard","isCopyClipboard","ensureItIsPossibleToCopyPaste","targetRange","spanFrom","oldContent","getRangeClipboardCells","restoreClipboardCells","getContent","content","beginUndoRedoBatchMode","beginBatchMode","commitUndoRedoBatchMode","commitBatchMode","isClipboardEmpty","clearClipboard","clear","addSheet","name","ensureItIsPossibleToAddSheet","addedSheetName","removeSheet","sheetId","ensureScopeIdIsValid","originalName","fetchDisplayName","oldSheetContent","getSheetClipboardCells","scopedNamedExpressions","renameSheet","newName","ensureItIsPossibleToRenameSheet","oldName","clearSheet","setCellContents","topLeftCornerAddress","cellContents","Array","i","length","ensureItIsPossibleToChangeCellContents","oldContents","j","address","row","col","newContent","setCellContent","push","setSheetContent","values","ensureItIsPossibleToChangeSheetContents","setRowOrder","rowMapping","validateSwapRowIndexes","testRowOrderForArrays","hasSheetWithId","validateRowOrColumnMapping","testColumnOrderForArrays","columnMapping","source","target","rowRange","Infinity","arrayMapping","isFormulaArrayInRange","setColumnOrder","validateSwapColumnIndexes","mappingFromOrder","newOrder","rowOrColumn","limit","getSheetHeight","getSheetWidth","ret","undo","isUndoStackEmpty","redo","isRedoStackEmpty","addNamedExpression","expressionName","expression","options","ensureItIsPossibleToAddNamedExpression","changeNamedExpressionExpression","newExpression","ensureItIsPossibleToChangeNamedExpression","oldNamedExpression","removeNamedExpression","namedExpression","ensureNamedExpressionNameIsValid","ensureNamedExpressionIsValid","namedExpressionForScope","isItPossibleToRemoveNamedExpression","sheetHeight","newRowsCount","map","index","reduce","a","b","numberOfRowsToAdd","isNonnegativeInteger","rowStart","rowEnd","sheetWidth","newColumnsCount","column","numberOfColumnsToAdd","columnStart","columnEnd","sourceStart","targetStart","sourceRange","isFormulaArrayInAllRows","fromNumberOfRows","isFormulaArrayInAllColumns","fromNumberOfColumns","hasSheetWithName","existingSheetId","get","ensureItIsPossibleToChangeContent","inputAddress","boundaries","ensureRangeInSizeLimits","addresses","range","exceedsSheetSizeLimits","isThereSomethingToUndo","isThereSomethingToRedo","getAndClearContentChanges","scopeId","sources","_","sort","targets","isNameValid","isNameAvailable","parsedExpression","parse","Formula","parsingResult","formula","ast","x","Number","isInteger"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/CrudOperations.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from \"./AbsoluteCellRange.mjs\";\nimport { invalidSimpleCellAddress, simpleCellAddress } from \"./Cell.mjs\";\nimport { CellContent } from \"./CellContentParser.mjs\";\nimport { InvalidAddressError, InvalidArgumentsError, NamedExpressionDoesNotExistError, NamedExpressionNameIsAlreadyTakenError, NamedExpressionNameIsInvalidError, NoOperationToRedoError, NoOperationToUndoError, NoRelativeAddressesAllowedError, NoSheetWithIdError, NothingToPasteError, SheetNameAlreadyTakenError, SheetSizeLimitExceededError, SourceLocationHasArrayError, TargetLocationHasArrayError } from \"./errors.mjs\";\nimport { doesContainRelativeReferences } from \"./NamedExpressions.mjs\";\nimport { AddColumnsCommand, AddRowsCommand, RemoveColumnsCommand, RemoveRowsCommand } from \"./Operations.mjs\";\nimport { findBoundaries, validateAsSheet } from \"./Sheet.mjs\";\nimport { ColumnsSpan, RowsSpan } from \"./Span.mjs\";\nimport { AddColumnsUndoEntry, AddNamedExpressionUndoEntry, AddRowsUndoEntry, AddSheetUndoEntry, ChangeNamedExpressionUndoEntry, ClearSheetUndoEntry, MoveCellsUndoEntry, MoveColumnsUndoEntry, MoveRowsUndoEntry, PasteUndoEntry, RemoveColumnsUndoEntry, RemoveNamedExpressionUndoEntry, RemoveRowsUndoEntry, RemoveSheetUndoEntry, RenameSheetUndoEntry, SetCellContentsUndoEntry, SetColumnOrderUndoEntry, SetRowOrderUndoEntry, SetSheetContentUndoEntry } from \"./UndoRedo.mjs\";\nexport class CrudOperations {\n  constructor(config, operations, undoRedo, clipboardOperations, dependencyGraph, columnSearch, parser, cellContentParser, lazilyTransformingAstService, namedExpressions) {\n    this.operations = operations;\n    this.undoRedo = undoRedo;\n    this.clipboardOperations = clipboardOperations;\n    this.dependencyGraph = dependencyGraph;\n    this.columnSearch = columnSearch;\n    this.parser = parser;\n    this.cellContentParser = cellContentParser;\n    this.lazilyTransformingAstService = lazilyTransformingAstService;\n    this.namedExpressions = namedExpressions;\n    this.maxRows = config.maxRows;\n    this.maxColumns = config.maxColumns;\n  }\n  get sheetMapping() {\n    return this.dependencyGraph.sheetMapping;\n  }\n  addRows(sheet, ...indexes) {\n    const addRowsCommand = new AddRowsCommand(sheet, indexes);\n    this.ensureItIsPossibleToAddRows(sheet, ...indexes);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    this.operations.addRows(addRowsCommand);\n    this.undoRedo.saveOperation(new AddRowsUndoEntry(addRowsCommand));\n  }\n  removeRows(sheet, ...indexes) {\n    const removeRowsCommand = new RemoveRowsCommand(sheet, indexes);\n    this.ensureItIsPossibleToRemoveRows(sheet, ...indexes);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const rowsRemovals = this.operations.removeRows(removeRowsCommand);\n    this.undoRedo.saveOperation(new RemoveRowsUndoEntry(removeRowsCommand, rowsRemovals));\n  }\n  addColumns(sheet, ...indexes) {\n    const addColumnsCommand = new AddColumnsCommand(sheet, indexes);\n    this.ensureItIsPossibleToAddColumns(sheet, ...indexes);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    this.operations.addColumns(addColumnsCommand);\n    this.undoRedo.saveOperation(new AddColumnsUndoEntry(addColumnsCommand));\n  }\n  removeColumns(sheet, ...indexes) {\n    const removeColumnsCommand = new RemoveColumnsCommand(sheet, indexes);\n    this.ensureItIsPossibleToRemoveColumns(sheet, ...indexes);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const columnsRemovals = this.operations.removeColumns(removeColumnsCommand);\n    this.undoRedo.saveOperation(new RemoveColumnsUndoEntry(removeColumnsCommand, columnsRemovals));\n  }\n  moveCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const {\n      version,\n      overwrittenCellsData,\n      addedGlobalNamedExpressions\n    } = this.operations.moveCells(sourceLeftCorner, width, height, destinationLeftCorner);\n    this.undoRedo.saveOperation(new MoveCellsUndoEntry(sourceLeftCorner, width, height, destinationLeftCorner, overwrittenCellsData, addedGlobalNamedExpressions, version));\n  }\n  moveRows(sheet, startRow, numberOfRows, targetRow) {\n    this.ensureItIsPossibleToMoveRows(sheet, startRow, numberOfRows, targetRow);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const version = this.operations.moveRows(sheet, startRow, numberOfRows, targetRow);\n    this.undoRedo.saveOperation(new MoveRowsUndoEntry(sheet, startRow, numberOfRows, targetRow, version));\n  }\n  moveColumns(sheet, startColumn, numberOfColumns, targetColumn) {\n    this.ensureItIsPossibleToMoveColumns(sheet, startColumn, numberOfColumns, targetColumn);\n    this.undoRedo.clearRedoStack();\n    const version = this.operations.moveColumns(sheet, startColumn, numberOfColumns, targetColumn);\n    this.undoRedo.saveOperation(new MoveColumnsUndoEntry(sheet, startColumn, numberOfColumns, targetColumn, version));\n  }\n  cut(sourceLeftCorner, width, height) {\n    this.clipboardOperations.cut(sourceLeftCorner, width, height);\n  }\n  ensureItIsPossibleToCopy(sourceLeftCorner, width, height) {\n    if (!isPositiveInteger(width)) {\n      throw new InvalidArgumentsError('width to be positive integer.');\n    }\n    if (!isPositiveInteger(height)) {\n      throw new InvalidArgumentsError('height to be positive integer.');\n    }\n  }\n  copy(sourceLeftCorner, width, height) {\n    this.ensureItIsPossibleToCopy(sourceLeftCorner, width, height);\n    this.clipboardOperations.copy(sourceLeftCorner, width, height);\n  }\n  paste(targetLeftCorner) {\n    const clipboard = this.clipboardOperations.clipboard;\n    if (clipboard === undefined) {\n      throw new NothingToPasteError();\n    } else if (this.clipboardOperations.isCutClipboard()) {\n      this.moveCells(clipboard.sourceLeftCorner, clipboard.width, clipboard.height, targetLeftCorner);\n    } else if (this.clipboardOperations.isCopyClipboard()) {\n      this.clipboardOperations.ensureItIsPossibleToCopyPaste(targetLeftCorner);\n      const targetRange = AbsoluteCellRange.spanFrom(targetLeftCorner, clipboard.width, clipboard.height);\n      const oldContent = this.operations.getRangeClipboardCells(targetRange);\n      this.undoRedo.clearRedoStack();\n      const addedGlobalNamedExpressions = this.operations.restoreClipboardCells(clipboard.sourceLeftCorner.sheet, clipboard.getContent(targetLeftCorner));\n      this.undoRedo.saveOperation(new PasteUndoEntry(targetLeftCorner, oldContent, clipboard.content, addedGlobalNamedExpressions));\n    }\n  }\n  beginUndoRedoBatchMode() {\n    this.undoRedo.beginBatchMode();\n  }\n  commitUndoRedoBatchMode() {\n    this.undoRedo.commitBatchMode();\n  }\n  isClipboardEmpty() {\n    return this.clipboardOperations.clipboard === undefined;\n  }\n  clearClipboard() {\n    this.clipboardOperations.clear();\n  }\n  addSheet(name) {\n    if (name !== undefined) {\n      this.ensureItIsPossibleToAddSheet(name);\n    }\n    this.undoRedo.clearRedoStack();\n    const addedSheetName = this.operations.addSheet(name);\n    this.undoRedo.saveOperation(new AddSheetUndoEntry(addedSheetName));\n    return addedSheetName;\n  }\n  removeSheet(sheetId) {\n    this.ensureScopeIdIsValid(sheetId);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const originalName = this.sheetMapping.fetchDisplayName(sheetId);\n    const oldSheetContent = this.operations.getSheetClipboardCells(sheetId);\n    const {\n      version,\n      scopedNamedExpressions\n    } = this.operations.removeSheet(sheetId);\n    this.undoRedo.saveOperation(new RemoveSheetUndoEntry(originalName, sheetId, oldSheetContent, scopedNamedExpressions, version));\n  }\n  renameSheet(sheetId, newName) {\n    this.ensureItIsPossibleToRenameSheet(sheetId, newName);\n    const oldName = this.operations.renameSheet(sheetId, newName);\n    if (oldName !== undefined) {\n      this.undoRedo.clearRedoStack();\n      this.undoRedo.saveOperation(new RenameSheetUndoEntry(sheetId, oldName, newName));\n    }\n    return oldName;\n  }\n  clearSheet(sheetId) {\n    this.ensureScopeIdIsValid(sheetId);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const oldSheetContent = this.operations.getSheetClipboardCells(sheetId);\n    this.operations.clearSheet(sheetId);\n    this.undoRedo.saveOperation(new ClearSheetUndoEntry(sheetId, oldSheetContent));\n  }\n  setCellContents(topLeftCornerAddress, cellContents) {\n    if (!(cellContents instanceof Array)) {\n      cellContents = [[cellContents]];\n    } else {\n      for (let i = 0; i < cellContents.length; i++) {\n        if (!(cellContents[i] instanceof Array)) {\n          throw new InvalidArgumentsError('an array of arrays or a raw cell value.');\n        }\n      }\n    }\n    this.ensureItIsPossibleToChangeCellContents(topLeftCornerAddress, cellContents);\n    this.undoRedo.clearRedoStack();\n    const oldContents = [];\n    for (let i = 0; i < cellContents.length; i++) {\n      for (let j = 0; j < cellContents[i].length; j++) {\n        const address = {\n          sheet: topLeftCornerAddress.sheet,\n          row: topLeftCornerAddress.row + i,\n          col: topLeftCornerAddress.col + j\n        };\n        const newContent = cellContents[i][j];\n        this.clipboardOperations.abortCut();\n        const oldContent = this.operations.setCellContent(address, newContent);\n        oldContents.push({\n          address,\n          newContent,\n          oldContent\n        });\n      }\n    }\n    this.undoRedo.saveOperation(new SetCellContentsUndoEntry(oldContents));\n  }\n  setSheetContent(sheetId, values) {\n    this.ensureScopeIdIsValid(sheetId);\n    this.ensureItIsPossibleToChangeSheetContents(sheetId, values);\n    validateAsSheet(values);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const oldSheetContent = this.operations.getSheetClipboardCells(sheetId);\n    this.operations.setSheetContent(sheetId, values);\n    this.undoRedo.saveOperation(new SetSheetContentUndoEntry(sheetId, oldSheetContent, values));\n  }\n  setRowOrder(sheetId, rowMapping) {\n    this.validateSwapRowIndexes(sheetId, rowMapping);\n    this.testRowOrderForArrays(sheetId, rowMapping);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const oldContent = this.operations.setRowOrder(sheetId, rowMapping);\n    this.undoRedo.saveOperation(new SetRowOrderUndoEntry(sheetId, rowMapping, oldContent));\n  }\n  validateSwapRowIndexes(sheetId, rowMapping) {\n    if (!this.sheetMapping.hasSheetWithId(sheetId)) {\n      throw new NoSheetWithIdError(sheetId);\n    }\n    this.validateRowOrColumnMapping(sheetId, rowMapping, 'row');\n  }\n  testColumnOrderForArrays(sheetId, columnMapping) {\n    for (const [source, target] of columnMapping) {\n      if (source !== target) {\n        const rowRange = AbsoluteCellRange.spanFrom({\n          sheet: sheetId,\n          col: source,\n          row: 0\n        }, 1, Infinity);\n        if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(rowRange)) {\n          throw new SourceLocationHasArrayError();\n        }\n      }\n    }\n  }\n  setColumnOrder(sheetId, columnMapping) {\n    this.validateSwapColumnIndexes(sheetId, columnMapping);\n    this.testColumnOrderForArrays(sheetId, columnMapping);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const oldContent = this.operations.setColumnOrder(sheetId, columnMapping);\n    this.undoRedo.saveOperation(new SetColumnOrderUndoEntry(sheetId, columnMapping, oldContent));\n  }\n  validateSwapColumnIndexes(sheetId, columnMapping) {\n    if (!this.sheetMapping.hasSheetWithId(sheetId)) {\n      throw new NoSheetWithIdError(sheetId);\n    }\n    this.validateRowOrColumnMapping(sheetId, columnMapping, 'column');\n  }\n  testRowOrderForArrays(sheetId, rowMapping) {\n    for (const [source, target] of rowMapping) {\n      if (source !== target) {\n        const rowRange = AbsoluteCellRange.spanFrom({\n          sheet: sheetId,\n          col: 0,\n          row: source\n        }, Infinity, 1);\n        if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(rowRange)) {\n          throw new SourceLocationHasArrayError();\n        }\n      }\n    }\n  }\n  mappingFromOrder(sheetId, newOrder, rowOrColumn) {\n    if (!this.sheetMapping.hasSheetWithId(sheetId)) {\n      throw new NoSheetWithIdError(sheetId);\n    }\n    const limit = rowOrColumn === 'row' ? this.dependencyGraph.getSheetHeight(sheetId) : this.dependencyGraph.getSheetWidth(sheetId);\n    if (newOrder.length !== limit) {\n      throw new InvalidArgumentsError(`number of ${rowOrColumn}s provided to be sheet ${rowOrColumn === 'row' ? 'height' : 'width'}.`);\n    }\n    const ret = [];\n    for (let i = 0; i < limit; i++) {\n      if (newOrder[i] !== i) {\n        ret.push([i, newOrder[i]]);\n      }\n    }\n    return ret;\n  }\n  undo() {\n    if (this.undoRedo.isUndoStackEmpty()) {\n      throw new NoOperationToUndoError();\n    }\n    this.clipboardOperations.abortCut();\n    this.undoRedo.undo();\n  }\n  redo() {\n    if (this.undoRedo.isRedoStackEmpty()) {\n      throw new NoOperationToRedoError();\n    }\n    this.clipboardOperations.abortCut();\n    this.undoRedo.redo();\n  }\n  addNamedExpression(expressionName, expression, sheetId, options) {\n    this.ensureItIsPossibleToAddNamedExpression(expressionName, expression, sheetId);\n    this.operations.addNamedExpression(expressionName, expression, sheetId, options);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    this.undoRedo.saveOperation(new AddNamedExpressionUndoEntry(expressionName, expression, sheetId, options));\n  }\n  changeNamedExpressionExpression(expressionName, sheetId, newExpression, options) {\n    this.ensureItIsPossibleToChangeNamedExpression(expressionName, newExpression, sheetId);\n    const [oldNamedExpression, content] = this.operations.changeNamedExpressionExpression(expressionName, newExpression, sheetId, options);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    this.undoRedo.saveOperation(new ChangeNamedExpressionUndoEntry(oldNamedExpression, newExpression, content, sheetId, options));\n  }\n  removeNamedExpression(expressionName, sheetId) {\n    this.ensureScopeIdIsValid(sheetId);\n    const [namedExpression, content] = this.operations.removeNamedExpression(expressionName, sheetId);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    this.undoRedo.saveOperation(new RemoveNamedExpressionUndoEntry(namedExpression, content, sheetId));\n    return namedExpression;\n  }\n  ensureItIsPossibleToAddNamedExpression(expressionName, expression, sheetId) {\n    this.ensureScopeIdIsValid(sheetId);\n    this.ensureNamedExpressionNameIsValid(expressionName, sheetId);\n    this.ensureNamedExpressionIsValid(expression);\n  }\n  ensureItIsPossibleToChangeNamedExpression(expressionName, expression, sheetId) {\n    this.ensureScopeIdIsValid(sheetId);\n    if (this.namedExpressions.namedExpressionForScope(expressionName, sheetId) === undefined) {\n      throw new NamedExpressionDoesNotExistError(expressionName);\n    }\n    this.ensureNamedExpressionIsValid(expression);\n  }\n  isItPossibleToRemoveNamedExpression(expressionName, sheetId) {\n    this.ensureScopeIdIsValid(sheetId);\n    if (this.namedExpressions.namedExpressionForScope(expressionName, sheetId) === undefined) {\n      throw new NamedExpressionDoesNotExistError(expressionName);\n    }\n  }\n  ensureItIsPossibleToAddRows(sheet, ...indexes) {\n    if (!this.sheetMapping.hasSheetWithId(sheet)) {\n      throw new NoSheetWithIdError(sheet);\n    }\n    const sheetHeight = this.dependencyGraph.getSheetHeight(sheet);\n    const newRowsCount = indexes.map(index => index[1]).reduce((a, b) => a + b, 0);\n    if (sheetHeight + newRowsCount > this.maxRows) {\n      throw new SheetSizeLimitExceededError();\n    }\n    for (const [row, numberOfRowsToAdd] of indexes) {\n      if (!isNonnegativeInteger(row) || !isPositiveInteger(numberOfRowsToAdd)) {\n        throw new InvalidArgumentsError('row number to be nonnegative and number of rows to add to be positive.');\n      }\n    }\n  }\n  ensureItIsPossibleToRemoveRows(sheet, ...indexes) {\n    for (const [rowStart, numberOfRows] of indexes) {\n      const rowEnd = rowStart + numberOfRows - 1;\n      if (!isNonnegativeInteger(rowStart) || !isNonnegativeInteger(rowEnd)) {\n        throw new InvalidArgumentsError('starting and ending row to be nonnegative.');\n      }\n      if (rowEnd < rowStart) {\n        throw new InvalidArgumentsError('starting row to be smaller than the ending row.');\n      }\n      if (!this.sheetMapping.hasSheetWithId(sheet)) {\n        throw new NoSheetWithIdError(sheet);\n      }\n    }\n  }\n  ensureItIsPossibleToAddColumns(sheet, ...indexes) {\n    if (!this.sheetMapping.hasSheetWithId(sheet)) {\n      throw new NoSheetWithIdError(sheet);\n    }\n    const sheetWidth = this.dependencyGraph.getSheetWidth(sheet);\n    const newColumnsCount = indexes.map(index => index[1]).reduce((a, b) => a + b, 0);\n    if (sheetWidth + newColumnsCount > this.maxColumns) {\n      throw new SheetSizeLimitExceededError();\n    }\n    for (const [column, numberOfColumnsToAdd] of indexes) {\n      if (!isNonnegativeInteger(column) || !isPositiveInteger(numberOfColumnsToAdd)) {\n        throw new InvalidArgumentsError('column number to be nonnegative and number of columns to add to be positive.');\n      }\n    }\n  }\n  ensureItIsPossibleToRemoveColumns(sheet, ...indexes) {\n    for (const [columnStart, numberOfColumns] of indexes) {\n      const columnEnd = columnStart + numberOfColumns - 1;\n      if (!isNonnegativeInteger(columnStart) || !isNonnegativeInteger(columnEnd)) {\n        throw new InvalidArgumentsError('starting and ending column to be nonnegative.');\n      }\n      if (columnEnd < columnStart) {\n        throw new InvalidArgumentsError('starting column to be smaller than the ending column.');\n      }\n      if (!this.sheetMapping.hasSheetWithId(sheet)) {\n        throw new NoSheetWithIdError(sheet);\n      }\n    }\n  }\n  ensureItIsPossibleToMoveRows(sheet, startRow, numberOfRows, targetRow) {\n    this.ensureItIsPossibleToAddRows(sheet, [targetRow, numberOfRows]);\n    const sourceStart = simpleCellAddress(sheet, 0, startRow);\n    const targetStart = simpleCellAddress(sheet, 0, targetRow);\n    if (!this.sheetMapping.hasSheetWithId(sheet) || invalidSimpleCellAddress(sourceStart) || invalidSimpleCellAddress(targetStart) || !isPositiveInteger(numberOfRows) || targetRow <= startRow + numberOfRows && targetRow >= startRow) {\n      throw new InvalidArgumentsError('a valid range of rows to move.');\n    }\n    const width = this.dependencyGraph.getSheetWidth(sheet);\n    const sourceRange = AbsoluteCellRange.spanFrom(sourceStart, width, numberOfRows);\n    if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(sourceRange)) {\n      throw new SourceLocationHasArrayError();\n    }\n    if (targetRow > 0 && this.dependencyGraph.arrayMapping.isFormulaArrayInAllRows(RowsSpan.fromNumberOfRows(sheet, targetRow - 1, 2))) {\n      throw new TargetLocationHasArrayError();\n    }\n  }\n  ensureItIsPossibleToMoveColumns(sheet, startColumn, numberOfColumns, targetColumn) {\n    this.ensureItIsPossibleToAddColumns(sheet, [targetColumn, numberOfColumns]);\n    const sourceStart = simpleCellAddress(sheet, startColumn, 0);\n    const targetStart = simpleCellAddress(sheet, targetColumn, 0);\n    if (!this.sheetMapping.hasSheetWithId(sheet) || invalidSimpleCellAddress(sourceStart) || invalidSimpleCellAddress(targetStart) || !isPositiveInteger(numberOfColumns) || targetColumn <= startColumn + numberOfColumns && targetColumn >= startColumn) {\n      throw new InvalidArgumentsError('a valid range of columns to move.');\n    }\n    const sheetHeight = this.dependencyGraph.getSheetHeight(sheet);\n    const sourceRange = AbsoluteCellRange.spanFrom(sourceStart, numberOfColumns, sheetHeight);\n    if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(sourceRange)) {\n      throw new SourceLocationHasArrayError();\n    }\n    if (targetColumn > 0 && this.dependencyGraph.arrayMapping.isFormulaArrayInAllColumns(ColumnsSpan.fromNumberOfColumns(sheet, targetColumn - 1, 2))) {\n      throw new TargetLocationHasArrayError();\n    }\n  }\n  ensureItIsPossibleToAddSheet(name) {\n    if (this.sheetMapping.hasSheetWithName(name)) {\n      throw new SheetNameAlreadyTakenError(name);\n    }\n  }\n  ensureItIsPossibleToRenameSheet(sheetId, name) {\n    if (!this.sheetMapping.hasSheetWithId(sheetId)) {\n      throw new NoSheetWithIdError(sheetId);\n    }\n    const existingSheetId = this.sheetMapping.get(name);\n    if (existingSheetId !== undefined && existingSheetId !== sheetId) {\n      throw new SheetNameAlreadyTakenError(name);\n    }\n  }\n  ensureItIsPossibleToChangeContent(address) {\n    if (invalidSimpleCellAddress(address)) {\n      throw new InvalidAddressError(address);\n    }\n    if (!this.sheetMapping.hasSheetWithId(address.sheet)) {\n      throw new NoSheetWithIdError(address.sheet);\n    }\n  }\n  ensureItIsPossibleToChangeCellContents(inputAddress, content) {\n    const boundaries = findBoundaries(content);\n    const targetRange = AbsoluteCellRange.spanFrom(inputAddress, boundaries.width, boundaries.height);\n    this.ensureRangeInSizeLimits(targetRange);\n    for (const address of targetRange.addresses(this.dependencyGraph)) {\n      this.ensureItIsPossibleToChangeContent(address);\n    }\n  }\n  ensureItIsPossibleToChangeSheetContents(sheetId, content) {\n    const boundaries = findBoundaries(content);\n    const targetRange = AbsoluteCellRange.spanFrom(simpleCellAddress(sheetId, 0, 0), boundaries.width, boundaries.height);\n    this.ensureRangeInSizeLimits(targetRange);\n  }\n  ensureRangeInSizeLimits(range) {\n    if (range.exceedsSheetSizeLimits(this.maxColumns, this.maxRows)) {\n      throw new SheetSizeLimitExceededError();\n    }\n  }\n  isThereSomethingToUndo() {\n    return !this.undoRedo.isUndoStackEmpty();\n  }\n  isThereSomethingToRedo() {\n    return !this.undoRedo.isRedoStackEmpty();\n  }\n  getAndClearContentChanges() {\n    return this.operations.getAndClearContentChanges();\n  }\n  ensureScopeIdIsValid(scopeId) {\n    if (scopeId !== undefined && !this.sheetMapping.hasSheetWithId(scopeId)) {\n      throw new NoSheetWithIdError(scopeId);\n    }\n  }\n  validateRowOrColumnMapping(sheetId, rowMapping, rowOrColumn) {\n    const limit = rowOrColumn === 'row' ? this.dependencyGraph.getSheetHeight(sheetId) : this.dependencyGraph.getSheetWidth(sheetId);\n    const sources = rowMapping.map(([a, _]) => a).sort((a, b) => a - b);\n    const targets = rowMapping.map(([_, b]) => b).sort((a, b) => a - b);\n    for (let i = 0; i < sources.length; i++) {\n      if (!isNonnegativeInteger(sources[i]) || sources[i] >= limit) {\n        throw new InvalidArgumentsError(`${rowOrColumn} numbers to be nonnegative integers and less than sheet ${rowOrColumn === 'row' ? 'height' : 'width'}.`);\n      }\n      if (sources[i] === sources[i + 1]) {\n        throw new InvalidArgumentsError(`source ${rowOrColumn} numbers to be unique.`);\n      }\n      if (sources[i] !== targets[i]) {\n        throw new InvalidArgumentsError(`target ${rowOrColumn} numbers to be permutation of source ${rowOrColumn} numbers.`);\n      }\n    }\n  }\n  ensureNamedExpressionNameIsValid(expressionName, sheetId) {\n    if (!this.namedExpressions.isNameValid(expressionName)) {\n      throw new NamedExpressionNameIsInvalidError(expressionName);\n    }\n    if (!this.namedExpressions.isNameAvailable(expressionName, sheetId)) {\n      throw new NamedExpressionNameIsAlreadyTakenError(expressionName);\n    }\n  }\n  ensureNamedExpressionIsValid(expression) {\n    const parsedExpression = this.cellContentParser.parse(expression);\n    if (parsedExpression instanceof CellContent.Formula) {\n      const parsingResult = this.parser.parse(parsedExpression.formula, simpleCellAddress(-1, 0, 0));\n      if (doesContainRelativeReferences(parsingResult.ast)) {\n        throw new NoRelativeAddressesAllowedError();\n      }\n    }\n  }\n}\nfunction isPositiveInteger(x) {\n  return Number.isInteger(x) && x > 0;\n}\nfunction isNonnegativeInteger(x) {\n  return Number.isInteger(x) && x >= 0;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}