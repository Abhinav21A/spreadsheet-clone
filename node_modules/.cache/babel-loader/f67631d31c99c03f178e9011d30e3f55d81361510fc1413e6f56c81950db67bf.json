{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange, AbsoluteColumnRange, AbsoluteRowRange } from \"../AbsoluteCellRange.mjs\";\nimport { ArrayValue, NotComputedArray } from \"../ArrayValue.mjs\";\nimport { CellError, ErrorType, invalidSimpleCellAddress } from \"../Cell.mjs\";\nimport { ErrorMessage } from \"../error-message.mjs\"; // noinspection TypeScriptPreferShortImport\nimport { AstNodeType } from \"../parser/Ast.mjs\";\nimport { coerceRangeToScalar, coerceScalarToString, coerceToRange, fixNegativeZero, isNumberOverflow } from \"./ArithmeticHelper.mjs\";\nimport { CriterionBuilder } from \"./Criterion.mjs\";\nimport { FunctionRegistry } from \"./FunctionRegistry.mjs\";\nimport { InterpreterState } from \"./InterpreterState.mjs\";\nimport { cloneNumber, EmptyValue, getRawValue, isExtendedNumber } from \"./InterpreterValue.mjs\";\nimport { SimpleRangeValue } from \"../SimpleRangeValue.mjs\";\nexport class Interpreter {\n  constructor(config, dependencyGraph, columnSearch, stats, arithmeticHelper, functionRegistry, namedExpressions, serialization, arraySizePredictor, dateTimeHelper) {\n    this.config = config;\n    this.dependencyGraph = dependencyGraph;\n    this.columnSearch = columnSearch;\n    this.stats = stats;\n    this.arithmeticHelper = arithmeticHelper;\n    this.functionRegistry = functionRegistry;\n    this.namedExpressions = namedExpressions;\n    this.serialization = serialization;\n    this.arraySizePredictor = arraySizePredictor;\n    this.dateTimeHelper = dateTimeHelper;\n    this.equalOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.eq, arg1, arg2);\n    this.notEqualOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.neq, arg1, arg2);\n    this.greaterThanOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.gt, arg1, arg2);\n    this.lessThanOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.lt, arg1, arg2);\n    this.greaterThanOrEqualOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.geq, arg1, arg2);\n    this.lessThanOrEqualOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.leq, arg1, arg2);\n    this.concatOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.concat, coerceScalarToString(arg1), coerceScalarToString(arg2));\n    this.plusOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.addWithEpsilon, this.arithmeticHelper.coerceScalarToNumberOrError(arg1), this.arithmeticHelper.coerceScalarToNumberOrError(arg2));\n    this.minusOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.subtract, this.arithmeticHelper.coerceScalarToNumberOrError(arg1), this.arithmeticHelper.coerceScalarToNumberOrError(arg2));\n    this.timesOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.multiply, this.arithmeticHelper.coerceScalarToNumberOrError(arg1), this.arithmeticHelper.coerceScalarToNumberOrError(arg2));\n    this.powerOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.pow, this.arithmeticHelper.coerceScalarToNumberOrError(arg1), this.arithmeticHelper.coerceScalarToNumberOrError(arg2));\n    this.divOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.divide, this.arithmeticHelper.coerceScalarToNumberOrError(arg1), this.arithmeticHelper.coerceScalarToNumberOrError(arg2));\n    this.unaryMinusOp = arg => unaryErrorWrapper(this.arithmeticHelper.unaryMinus, this.arithmeticHelper.coerceScalarToNumberOrError(arg));\n    this.percentOp = arg => unaryErrorWrapper(this.arithmeticHelper.unaryPercent, this.arithmeticHelper.coerceScalarToNumberOrError(arg));\n    this.unaryPlusOp = arg => this.arithmeticHelper.unaryPlus(arg);\n    this.functionRegistry.initializePlugins(this);\n    this.criterionBuilder = new CriterionBuilder(config);\n  }\n  evaluateAst(ast, state) {\n    let val = this.evaluateAstWithoutPostprocessing(ast, state);\n    if (isExtendedNumber(val)) {\n      if (isNumberOverflow(getRawValue(val))) {\n        return new CellError(ErrorType.NUM, ErrorMessage.NaN);\n      } else {\n        val = cloneNumber(val, fixNegativeZero(getRawValue(val)));\n      }\n    }\n    if (val instanceof SimpleRangeValue && val.height() === 1 && val.width() === 1) {\n      [[val]] = val.data;\n    }\n    return wrapperForRootVertex(val, state.formulaVertex);\n  }\n  /**\r\n   * Calculates cell value from formula abstract syntax tree\r\n   *\r\n   * @param formula - abstract syntax tree of formula\r\n   * @param formulaAddress - address of the cell in which formula is located\r\n   */\n  evaluateAstWithoutPostprocessing(ast, state) {\n    switch (ast.type) {\n      case AstNodeType.EMPTY:\n        {\n          return EmptyValue;\n        }\n      case AstNodeType.CELL_REFERENCE:\n        {\n          const address = ast.reference.toSimpleCellAddress(state.formulaAddress);\n          if (invalidSimpleCellAddress(address)) {\n            return new CellError(ErrorType.REF, ErrorMessage.BadRef);\n          }\n          return this.dependencyGraph.getCellValue(address);\n        }\n      case AstNodeType.NUMBER:\n      case AstNodeType.STRING:\n        {\n          return ast.value;\n        }\n      case AstNodeType.CONCATENATE_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.concatOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.EQUALS_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.equalOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.NOT_EQUAL_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.notEqualOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.GREATER_THAN_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.greaterThanOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.LESS_THAN_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.lessThanOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.GREATER_THAN_OR_EQUAL_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.greaterThanOrEqualOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.LESS_THAN_OR_EQUAL_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.lessThanOrEqualOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.PLUS_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.plusOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.MINUS_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.minusOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.TIMES_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.timesOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.POWER_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.powerOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.DIV_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.divOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.PLUS_UNARY_OP:\n        {\n          const result = this.evaluateAst(ast.value, state);\n          return this.unaryRangeWrapper(this.unaryPlusOp, result, state);\n        }\n      case AstNodeType.MINUS_UNARY_OP:\n        {\n          const result = this.evaluateAst(ast.value, state);\n          return this.unaryRangeWrapper(this.unaryMinusOp, result, state);\n        }\n      case AstNodeType.PERCENT_OP:\n        {\n          const result = this.evaluateAst(ast.value, state);\n          return this.unaryRangeWrapper(this.percentOp, result, state);\n        }\n      case AstNodeType.FUNCTION_CALL:\n        {\n          if (this.config.licenseKeyValidityState !== \"valid\" /* VALID */ && !FunctionRegistry.functionIsProtected(ast.procedureName)) {\n            return new CellError(ErrorType.LIC, ErrorMessage.LicenseKey(this.config.licenseKeyValidityState));\n          }\n          const pluginFunction = this.functionRegistry.getFunction(ast.procedureName);\n          if (pluginFunction !== undefined) {\n            return pluginFunction(ast, new InterpreterState(state.formulaAddress, state.arraysFlag || this.functionRegistry.isArrayFunction(ast.procedureName), state.formulaVertex));\n          } else {\n            return new CellError(ErrorType.NAME, ErrorMessage.FunctionName(ast.procedureName));\n          }\n        }\n      case AstNodeType.NAMED_EXPRESSION:\n        {\n          const namedExpression = this.namedExpressions.nearestNamedExpression(ast.expressionName, state.formulaAddress.sheet);\n          if (namedExpression) {\n            return this.dependencyGraph.getCellValue(namedExpression.address);\n          } else {\n            return new CellError(ErrorType.NAME, ErrorMessage.NamedExpressionName(ast.expressionName));\n          }\n        }\n      case AstNodeType.CELL_RANGE:\n        {\n          if (!this.rangeSpansOneSheet(ast)) {\n            return new CellError(ErrorType.REF, ErrorMessage.RangeManySheets);\n          }\n          const range = AbsoluteCellRange.fromCellRange(ast, state.formulaAddress);\n          const arrayVertex = this.dependencyGraph.getArray(range);\n          if (arrayVertex) {\n            const array = arrayVertex.array;\n            if (array instanceof NotComputedArray) {\n              throw new Error('Array should be already computed');\n            } else if (array instanceof CellError) {\n              return array;\n            } else if (array instanceof ArrayValue) {\n              return SimpleRangeValue.fromRange(array.raw(), range, this.dependencyGraph);\n            } else {\n              throw new Error('Unknown array');\n            }\n          } else {\n            return SimpleRangeValue.onlyRange(range, this.dependencyGraph);\n          }\n        }\n      case AstNodeType.COLUMN_RANGE:\n        {\n          if (!this.rangeSpansOneSheet(ast)) {\n            return new CellError(ErrorType.REF, ErrorMessage.RangeManySheets);\n          }\n          const range = AbsoluteColumnRange.fromColumnRange(ast, state.formulaAddress);\n          return SimpleRangeValue.onlyRange(range, this.dependencyGraph);\n        }\n      case AstNodeType.ROW_RANGE:\n        {\n          if (!this.rangeSpansOneSheet(ast)) {\n            return new CellError(ErrorType.REF, ErrorMessage.RangeManySheets);\n          }\n          const range = AbsoluteRowRange.fromRowRangeAst(ast, state.formulaAddress);\n          return SimpleRangeValue.onlyRange(range, this.dependencyGraph);\n        }\n      case AstNodeType.PARENTHESIS:\n        {\n          return this.evaluateAst(ast.expression, state);\n        }\n      case AstNodeType.ARRAY:\n        {\n          let totalWidth = undefined;\n          const ret = [];\n          for (const astRow of ast.args) {\n            let rowHeight = undefined;\n            const rowRet = [];\n            for (const astIt of astRow) {\n              const arr = coerceToRange(this.evaluateAst(astIt, state));\n              const height = arr.height();\n              if (rowHeight === undefined) {\n                rowHeight = height;\n                rowRet.push(...arr.data);\n              } else if (rowHeight === height) {\n                for (let i = 0; i < height; i++) {\n                  rowRet[i].push(...arr.data[i]);\n                }\n              } else {\n                return new CellError(ErrorType.REF, ErrorMessage.SizeMismatch);\n              }\n            }\n            const width = rowRet[0].length;\n            if (totalWidth === undefined) {\n              totalWidth = width;\n              ret.push(...rowRet);\n            } else if (totalWidth === width) {\n              ret.push(...rowRet);\n            } else {\n              return new CellError(ErrorType.REF, ErrorMessage.SizeMismatch);\n            }\n          }\n          return SimpleRangeValue.onlyValues(ret);\n        }\n      case AstNodeType.ERROR_WITH_RAW_INPUT:\n      case AstNodeType.ERROR:\n        {\n          return ast.error;\n        }\n    }\n  }\n  rangeSpansOneSheet(ast) {\n    return ast.start.sheet === ast.end.sheet;\n  }\n  unaryRangeWrapper(op, arg, state) {\n    var _a;\n    if (arg instanceof SimpleRangeValue && !state.arraysFlag) {\n      arg = (_a = coerceRangeToScalar(arg, state)) !== null && _a !== void 0 ? _a : new CellError(ErrorType.VALUE, ErrorMessage.ScalarExpected);\n    }\n    if (arg instanceof CellError) {\n      return arg;\n    }\n    if (arg instanceof SimpleRangeValue) {\n      const newRaw = arg.data.map(row => row.map(op));\n      return SimpleRangeValue.onlyValues(newRaw);\n    }\n    return op(arg);\n  }\n  binaryRangeWrapper(op, arg1, arg2, state) {\n    var _a, _b;\n    if (arg1 instanceof SimpleRangeValue && !state.arraysFlag) {\n      arg1 = (_a = coerceRangeToScalar(arg1, state)) !== null && _a !== void 0 ? _a : new CellError(ErrorType.VALUE, ErrorMessage.ScalarExpected);\n    }\n    if (arg1 instanceof CellError) {\n      return arg1;\n    }\n    if (arg2 instanceof SimpleRangeValue && !state.arraysFlag) {\n      arg2 = (_b = coerceRangeToScalar(arg2, state)) !== null && _b !== void 0 ? _b : new CellError(ErrorType.VALUE, ErrorMessage.ScalarExpected);\n    }\n    if (arg2 instanceof CellError) {\n      return arg2;\n    }\n    if (arg1 instanceof SimpleRangeValue || arg2 instanceof SimpleRangeValue) {\n      if (!(arg1 instanceof SimpleRangeValue)) {\n        if (arg2.isAdHoc()) {\n          const raw2 = arg2.data;\n          for (let i = 0; i < raw2.length; i++) {\n            for (let j = 0; j < raw2[0].length; j++) {\n              raw2[i][j] = op(arg1, raw2[i][j]);\n            }\n          }\n          return SimpleRangeValue.onlyValues(raw2);\n        } else {\n          arg1 = SimpleRangeValue.fromScalar(arg1);\n        }\n      }\n      if (!(arg2 instanceof SimpleRangeValue)) {\n        if (arg1.isAdHoc()) {\n          const raw1 = arg1.data;\n          for (let i = 0; i < raw1.length; i++) {\n            for (let j = 0; j < raw1[0].length; j++) {\n              raw1[i][j] = op(raw1[i][j], arg2);\n            }\n          }\n          return SimpleRangeValue.onlyValues(raw1);\n        } else {\n          arg2 = SimpleRangeValue.fromScalar(arg2);\n        }\n      }\n      if (arg1.width() === arg2.width() && arg1.height() === arg2.height()) {\n        if (arg1.isAdHoc()) {\n          const raw1 = arg1.data;\n          const raw2 = arg2.data;\n          for (let i = 0; i < raw1.length; i++) {\n            for (let j = 0; j < raw1[0].length; j++) {\n              raw1[i][j] = op(raw1[i][j], raw2[i][j]);\n            }\n          }\n          return SimpleRangeValue.onlyValues(raw1);\n        }\n        if (arg2.isAdHoc()) {\n          const raw1 = arg1.data;\n          const raw2 = arg2.data;\n          for (let i = 0; i < raw1.length; i++) {\n            for (let j = 0; j < raw1[0].length; j++) {\n              raw2[i][j] = op(raw1[i][j], raw2[i][j]);\n            }\n          }\n          return SimpleRangeValue.onlyValues(raw2);\n        }\n      }\n      const width = Math.max(arg1.width(), arg2.width());\n      const height = Math.max(arg1.height(), arg2.height());\n      const ret = Array(height);\n      for (let i = 0; i < height; i++) {\n        ret[i] = Array(width);\n      }\n      for (let i = 0; i < height; i++) {\n        const i1 = arg1.height() !== 1 ? i : 0;\n        const i2 = arg2.height() !== 1 ? i : 0;\n        for (let j = 0; j < width; j++) {\n          const j1 = arg1.width() !== 1 ? j : 0;\n          const j2 = arg2.width() !== 1 ? j : 0;\n          if (i1 < arg1.height() && i2 < arg2.height() && j1 < arg1.width() && j2 < arg2.width()) {\n            ret[i][j] = op(arg1.data[i1][j1], arg2.data[i2][j2]);\n          } else {\n            ret[i][j] = new CellError(ErrorType.NA);\n          }\n        }\n      }\n      return SimpleRangeValue.onlyValues(ret);\n    }\n    return op(arg1, arg2);\n  }\n}\nfunction unaryErrorWrapper(op, arg) {\n  if (arg instanceof CellError) {\n    return arg;\n  } else {\n    return op(arg);\n  }\n}\nfunction binaryErrorWrapper(op, arg1, arg2) {\n  if (arg1 instanceof CellError) {\n    return arg1;\n  } else if (arg2 instanceof CellError) {\n    return arg2;\n  } else {\n    return op(arg1, arg2);\n  }\n}\nfunction wrapperForRootVertex(val, vertex) {\n  if (val instanceof CellError && vertex !== undefined) {\n    return val.attachRootVertex(vertex);\n  }\n  return val;\n}","map":{"version":3,"names":["AbsoluteCellRange","AbsoluteColumnRange","AbsoluteRowRange","ArrayValue","NotComputedArray","CellError","ErrorType","invalidSimpleCellAddress","ErrorMessage","AstNodeType","coerceRangeToScalar","coerceScalarToString","coerceToRange","fixNegativeZero","isNumberOverflow","CriterionBuilder","FunctionRegistry","InterpreterState","cloneNumber","EmptyValue","getRawValue","isExtendedNumber","SimpleRangeValue","Interpreter","constructor","config","dependencyGraph","columnSearch","stats","arithmeticHelper","functionRegistry","namedExpressions","serialization","arraySizePredictor","dateTimeHelper","equalOp","arg1","arg2","binaryErrorWrapper","eq","notEqualOp","neq","greaterThanOp","gt","lessThanOp","lt","greaterThanOrEqualOp","geq","lessThanOrEqualOp","leq","concatOp","concat","plusOp","addWithEpsilon","coerceScalarToNumberOrError","minusOp","subtract","timesOp","multiply","powerOp","pow","divOp","divide","unaryMinusOp","arg","unaryErrorWrapper","unaryMinus","percentOp","unaryPercent","unaryPlusOp","unaryPlus","initializePlugins","criterionBuilder","evaluateAst","ast","state","val","evaluateAstWithoutPostprocessing","NUM","NaN","height","width","data","wrapperForRootVertex","formulaVertex","type","EMPTY","CELL_REFERENCE","address","reference","toSimpleCellAddress","formulaAddress","REF","BadRef","getCellValue","NUMBER","STRING","value","CONCATENATE_OP","leftResult","left","rightResult","right","binaryRangeWrapper","EQUALS_OP","NOT_EQUAL_OP","GREATER_THAN_OP","LESS_THAN_OP","GREATER_THAN_OR_EQUAL_OP","LESS_THAN_OR_EQUAL_OP","PLUS_OP","MINUS_OP","TIMES_OP","POWER_OP","DIV_OP","PLUS_UNARY_OP","result","unaryRangeWrapper","MINUS_UNARY_OP","PERCENT_OP","FUNCTION_CALL","licenseKeyValidityState","functionIsProtected","procedureName","LIC","LicenseKey","pluginFunction","getFunction","undefined","arraysFlag","isArrayFunction","NAME","FunctionName","NAMED_EXPRESSION","namedExpression","nearestNamedExpression","expressionName","sheet","NamedExpressionName","CELL_RANGE","rangeSpansOneSheet","RangeManySheets","range","fromCellRange","arrayVertex","getArray","array","Error","fromRange","raw","onlyRange","COLUMN_RANGE","fromColumnRange","ROW_RANGE","fromRowRangeAst","PARENTHESIS","expression","ARRAY","totalWidth","ret","astRow","args","rowHeight","rowRet","astIt","arr","push","i","SizeMismatch","length","onlyValues","ERROR_WITH_RAW_INPUT","ERROR","error","start","end","op","_a","VALUE","ScalarExpected","newRaw","map","row","_b","isAdHoc","raw2","j","fromScalar","raw1","Math","max","Array","i1","i2","j1","j2","NA","vertex","attachRootVertex"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/interpreter/Interpreter.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange, AbsoluteColumnRange, AbsoluteRowRange } from \"../AbsoluteCellRange.mjs\";\nimport { ArrayValue, NotComputedArray } from \"../ArrayValue.mjs\";\nimport { CellError, ErrorType, invalidSimpleCellAddress } from \"../Cell.mjs\";\nimport { ErrorMessage } from \"../error-message.mjs\"; // noinspection TypeScriptPreferShortImport\nimport { AstNodeType } from \"../parser/Ast.mjs\";\nimport { coerceRangeToScalar, coerceScalarToString, coerceToRange, fixNegativeZero, isNumberOverflow } from \"./ArithmeticHelper.mjs\";\nimport { CriterionBuilder } from \"./Criterion.mjs\";\nimport { FunctionRegistry } from \"./FunctionRegistry.mjs\";\nimport { InterpreterState } from \"./InterpreterState.mjs\";\nimport { cloneNumber, EmptyValue, getRawValue, isExtendedNumber } from \"./InterpreterValue.mjs\";\nimport { SimpleRangeValue } from \"../SimpleRangeValue.mjs\";\nexport class Interpreter {\n  constructor(config, dependencyGraph, columnSearch, stats, arithmeticHelper, functionRegistry, namedExpressions, serialization, arraySizePredictor, dateTimeHelper) {\n    this.config = config;\n    this.dependencyGraph = dependencyGraph;\n    this.columnSearch = columnSearch;\n    this.stats = stats;\n    this.arithmeticHelper = arithmeticHelper;\n    this.functionRegistry = functionRegistry;\n    this.namedExpressions = namedExpressions;\n    this.serialization = serialization;\n    this.arraySizePredictor = arraySizePredictor;\n    this.dateTimeHelper = dateTimeHelper;\n    this.equalOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.eq, arg1, arg2);\n    this.notEqualOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.neq, arg1, arg2);\n    this.greaterThanOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.gt, arg1, arg2);\n    this.lessThanOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.lt, arg1, arg2);\n    this.greaterThanOrEqualOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.geq, arg1, arg2);\n    this.lessThanOrEqualOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.leq, arg1, arg2);\n    this.concatOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.concat, coerceScalarToString(arg1), coerceScalarToString(arg2));\n    this.plusOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.addWithEpsilon, this.arithmeticHelper.coerceScalarToNumberOrError(arg1), this.arithmeticHelper.coerceScalarToNumberOrError(arg2));\n    this.minusOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.subtract, this.arithmeticHelper.coerceScalarToNumberOrError(arg1), this.arithmeticHelper.coerceScalarToNumberOrError(arg2));\n    this.timesOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.multiply, this.arithmeticHelper.coerceScalarToNumberOrError(arg1), this.arithmeticHelper.coerceScalarToNumberOrError(arg2));\n    this.powerOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.pow, this.arithmeticHelper.coerceScalarToNumberOrError(arg1), this.arithmeticHelper.coerceScalarToNumberOrError(arg2));\n    this.divOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.divide, this.arithmeticHelper.coerceScalarToNumberOrError(arg1), this.arithmeticHelper.coerceScalarToNumberOrError(arg2));\n    this.unaryMinusOp = arg => unaryErrorWrapper(this.arithmeticHelper.unaryMinus, this.arithmeticHelper.coerceScalarToNumberOrError(arg));\n    this.percentOp = arg => unaryErrorWrapper(this.arithmeticHelper.unaryPercent, this.arithmeticHelper.coerceScalarToNumberOrError(arg));\n    this.unaryPlusOp = arg => this.arithmeticHelper.unaryPlus(arg);\n    this.functionRegistry.initializePlugins(this);\n    this.criterionBuilder = new CriterionBuilder(config);\n  }\n  evaluateAst(ast, state) {\n    let val = this.evaluateAstWithoutPostprocessing(ast, state);\n    if (isExtendedNumber(val)) {\n      if (isNumberOverflow(getRawValue(val))) {\n        return new CellError(ErrorType.NUM, ErrorMessage.NaN);\n      } else {\n        val = cloneNumber(val, fixNegativeZero(getRawValue(val)));\n      }\n    }\n    if (val instanceof SimpleRangeValue && val.height() === 1 && val.width() === 1) {\n      [[val]] = val.data;\n    }\n    return wrapperForRootVertex(val, state.formulaVertex);\n  }\n  /**\r\n   * Calculates cell value from formula abstract syntax tree\r\n   *\r\n   * @param formula - abstract syntax tree of formula\r\n   * @param formulaAddress - address of the cell in which formula is located\r\n   */\n  evaluateAstWithoutPostprocessing(ast, state) {\n    switch (ast.type) {\n      case AstNodeType.EMPTY:\n        {\n          return EmptyValue;\n        }\n      case AstNodeType.CELL_REFERENCE:\n        {\n          const address = ast.reference.toSimpleCellAddress(state.formulaAddress);\n          if (invalidSimpleCellAddress(address)) {\n            return new CellError(ErrorType.REF, ErrorMessage.BadRef);\n          }\n          return this.dependencyGraph.getCellValue(address);\n        }\n      case AstNodeType.NUMBER:\n      case AstNodeType.STRING:\n        {\n          return ast.value;\n        }\n      case AstNodeType.CONCATENATE_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.concatOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.EQUALS_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.equalOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.NOT_EQUAL_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.notEqualOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.GREATER_THAN_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.greaterThanOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.LESS_THAN_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.lessThanOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.GREATER_THAN_OR_EQUAL_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.greaterThanOrEqualOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.LESS_THAN_OR_EQUAL_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.lessThanOrEqualOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.PLUS_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.plusOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.MINUS_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.minusOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.TIMES_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.timesOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.POWER_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.powerOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.DIV_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.divOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.PLUS_UNARY_OP:\n        {\n          const result = this.evaluateAst(ast.value, state);\n          return this.unaryRangeWrapper(this.unaryPlusOp, result, state);\n        }\n      case AstNodeType.MINUS_UNARY_OP:\n        {\n          const result = this.evaluateAst(ast.value, state);\n          return this.unaryRangeWrapper(this.unaryMinusOp, result, state);\n        }\n      case AstNodeType.PERCENT_OP:\n        {\n          const result = this.evaluateAst(ast.value, state);\n          return this.unaryRangeWrapper(this.percentOp, result, state);\n        }\n      case AstNodeType.FUNCTION_CALL:\n        {\n          if (this.config.licenseKeyValidityState !== \"valid\" /* VALID */ && !FunctionRegistry.functionIsProtected(ast.procedureName)) {\n            return new CellError(ErrorType.LIC, ErrorMessage.LicenseKey(this.config.licenseKeyValidityState));\n          }\n          const pluginFunction = this.functionRegistry.getFunction(ast.procedureName);\n          if (pluginFunction !== undefined) {\n            return pluginFunction(ast, new InterpreterState(state.formulaAddress, state.arraysFlag || this.functionRegistry.isArrayFunction(ast.procedureName), state.formulaVertex));\n          } else {\n            return new CellError(ErrorType.NAME, ErrorMessage.FunctionName(ast.procedureName));\n          }\n        }\n      case AstNodeType.NAMED_EXPRESSION:\n        {\n          const namedExpression = this.namedExpressions.nearestNamedExpression(ast.expressionName, state.formulaAddress.sheet);\n          if (namedExpression) {\n            return this.dependencyGraph.getCellValue(namedExpression.address);\n          } else {\n            return new CellError(ErrorType.NAME, ErrorMessage.NamedExpressionName(ast.expressionName));\n          }\n        }\n      case AstNodeType.CELL_RANGE:\n        {\n          if (!this.rangeSpansOneSheet(ast)) {\n            return new CellError(ErrorType.REF, ErrorMessage.RangeManySheets);\n          }\n          const range = AbsoluteCellRange.fromCellRange(ast, state.formulaAddress);\n          const arrayVertex = this.dependencyGraph.getArray(range);\n          if (arrayVertex) {\n            const array = arrayVertex.array;\n            if (array instanceof NotComputedArray) {\n              throw new Error('Array should be already computed');\n            } else if (array instanceof CellError) {\n              return array;\n            } else if (array instanceof ArrayValue) {\n              return SimpleRangeValue.fromRange(array.raw(), range, this.dependencyGraph);\n            } else {\n              throw new Error('Unknown array');\n            }\n          } else {\n            return SimpleRangeValue.onlyRange(range, this.dependencyGraph);\n          }\n        }\n      case AstNodeType.COLUMN_RANGE:\n        {\n          if (!this.rangeSpansOneSheet(ast)) {\n            return new CellError(ErrorType.REF, ErrorMessage.RangeManySheets);\n          }\n          const range = AbsoluteColumnRange.fromColumnRange(ast, state.formulaAddress);\n          return SimpleRangeValue.onlyRange(range, this.dependencyGraph);\n        }\n      case AstNodeType.ROW_RANGE:\n        {\n          if (!this.rangeSpansOneSheet(ast)) {\n            return new CellError(ErrorType.REF, ErrorMessage.RangeManySheets);\n          }\n          const range = AbsoluteRowRange.fromRowRangeAst(ast, state.formulaAddress);\n          return SimpleRangeValue.onlyRange(range, this.dependencyGraph);\n        }\n      case AstNodeType.PARENTHESIS:\n        {\n          return this.evaluateAst(ast.expression, state);\n        }\n      case AstNodeType.ARRAY:\n        {\n          let totalWidth = undefined;\n          const ret = [];\n          for (const astRow of ast.args) {\n            let rowHeight = undefined;\n            const rowRet = [];\n            for (const astIt of astRow) {\n              const arr = coerceToRange(this.evaluateAst(astIt, state));\n              const height = arr.height();\n              if (rowHeight === undefined) {\n                rowHeight = height;\n                rowRet.push(...arr.data);\n              } else if (rowHeight === height) {\n                for (let i = 0; i < height; i++) {\n                  rowRet[i].push(...arr.data[i]);\n                }\n              } else {\n                return new CellError(ErrorType.REF, ErrorMessage.SizeMismatch);\n              }\n            }\n            const width = rowRet[0].length;\n            if (totalWidth === undefined) {\n              totalWidth = width;\n              ret.push(...rowRet);\n            } else if (totalWidth === width) {\n              ret.push(...rowRet);\n            } else {\n              return new CellError(ErrorType.REF, ErrorMessage.SizeMismatch);\n            }\n          }\n          return SimpleRangeValue.onlyValues(ret);\n        }\n      case AstNodeType.ERROR_WITH_RAW_INPUT:\n      case AstNodeType.ERROR:\n        {\n          return ast.error;\n        }\n    }\n  }\n  rangeSpansOneSheet(ast) {\n    return ast.start.sheet === ast.end.sheet;\n  }\n  unaryRangeWrapper(op, arg, state) {\n    var _a;\n    if (arg instanceof SimpleRangeValue && !state.arraysFlag) {\n      arg = (_a = coerceRangeToScalar(arg, state)) !== null && _a !== void 0 ? _a : new CellError(ErrorType.VALUE, ErrorMessage.ScalarExpected);\n    }\n    if (arg instanceof CellError) {\n      return arg;\n    }\n    if (arg instanceof SimpleRangeValue) {\n      const newRaw = arg.data.map(row => row.map(op));\n      return SimpleRangeValue.onlyValues(newRaw);\n    }\n    return op(arg);\n  }\n  binaryRangeWrapper(op, arg1, arg2, state) {\n    var _a, _b;\n    if (arg1 instanceof SimpleRangeValue && !state.arraysFlag) {\n      arg1 = (_a = coerceRangeToScalar(arg1, state)) !== null && _a !== void 0 ? _a : new CellError(ErrorType.VALUE, ErrorMessage.ScalarExpected);\n    }\n    if (arg1 instanceof CellError) {\n      return arg1;\n    }\n    if (arg2 instanceof SimpleRangeValue && !state.arraysFlag) {\n      arg2 = (_b = coerceRangeToScalar(arg2, state)) !== null && _b !== void 0 ? _b : new CellError(ErrorType.VALUE, ErrorMessage.ScalarExpected);\n    }\n    if (arg2 instanceof CellError) {\n      return arg2;\n    }\n    if (arg1 instanceof SimpleRangeValue || arg2 instanceof SimpleRangeValue) {\n      if (!(arg1 instanceof SimpleRangeValue)) {\n        if (arg2.isAdHoc()) {\n          const raw2 = arg2.data;\n          for (let i = 0; i < raw2.length; i++) {\n            for (let j = 0; j < raw2[0].length; j++) {\n              raw2[i][j] = op(arg1, raw2[i][j]);\n            }\n          }\n          return SimpleRangeValue.onlyValues(raw2);\n        } else {\n          arg1 = SimpleRangeValue.fromScalar(arg1);\n        }\n      }\n      if (!(arg2 instanceof SimpleRangeValue)) {\n        if (arg1.isAdHoc()) {\n          const raw1 = arg1.data;\n          for (let i = 0; i < raw1.length; i++) {\n            for (let j = 0; j < raw1[0].length; j++) {\n              raw1[i][j] = op(raw1[i][j], arg2);\n            }\n          }\n          return SimpleRangeValue.onlyValues(raw1);\n        } else {\n          arg2 = SimpleRangeValue.fromScalar(arg2);\n        }\n      }\n      if (arg1.width() === arg2.width() && arg1.height() === arg2.height()) {\n        if (arg1.isAdHoc()) {\n          const raw1 = arg1.data;\n          const raw2 = arg2.data;\n          for (let i = 0; i < raw1.length; i++) {\n            for (let j = 0; j < raw1[0].length; j++) {\n              raw1[i][j] = op(raw1[i][j], raw2[i][j]);\n            }\n          }\n          return SimpleRangeValue.onlyValues(raw1);\n        }\n        if (arg2.isAdHoc()) {\n          const raw1 = arg1.data;\n          const raw2 = arg2.data;\n          for (let i = 0; i < raw1.length; i++) {\n            for (let j = 0; j < raw1[0].length; j++) {\n              raw2[i][j] = op(raw1[i][j], raw2[i][j]);\n            }\n          }\n          return SimpleRangeValue.onlyValues(raw2);\n        }\n      }\n      const width = Math.max(arg1.width(), arg2.width());\n      const height = Math.max(arg1.height(), arg2.height());\n      const ret = Array(height);\n      for (let i = 0; i < height; i++) {\n        ret[i] = Array(width);\n      }\n      for (let i = 0; i < height; i++) {\n        const i1 = arg1.height() !== 1 ? i : 0;\n        const i2 = arg2.height() !== 1 ? i : 0;\n        for (let j = 0; j < width; j++) {\n          const j1 = arg1.width() !== 1 ? j : 0;\n          const j2 = arg2.width() !== 1 ? j : 0;\n          if (i1 < arg1.height() && i2 < arg2.height() && j1 < arg1.width() && j2 < arg2.width()) {\n            ret[i][j] = op(arg1.data[i1][j1], arg2.data[i2][j2]);\n          } else {\n            ret[i][j] = new CellError(ErrorType.NA);\n          }\n        }\n      }\n      return SimpleRangeValue.onlyValues(ret);\n    }\n    return op(arg1, arg2);\n  }\n}\nfunction unaryErrorWrapper(op, arg) {\n  if (arg instanceof CellError) {\n    return arg;\n  } else {\n    return op(arg);\n  }\n}\nfunction binaryErrorWrapper(op, arg1, arg2) {\n  if (arg1 instanceof CellError) {\n    return arg1;\n  } else if (arg2 instanceof CellError) {\n    return arg2;\n  } else {\n    return op(arg1, arg2);\n  }\n}\nfunction wrapperForRootVertex(val, vertex) {\n  if (val instanceof CellError && vertex !== undefined) {\n    return val.attachRootVertex(vertex);\n  }\n  return val;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}