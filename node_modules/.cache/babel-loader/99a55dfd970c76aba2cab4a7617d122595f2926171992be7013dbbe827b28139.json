{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { TIME_FORMAT_SECONDS_ITEM_REGEXP } from \"../DateTimeDefault.mjs\";\nimport { numberToSimpleTime } from \"../DateTimeHelper.mjs\";\nimport { parseForDateTimeFormat, parseForNumberFormat, TokenType } from \"./parser.mjs\";\nexport function format(value, formatArg, config, dateHelper) {\n  const tryDateTime = config.stringifyDateTime(dateHelper.numberToSimpleDateTime(value), formatArg); // default points to defaultStringifyDateTime()\n  if (tryDateTime !== undefined) {\n    return tryDateTime;\n  }\n  const tryDuration = config.stringifyDuration(numberToSimpleTime(value), formatArg);\n  if (tryDuration !== undefined) {\n    return tryDuration;\n  }\n  const expression = parseForNumberFormat(formatArg);\n  if (expression !== undefined) {\n    return numberFormat(expression.tokens, value);\n  }\n  return formatArg;\n}\nexport function padLeft(number, size) {\n  let result = `${number}`;\n  while (result.length < size) {\n    result = '0' + result;\n  }\n  return result;\n}\nexport function padRight(number, size) {\n  let result = `${number}`;\n  while (result.length < size) {\n    result = result + '0';\n  }\n  return result;\n}\nfunction countChars(text, char) {\n  return text.split(char).length - 1;\n}\nfunction numberFormat(tokens, value) {\n  let result = '';\n  for (let i = 0; i < tokens.length; ++i) {\n    const token = tokens[i];\n    if (token.type === TokenType.FREE_TEXT) {\n      result += token.value;\n      continue;\n    }\n    const tokenParts = token.value.split('.');\n    const integerFormat = tokenParts[0];\n    const decimalFormat = tokenParts[1] || '';\n    const separator = tokenParts[1] ? '.' : '';\n    /* get fixed-point number without trailing zeros */\n    const valueParts = Number(value.toFixed(decimalFormat.length)).toString().split('.');\n    let integerPart = valueParts[0] || '';\n    let decimalPart = valueParts[1] || '';\n    if (integerFormat.length > integerPart.length) {\n      const padSizeInteger = countChars(integerFormat.substr(0, integerFormat.length - integerPart.length), '0');\n      integerPart = padLeft(integerPart, padSizeInteger + integerPart.length);\n    }\n    const padSizeDecimal = countChars(decimalFormat.substr(decimalPart.length, decimalFormat.length - decimalPart.length), '0');\n    decimalPart = padRight(decimalPart, padSizeDecimal + decimalPart.length);\n    result += integerPart + separator + decimalPart;\n  }\n  return result;\n}\nexport function defaultStringifyDuration(time, formatArg) {\n  const expression = parseForDateTimeFormat(formatArg);\n  if (expression === undefined) {\n    return undefined;\n  }\n  const tokens = expression.tokens;\n  let result = '';\n  for (const token of tokens) {\n    if (token.type === TokenType.FREE_TEXT) {\n      result += token.value;\n      continue;\n    }\n    switch (token.value.toLowerCase()) {\n      case 'h':\n      case 'hh':\n        {\n          result += padLeft(time.hours, token.value.length);\n          time.hours = 0;\n          break;\n        }\n      case '[hh]':\n        {\n          result += padLeft(time.hours, token.value.length - 2);\n          time.hours = 0;\n          break;\n        }\n      case 'm':\n      case 'mm':\n        {\n          result += padLeft(time.minutes, token.value.length);\n          time.minutes = 0;\n          break;\n        }\n      case '[mm]':\n        {\n          result += padLeft(time.minutes + 60 * time.hours, token.value.length - 2);\n          time.minutes = 0;\n          time.hours = 0;\n          break;\n        }\n      /* seconds */\n      case 's':\n      case 'ss':\n        {\n          result += padLeft(Math.floor(time.seconds), token.value.length);\n          break;\n        }\n      default:\n        {\n          if (TIME_FORMAT_SECONDS_ITEM_REGEXP.test(token.value)) {\n            const fractionOfSecondPrecision = Math.max(token.value.length - 3, 0);\n            result += `${time.seconds < 10 ? '0' : ''}${Math.floor(time.seconds * Math.pow(10, fractionOfSecondPrecision)) / Math.pow(10, fractionOfSecondPrecision)}`;\n            continue;\n          }\n          return undefined;\n        }\n    }\n  }\n  return result;\n}\nexport function defaultStringifyDateTime(dateTime, formatArg) {\n  const expression = parseForDateTimeFormat(formatArg);\n  if (expression === undefined) {\n    return undefined;\n  }\n  const tokens = expression.tokens;\n  let result = '';\n  let minutes = false;\n  const ampm = tokens.some(token => token.type === TokenType.FORMAT && (token.value === 'a/p' || token.value === 'A/P' || token.value === 'am/pm' || token.value === 'AM/PM'));\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (token.type === TokenType.FREE_TEXT) {\n      result += token.value;\n      continue;\n    }\n    switch (token.value.toLowerCase()) {\n      /* hours*/\n      case 'h':\n      case 'hh':\n        {\n          minutes = true;\n          result += padLeft(ampm ? (dateTime.hours + 11) % 12 + 1 : dateTime.hours, token.value.length);\n          break;\n        }\n      /* days */\n      case 'd':\n      case 'dd':\n        {\n          result += padLeft(dateTime.day, token.value.length);\n          break;\n        }\n      /* seconds */\n      case 's':\n      case 'ss':\n        {\n          result += padLeft(Math.floor(dateTime.seconds), token.value.length);\n          break;\n        }\n      /* minutes / months */\n      case 'm':\n      case 'mm':\n        {\n          if (i + 1 < tokens.length && tokens[i + 1].value.startsWith(':')) {\n            minutes = true;\n          }\n          if (minutes) {\n            result += padLeft(dateTime.minutes, token.value.length);\n          } else {\n            result += padLeft(dateTime.month, token.value.length);\n          }\n          minutes = true;\n          break;\n        }\n      /* years */\n      case 'yy':\n        {\n          result += padLeft(dateTime.year % 100, token.value.length);\n          break;\n        }\n      case 'yyyy':\n        {\n          result += dateTime.year;\n          break;\n        }\n      /* AM / PM */\n      case 'am/pm':\n      case 'a/p':\n        {\n          const [am, pm] = token.value.split('/');\n          result += dateTime.hours < 12 ? am : pm;\n          break;\n        }\n      default:\n        {\n          if (TIME_FORMAT_SECONDS_ITEM_REGEXP.test(token.value)) {\n            const fractionOfSecondPrecision = token.value.length - 3;\n            result += `${dateTime.seconds < 10 ? '0' : ''}${Math.floor(dateTime.seconds * Math.pow(10, fractionOfSecondPrecision)) / Math.pow(10, fractionOfSecondPrecision)}`;\n            continue;\n          }\n          return undefined;\n        }\n    }\n  }\n  return result;\n}","map":{"version":3,"names":["TIME_FORMAT_SECONDS_ITEM_REGEXP","numberToSimpleTime","parseForDateTimeFormat","parseForNumberFormat","TokenType","format","value","formatArg","config","dateHelper","tryDateTime","stringifyDateTime","numberToSimpleDateTime","undefined","tryDuration","stringifyDuration","expression","numberFormat","tokens","padLeft","number","size","result","length","padRight","countChars","text","char","split","i","token","type","FREE_TEXT","tokenParts","integerFormat","decimalFormat","separator","valueParts","Number","toFixed","toString","integerPart","decimalPart","padSizeInteger","substr","padSizeDecimal","defaultStringifyDuration","time","toLowerCase","hours","minutes","Math","floor","seconds","test","fractionOfSecondPrecision","max","pow","defaultStringifyDateTime","dateTime","ampm","some","FORMAT","day","startsWith","month","year","am","pm"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/format/format.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { TIME_FORMAT_SECONDS_ITEM_REGEXP } from \"../DateTimeDefault.mjs\";\nimport { numberToSimpleTime } from \"../DateTimeHelper.mjs\";\nimport { parseForDateTimeFormat, parseForNumberFormat, TokenType } from \"./parser.mjs\";\nexport function format(value, formatArg, config, dateHelper) {\n  const tryDateTime = config.stringifyDateTime(dateHelper.numberToSimpleDateTime(value), formatArg); // default points to defaultStringifyDateTime()\n  if (tryDateTime !== undefined) {\n    return tryDateTime;\n  }\n  const tryDuration = config.stringifyDuration(numberToSimpleTime(value), formatArg);\n  if (tryDuration !== undefined) {\n    return tryDuration;\n  }\n  const expression = parseForNumberFormat(formatArg);\n  if (expression !== undefined) {\n    return numberFormat(expression.tokens, value);\n  }\n  return formatArg;\n}\nexport function padLeft(number, size) {\n  let result = `${number}`;\n  while (result.length < size) {\n    result = '0' + result;\n  }\n  return result;\n}\nexport function padRight(number, size) {\n  let result = `${number}`;\n  while (result.length < size) {\n    result = result + '0';\n  }\n  return result;\n}\nfunction countChars(text, char) {\n  return text.split(char).length - 1;\n}\nfunction numberFormat(tokens, value) {\n  let result = '';\n  for (let i = 0; i < tokens.length; ++i) {\n    const token = tokens[i];\n    if (token.type === TokenType.FREE_TEXT) {\n      result += token.value;\n      continue;\n    }\n    const tokenParts = token.value.split('.');\n    const integerFormat = tokenParts[0];\n    const decimalFormat = tokenParts[1] || '';\n    const separator = tokenParts[1] ? '.' : '';\n    /* get fixed-point number without trailing zeros */\n    const valueParts = Number(value.toFixed(decimalFormat.length)).toString().split('.');\n    let integerPart = valueParts[0] || '';\n    let decimalPart = valueParts[1] || '';\n    if (integerFormat.length > integerPart.length) {\n      const padSizeInteger = countChars(integerFormat.substr(0, integerFormat.length - integerPart.length), '0');\n      integerPart = padLeft(integerPart, padSizeInteger + integerPart.length);\n    }\n    const padSizeDecimal = countChars(decimalFormat.substr(decimalPart.length, decimalFormat.length - decimalPart.length), '0');\n    decimalPart = padRight(decimalPart, padSizeDecimal + decimalPart.length);\n    result += integerPart + separator + decimalPart;\n  }\n  return result;\n}\nexport function defaultStringifyDuration(time, formatArg) {\n  const expression = parseForDateTimeFormat(formatArg);\n  if (expression === undefined) {\n    return undefined;\n  }\n  const tokens = expression.tokens;\n  let result = '';\n  for (const token of tokens) {\n    if (token.type === TokenType.FREE_TEXT) {\n      result += token.value;\n      continue;\n    }\n    switch (token.value.toLowerCase()) {\n      case 'h':\n      case 'hh':\n        {\n          result += padLeft(time.hours, token.value.length);\n          time.hours = 0;\n          break;\n        }\n      case '[hh]':\n        {\n          result += padLeft(time.hours, token.value.length - 2);\n          time.hours = 0;\n          break;\n        }\n      case 'm':\n      case 'mm':\n        {\n          result += padLeft(time.minutes, token.value.length);\n          time.minutes = 0;\n          break;\n        }\n      case '[mm]':\n        {\n          result += padLeft(time.minutes + 60 * time.hours, token.value.length - 2);\n          time.minutes = 0;\n          time.hours = 0;\n          break;\n        }\n      /* seconds */\n      case 's':\n      case 'ss':\n        {\n          result += padLeft(Math.floor(time.seconds), token.value.length);\n          break;\n        }\n      default:\n        {\n          if (TIME_FORMAT_SECONDS_ITEM_REGEXP.test(token.value)) {\n            const fractionOfSecondPrecision = Math.max(token.value.length - 3, 0);\n            result += `${time.seconds < 10 ? '0' : ''}${Math.floor(time.seconds * Math.pow(10, fractionOfSecondPrecision)) / Math.pow(10, fractionOfSecondPrecision)}`;\n            continue;\n          }\n          return undefined;\n        }\n    }\n  }\n  return result;\n}\nexport function defaultStringifyDateTime(dateTime, formatArg) {\n  const expression = parseForDateTimeFormat(formatArg);\n  if (expression === undefined) {\n    return undefined;\n  }\n  const tokens = expression.tokens;\n  let result = '';\n  let minutes = false;\n  const ampm = tokens.some(token => token.type === TokenType.FORMAT && (token.value === 'a/p' || token.value === 'A/P' || token.value === 'am/pm' || token.value === 'AM/PM'));\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (token.type === TokenType.FREE_TEXT) {\n      result += token.value;\n      continue;\n    }\n    switch (token.value.toLowerCase()) {\n      /* hours*/\n      case 'h':\n      case 'hh':\n        {\n          minutes = true;\n          result += padLeft(ampm ? (dateTime.hours + 11) % 12 + 1 : dateTime.hours, token.value.length);\n          break;\n        }\n      /* days */\n      case 'd':\n      case 'dd':\n        {\n          result += padLeft(dateTime.day, token.value.length);\n          break;\n        }\n      /* seconds */\n      case 's':\n      case 'ss':\n        {\n          result += padLeft(Math.floor(dateTime.seconds), token.value.length);\n          break;\n        }\n      /* minutes / months */\n      case 'm':\n      case 'mm':\n        {\n          if (i + 1 < tokens.length && tokens[i + 1].value.startsWith(':')) {\n            minutes = true;\n          }\n          if (minutes) {\n            result += padLeft(dateTime.minutes, token.value.length);\n          } else {\n            result += padLeft(dateTime.month, token.value.length);\n          }\n          minutes = true;\n          break;\n        }\n      /* years */\n      case 'yy':\n        {\n          result += padLeft(dateTime.year % 100, token.value.length);\n          break;\n        }\n      case 'yyyy':\n        {\n          result += dateTime.year;\n          break;\n        }\n      /* AM / PM */\n      case 'am/pm':\n      case 'a/p':\n        {\n          const [am, pm] = token.value.split('/');\n          result += dateTime.hours < 12 ? am : pm;\n          break;\n        }\n      default:\n        {\n          if (TIME_FORMAT_SECONDS_ITEM_REGEXP.test(token.value)) {\n            const fractionOfSecondPrecision = token.value.length - 3;\n            result += `${dateTime.seconds < 10 ? '0' : ''}${Math.floor(dateTime.seconds * Math.pow(10, fractionOfSecondPrecision)) / Math.pow(10, fractionOfSecondPrecision)}`;\n            continue;\n          }\n          return undefined;\n        }\n    }\n  }\n  return result;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}