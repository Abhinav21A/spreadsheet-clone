{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from \"../../AbsoluteCellRange.mjs\";\nimport { CellError, ErrorType } from \"../../Cell.mjs\";\nimport { ErrorMessage } from \"../../error-message.mjs\";\nimport { AstNodeType } from \"../../parser/index.mjs\";\nimport { coerceRangeToScalar, coerceScalarToBoolean, coerceScalarToString, coerceToRange } from \"../ArithmeticHelper.mjs\";\nimport { getRawValue, isExtendedNumber } from \"../InterpreterValue.mjs\";\nimport { SimpleRangeValue } from \"../../SimpleRangeValue.mjs\";\nexport var FunctionArgumentType;\n(function (FunctionArgumentType) {\n  /**\r\n   * String type.\r\n   */\n  FunctionArgumentType[\"STRING\"] = \"STRING\";\n  /**\r\n   * Floating point type.\r\n   */\n  FunctionArgumentType[\"NUMBER\"] = \"NUMBER\";\n  /**\r\n   * Boolean type.\r\n   */\n  FunctionArgumentType[\"BOOLEAN\"] = \"BOOLEAN\";\n  /**\r\n   * Any non-range value.\r\n   */\n  FunctionArgumentType[\"SCALAR\"] = \"SCALAR\";\n  /**\r\n   * Any non-range, no-error type.\r\n   */\n  FunctionArgumentType[\"NOERROR\"] = \"NOERROR\";\n  /**\r\n   * Range type.\r\n   */\n  FunctionArgumentType[\"RANGE\"] = \"RANGE\";\n  /**\r\n   * Integer type.\r\n   */\n  FunctionArgumentType[\"INTEGER\"] = \"INTEGER\";\n  /**\r\n   * String representing complex number.\r\n   */\n  FunctionArgumentType[\"COMPLEX\"] = \"COMPLEX\";\n  /**\r\n   * Range or scalar.\r\n   */\n  FunctionArgumentType[\"ANY\"] = \"ANY\";\n})(FunctionArgumentType || (FunctionArgumentType = {}));\n/**\r\n * Abstract class representing interpreter function plugin.\r\n * Plugin may contain multiple functions. Each function should be of type {@link PluginFunctionType} and needs to be\r\n * included in {@link implementedFunctions}\r\n */\nexport class FunctionPlugin {\n  constructor(interpreter) {\n    this.coerceScalarToNumberOrError = arg => this.arithmeticHelper.coerceScalarToNumberOrError(arg);\n    /**\r\n     * A method that should wrap the logic of every built-in function and custom function. It:\r\n     * - Evaluates the function's arguments.\r\n     * - Validates the number of arguments against the [`parameters` array](#function-options).\r\n     * - Coerces the argument values to types set in the [`parameters` array](#argument-validation-options).\r\n     * - Handles optional arguments and default values according to options set in the [`parameters` array](#argument-validation-options).\r\n     * - Validates the function's arguments against the [argument validation options](#argument-validation-options).\r\n     * - Duplicates the arguments according to the [`repeatLastArgs` option](#function-options).\r\n     * - Handles the [array arithmetic mode](arrays.md#array-arithmetic-mode).\r\n     * - Performs [function vectorization](arrays.md#passing-arrays-to-scalar-functions-vectorization).\r\n     * - Performs [argument broadcasting](arrays.md#broadcasting).\r\n     */\n    this.runFunction = (args, state, metadata, functionImplementation) => {\n      const evaluatedArguments = this.evaluateArguments(args, state, metadata);\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n      const argumentValues = evaluatedArguments.map(([value, _]) => value);\n      const argumentIgnorableFlags = evaluatedArguments.map(([_, ignorable]) => ignorable);\n      const argumentMetadata = this.buildMetadataForEachArgumentValue(argumentValues.length, metadata);\n      const isVectorizationOn = state.arraysFlag && !metadata.vectorizationForbidden;\n      if (!this.isNumberOfArgumentValuesValid(argumentMetadata, argumentValues.length)) {\n        return new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);\n      }\n      const [resultArrayHeight, resultArrayWidth] = isVectorizationOn ? this.calculateSizeOfVectorizedResultArray(argumentValues, argumentMetadata) : [1, 1];\n      if (resultArrayHeight === 1 && resultArrayWidth === 1) {\n        const vectorizedArguments = this.vectorizeAndBroadcastArgumentsIfNecessary(isVectorizationOn, argumentValues, argumentMetadata, 0, 0);\n        return this.calculateSingleCellOfResultArray(state, vectorizedArguments, argumentMetadata, argumentIgnorableFlags, functionImplementation, metadata.returnNumberType);\n      }\n      const resultArray = [...Array(resultArrayHeight).keys()].map(row => [...Array(resultArrayWidth).keys()].map(col => {\n        const vectorizedArguments = this.vectorizeAndBroadcastArgumentsIfNecessary(isVectorizationOn, argumentValues, argumentMetadata, row, col);\n        const result = this.calculateSingleCellOfResultArray(state, vectorizedArguments, argumentMetadata, argumentIgnorableFlags, functionImplementation, metadata.returnNumberType);\n        if (result instanceof SimpleRangeValue) {\n          throw new Error('Function returning array cannot be vectorized.');\n        }\n        return result;\n      }));\n      return SimpleRangeValue.onlyValues(resultArray);\n    };\n    this.runFunctionWithReferenceArgument = (args, state, metadata, noArgCallback, referenceCallback, nonReferenceCallback = () => new CellError(ErrorType.NA, ErrorMessage.CellRefExpected)) => {\n      if (args.length === 0) {\n        return this.returnNumberWrapper(noArgCallback(), metadata.returnNumberType);\n      } else if (args.length > 1) {\n        return new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);\n      }\n      let arg = args[0];\n      while (arg.type === AstNodeType.PARENTHESIS) {\n        arg = arg.expression;\n      }\n      let cellReference;\n      if (arg.type === AstNodeType.CELL_REFERENCE) {\n        cellReference = arg.reference.toSimpleCellAddress(state.formulaAddress);\n      } else if (arg.type === AstNodeType.CELL_RANGE || arg.type === AstNodeType.COLUMN_RANGE || arg.type === AstNodeType.ROW_RANGE) {\n        try {\n          cellReference = AbsoluteCellRange.fromAst(arg, state.formulaAddress).start;\n        } catch (e) {\n          return new CellError(ErrorType.REF, ErrorMessage.CellRefExpected);\n        }\n      }\n      if (cellReference !== undefined) {\n        return this.returnNumberWrapper(referenceCallback(cellReference), metadata.returnNumberType);\n      }\n      return this.runFunction(args, state, metadata, nonReferenceCallback);\n    };\n    this.interpreter = interpreter;\n    this.dependencyGraph = interpreter.dependencyGraph;\n    this.columnSearch = interpreter.columnSearch;\n    this.config = interpreter.config;\n    this.serialization = interpreter.serialization;\n    this.arraySizePredictor = interpreter.arraySizePredictor;\n    this.dateTimeHelper = interpreter.dateTimeHelper;\n    this.arithmeticHelper = interpreter.arithmeticHelper;\n  }\n  evaluateAst(ast, state) {\n    return this.interpreter.evaluateAst(ast, state);\n  }\n  arraySizeForAst(ast, state) {\n    return this.arraySizePredictor.checkArraySizeForAst(ast, state);\n  }\n  listOfScalarValues(asts, state) {\n    const ret = [];\n    for (const argAst of asts) {\n      const value = this.evaluateAst(argAst, state);\n      if (value instanceof SimpleRangeValue) {\n        for (const scalarValue of value.valuesFromTopLeftCorner()) {\n          ret.push([scalarValue, true]);\n        }\n      } else {\n        ret.push([value, false]);\n      }\n    }\n    return ret;\n  }\n  coerceToType(arg, coercedType, state) {\n    let ret;\n    if (arg instanceof SimpleRangeValue) {\n      switch (coercedType.argumentType) {\n        case FunctionArgumentType.RANGE:\n        case FunctionArgumentType.ANY:\n          ret = arg;\n          break;\n        default:\n          {\n            const coerce = coerceRangeToScalar(arg, state);\n            if (coerce === undefined) {\n              return undefined;\n            }\n            arg = coerce;\n          }\n      }\n    }\n    if (!(arg instanceof SimpleRangeValue)) {\n      switch (coercedType.argumentType) {\n        case FunctionArgumentType.INTEGER:\n        case FunctionArgumentType.NUMBER:\n          // eslint-disable-next-line no-case-declarations\n          const coerced = this.coerceScalarToNumberOrError(arg);\n          if (!isExtendedNumber(coerced)) {\n            ret = coerced;\n            break;\n          }\n          // eslint-disable-next-line no-case-declarations\n          const value = getRawValue(coerced);\n          if (coercedType.maxValue !== undefined && value > coercedType.maxValue) {\n            return new CellError(ErrorType.NUM, ErrorMessage.ValueLarge);\n          }\n          if (coercedType.minValue !== undefined && value < coercedType.minValue) {\n            return new CellError(ErrorType.NUM, ErrorMessage.ValueSmall);\n          }\n          if (coercedType.lessThan !== undefined && value >= coercedType.lessThan) {\n            return new CellError(ErrorType.NUM, ErrorMessage.ValueLarge);\n          }\n          if (coercedType.greaterThan !== undefined && value <= coercedType.greaterThan) {\n            return new CellError(ErrorType.NUM, ErrorMessage.ValueSmall);\n          }\n          if (coercedType.argumentType === FunctionArgumentType.INTEGER && !Number.isInteger(value)) {\n            return new CellError(ErrorType.NUM, ErrorMessage.IntegerExpected);\n          }\n          ret = coerced;\n          break;\n        case FunctionArgumentType.STRING:\n          ret = coerceScalarToString(arg);\n          break;\n        case FunctionArgumentType.BOOLEAN:\n          ret = coerceScalarToBoolean(arg);\n          break;\n        case FunctionArgumentType.SCALAR:\n        case FunctionArgumentType.NOERROR:\n        case FunctionArgumentType.ANY:\n          ret = arg;\n          break;\n        case FunctionArgumentType.RANGE:\n          if (arg instanceof CellError) {\n            return arg;\n          }\n          ret = coerceToRange(arg);\n          break;\n        case FunctionArgumentType.COMPLEX:\n          return this.arithmeticHelper.coerceScalarToComplex(getRawValue(arg));\n      }\n    }\n    if (coercedType.passSubtype || ret === undefined) {\n      return ret;\n    } else {\n      return getRawValue(ret);\n    }\n  }\n  calculateSingleCellOfResultArray(state, vectorizedArguments, argumentsMetadata, argumentIgnorableFlags, functionImplementation, returnNumberType) {\n    const coercedArguments = this.coerceArgumentsToRequiredTypes(state, vectorizedArguments, argumentsMetadata, argumentIgnorableFlags);\n    if (coercedArguments instanceof CellError) {\n      return coercedArguments;\n    }\n    const functionCalculationResult = functionImplementation(...coercedArguments);\n    return this.returnNumberWrapper(functionCalculationResult, returnNumberType);\n  }\n  coerceArgumentsToRequiredTypes(state, vectorizedArguments, argumentsMetadata, argumentIgnorableFlags) {\n    const coercedArguments = [];\n    for (let i = 0; i < argumentsMetadata.length; i++) {\n      const argumentMetadata = argumentsMetadata[i];\n      const argumentValue = vectorizedArguments[i] !== undefined ? vectorizedArguments[i] : argumentMetadata === null || argumentMetadata === void 0 ? void 0 : argumentMetadata.defaultValue;\n      if (argumentValue === undefined) {\n        coercedArguments.push(undefined);\n        continue;\n      }\n      const coercedValue = this.coerceToType(argumentValue, argumentMetadata, state);\n      if (coercedValue === undefined && !argumentIgnorableFlags[i]) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.WrongType);\n      }\n      if (coercedValue instanceof CellError && argumentMetadata.argumentType !== FunctionArgumentType.SCALAR) {\n        return coercedValue;\n      }\n      coercedArguments.push(coercedValue);\n    }\n    return coercedArguments;\n  }\n  vectorizeAndBroadcastArgumentsIfNecessary(isVectorizationOn, argumentValues, argumentMetadata, row, col) {\n    return argumentValues.map((value, i) => isVectorizationOn && this.isRangePassedAsAScalarArgument(value, argumentMetadata[i]) ? this.vectorizeAndBroadcastRangeArgument(value, row, col) : value);\n  }\n  vectorizeAndBroadcastRangeArgument(argumentValue, rowNum, colNum) {\n    var _a;\n    const targetRowNum = argumentValue.height() === 1 ? 0 : rowNum;\n    const targetColNum = argumentValue.width() === 1 ? 0 : colNum;\n    return (_a = argumentValue.data[targetRowNum]) === null || _a === void 0 ? void 0 : _a[targetColNum];\n  }\n  evaluateArguments(args, state, metadata) {\n    return metadata.expandRanges ? this.listOfScalarValues(args, state) : args.map(ast => [this.evaluateAst(ast, state), false]);\n  }\n  buildMetadataForEachArgumentValue(numberOfArgumentValuesPassed, metadata) {\n    const argumentsMetadata = metadata.parameters ? [...metadata.parameters] : [];\n    const isRepeatLastArgsValid = metadata.repeatLastArgs !== undefined && Number.isInteger(metadata.repeatLastArgs) && metadata.repeatLastArgs > 0;\n    if (isRepeatLastArgsValid) {\n      while (numberOfArgumentValuesPassed > argumentsMetadata.length) {\n        argumentsMetadata.push(...argumentsMetadata.slice(argumentsMetadata.length - metadata.repeatLastArgs));\n      }\n    }\n    return argumentsMetadata;\n  }\n  isNumberOfArgumentValuesValid(argumentsMetadata, numberOfArgumentValuesPassed) {\n    if (numberOfArgumentValuesPassed > argumentsMetadata.length) {\n      return false;\n    }\n    if (numberOfArgumentValuesPassed < argumentsMetadata.length) {\n      const metadataForMissingArguments = argumentsMetadata.slice(numberOfArgumentValuesPassed);\n      const areMissingArgumentsOptional = metadataForMissingArguments.every(argMetadata => (argMetadata === null || argMetadata === void 0 ? void 0 : argMetadata.optionalArg) || (argMetadata === null || argMetadata === void 0 ? void 0 : argMetadata.defaultValue) !== undefined);\n      return areMissingArgumentsOptional;\n    }\n    return true;\n  }\n  calculateSizeOfVectorizedResultArray(argumentValues, argumentMetadata) {\n    const argumentsThatRequireVectorization = argumentValues.filter((value, i) => this.isRangePassedAsAScalarArgument(value, argumentMetadata[i]));\n    const height = Math.max(1, ...argumentsThatRequireVectorization.map(val => val.height()));\n    const width = Math.max(1, ...argumentsThatRequireVectorization.map(val => val.width()));\n    return [height, width];\n  }\n  isRangePassedAsAScalarArgument(argumentValue, argumentMetadata) {\n    if (argumentValue == null || argumentMetadata == null) {\n      return false;\n    }\n    return argumentValue instanceof SimpleRangeValue && ![FunctionArgumentType.RANGE, FunctionArgumentType.ANY].includes(argumentMetadata.argumentType);\n  }\n  metadata(name) {\n    const params = this.constructor.implementedFunctions[name];\n    if (params !== undefined) {\n      return params;\n    }\n    throw new Error(`No metadata for function ${name}.`);\n  }\n  returnNumberWrapper(val, type, format) {\n    if (type !== undefined && isExtendedNumber(val)) {\n      return this.arithmeticHelper.ExtendedNumberFactory(getRawValue(val), {\n        type,\n        format\n      });\n    } else {\n      return val;\n    }\n  }\n}","map":{"version":3,"names":["AbsoluteCellRange","CellError","ErrorType","ErrorMessage","AstNodeType","coerceRangeToScalar","coerceScalarToBoolean","coerceScalarToString","coerceToRange","getRawValue","isExtendedNumber","SimpleRangeValue","FunctionArgumentType","FunctionPlugin","constructor","interpreter","coerceScalarToNumberOrError","arg","arithmeticHelper","runFunction","args","state","metadata","functionImplementation","evaluatedArguments","evaluateArguments","argumentValues","map","value","_","argumentIgnorableFlags","ignorable","argumentMetadata","buildMetadataForEachArgumentValue","length","isVectorizationOn","arraysFlag","vectorizationForbidden","isNumberOfArgumentValuesValid","NA","WrongArgNumber","resultArrayHeight","resultArrayWidth","calculateSizeOfVectorizedResultArray","vectorizedArguments","vectorizeAndBroadcastArgumentsIfNecessary","calculateSingleCellOfResultArray","returnNumberType","resultArray","Array","keys","row","col","result","Error","onlyValues","runFunctionWithReferenceArgument","noArgCallback","referenceCallback","nonReferenceCallback","CellRefExpected","returnNumberWrapper","type","PARENTHESIS","expression","cellReference","CELL_REFERENCE","reference","toSimpleCellAddress","formulaAddress","CELL_RANGE","COLUMN_RANGE","ROW_RANGE","fromAst","start","e","REF","undefined","dependencyGraph","columnSearch","config","serialization","arraySizePredictor","dateTimeHelper","evaluateAst","ast","arraySizeForAst","checkArraySizeForAst","listOfScalarValues","asts","ret","argAst","scalarValue","valuesFromTopLeftCorner","push","coerceToType","coercedType","argumentType","RANGE","ANY","coerce","INTEGER","NUMBER","coerced","maxValue","NUM","ValueLarge","minValue","ValueSmall","lessThan","greaterThan","Number","isInteger","IntegerExpected","STRING","BOOLEAN","SCALAR","NOERROR","COMPLEX","coerceScalarToComplex","passSubtype","argumentsMetadata","coercedArguments","coerceArgumentsToRequiredTypes","functionCalculationResult","i","argumentValue","defaultValue","coercedValue","VALUE","WrongType","isRangePassedAsAScalarArgument","vectorizeAndBroadcastRangeArgument","rowNum","colNum","_a","targetRowNum","height","targetColNum","width","data","expandRanges","numberOfArgumentValuesPassed","parameters","isRepeatLastArgsValid","repeatLastArgs","slice","metadataForMissingArguments","areMissingArgumentsOptional","every","argMetadata","optionalArg","argumentsThatRequireVectorization","filter","Math","max","val","includes","name","params","implementedFunctions","format","ExtendedNumberFactory"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/interpreter/plugin/FunctionPlugin.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from \"../../AbsoluteCellRange.mjs\";\nimport { CellError, ErrorType } from \"../../Cell.mjs\";\nimport { ErrorMessage } from \"../../error-message.mjs\";\nimport { AstNodeType } from \"../../parser/index.mjs\";\nimport { coerceRangeToScalar, coerceScalarToBoolean, coerceScalarToString, coerceToRange } from \"../ArithmeticHelper.mjs\";\nimport { getRawValue, isExtendedNumber } from \"../InterpreterValue.mjs\";\nimport { SimpleRangeValue } from \"../../SimpleRangeValue.mjs\";\nexport var FunctionArgumentType;\n(function (FunctionArgumentType) {\n  /**\r\n   * String type.\r\n   */\n  FunctionArgumentType[\"STRING\"] = \"STRING\";\n  /**\r\n   * Floating point type.\r\n   */\n  FunctionArgumentType[\"NUMBER\"] = \"NUMBER\";\n  /**\r\n   * Boolean type.\r\n   */\n  FunctionArgumentType[\"BOOLEAN\"] = \"BOOLEAN\";\n  /**\r\n   * Any non-range value.\r\n   */\n  FunctionArgumentType[\"SCALAR\"] = \"SCALAR\";\n  /**\r\n   * Any non-range, no-error type.\r\n   */\n  FunctionArgumentType[\"NOERROR\"] = \"NOERROR\";\n  /**\r\n   * Range type.\r\n   */\n  FunctionArgumentType[\"RANGE\"] = \"RANGE\";\n  /**\r\n   * Integer type.\r\n   */\n  FunctionArgumentType[\"INTEGER\"] = \"INTEGER\";\n  /**\r\n   * String representing complex number.\r\n   */\n  FunctionArgumentType[\"COMPLEX\"] = \"COMPLEX\";\n  /**\r\n   * Range or scalar.\r\n   */\n  FunctionArgumentType[\"ANY\"] = \"ANY\";\n})(FunctionArgumentType || (FunctionArgumentType = {}));\n/**\r\n * Abstract class representing interpreter function plugin.\r\n * Plugin may contain multiple functions. Each function should be of type {@link PluginFunctionType} and needs to be\r\n * included in {@link implementedFunctions}\r\n */\nexport class FunctionPlugin {\n  constructor(interpreter) {\n    this.coerceScalarToNumberOrError = arg => this.arithmeticHelper.coerceScalarToNumberOrError(arg);\n    /**\r\n     * A method that should wrap the logic of every built-in function and custom function. It:\r\n     * - Evaluates the function's arguments.\r\n     * - Validates the number of arguments against the [`parameters` array](#function-options).\r\n     * - Coerces the argument values to types set in the [`parameters` array](#argument-validation-options).\r\n     * - Handles optional arguments and default values according to options set in the [`parameters` array](#argument-validation-options).\r\n     * - Validates the function's arguments against the [argument validation options](#argument-validation-options).\r\n     * - Duplicates the arguments according to the [`repeatLastArgs` option](#function-options).\r\n     * - Handles the [array arithmetic mode](arrays.md#array-arithmetic-mode).\r\n     * - Performs [function vectorization](arrays.md#passing-arrays-to-scalar-functions-vectorization).\r\n     * - Performs [argument broadcasting](arrays.md#broadcasting).\r\n     */\n    this.runFunction = (args, state, metadata, functionImplementation) => {\n      const evaluatedArguments = this.evaluateArguments(args, state, metadata);\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n      const argumentValues = evaluatedArguments.map(([value, _]) => value);\n      const argumentIgnorableFlags = evaluatedArguments.map(([_, ignorable]) => ignorable);\n      const argumentMetadata = this.buildMetadataForEachArgumentValue(argumentValues.length, metadata);\n      const isVectorizationOn = state.arraysFlag && !metadata.vectorizationForbidden;\n      if (!this.isNumberOfArgumentValuesValid(argumentMetadata, argumentValues.length)) {\n        return new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);\n      }\n      const [resultArrayHeight, resultArrayWidth] = isVectorizationOn ? this.calculateSizeOfVectorizedResultArray(argumentValues, argumentMetadata) : [1, 1];\n      if (resultArrayHeight === 1 && resultArrayWidth === 1) {\n        const vectorizedArguments = this.vectorizeAndBroadcastArgumentsIfNecessary(isVectorizationOn, argumentValues, argumentMetadata, 0, 0);\n        return this.calculateSingleCellOfResultArray(state, vectorizedArguments, argumentMetadata, argumentIgnorableFlags, functionImplementation, metadata.returnNumberType);\n      }\n      const resultArray = [...Array(resultArrayHeight).keys()].map(row => [...Array(resultArrayWidth).keys()].map(col => {\n        const vectorizedArguments = this.vectorizeAndBroadcastArgumentsIfNecessary(isVectorizationOn, argumentValues, argumentMetadata, row, col);\n        const result = this.calculateSingleCellOfResultArray(state, vectorizedArguments, argumentMetadata, argumentIgnorableFlags, functionImplementation, metadata.returnNumberType);\n        if (result instanceof SimpleRangeValue) {\n          throw new Error('Function returning array cannot be vectorized.');\n        }\n        return result;\n      }));\n      return SimpleRangeValue.onlyValues(resultArray);\n    };\n    this.runFunctionWithReferenceArgument = (args, state, metadata, noArgCallback, referenceCallback, nonReferenceCallback = () => new CellError(ErrorType.NA, ErrorMessage.CellRefExpected)) => {\n      if (args.length === 0) {\n        return this.returnNumberWrapper(noArgCallback(), metadata.returnNumberType);\n      } else if (args.length > 1) {\n        return new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);\n      }\n      let arg = args[0];\n      while (arg.type === AstNodeType.PARENTHESIS) {\n        arg = arg.expression;\n      }\n      let cellReference;\n      if (arg.type === AstNodeType.CELL_REFERENCE) {\n        cellReference = arg.reference.toSimpleCellAddress(state.formulaAddress);\n      } else if (arg.type === AstNodeType.CELL_RANGE || arg.type === AstNodeType.COLUMN_RANGE || arg.type === AstNodeType.ROW_RANGE) {\n        try {\n          cellReference = AbsoluteCellRange.fromAst(arg, state.formulaAddress).start;\n        } catch (e) {\n          return new CellError(ErrorType.REF, ErrorMessage.CellRefExpected);\n        }\n      }\n      if (cellReference !== undefined) {\n        return this.returnNumberWrapper(referenceCallback(cellReference), metadata.returnNumberType);\n      }\n      return this.runFunction(args, state, metadata, nonReferenceCallback);\n    };\n    this.interpreter = interpreter;\n    this.dependencyGraph = interpreter.dependencyGraph;\n    this.columnSearch = interpreter.columnSearch;\n    this.config = interpreter.config;\n    this.serialization = interpreter.serialization;\n    this.arraySizePredictor = interpreter.arraySizePredictor;\n    this.dateTimeHelper = interpreter.dateTimeHelper;\n    this.arithmeticHelper = interpreter.arithmeticHelper;\n  }\n  evaluateAst(ast, state) {\n    return this.interpreter.evaluateAst(ast, state);\n  }\n  arraySizeForAst(ast, state) {\n    return this.arraySizePredictor.checkArraySizeForAst(ast, state);\n  }\n  listOfScalarValues(asts, state) {\n    const ret = [];\n    for (const argAst of asts) {\n      const value = this.evaluateAst(argAst, state);\n      if (value instanceof SimpleRangeValue) {\n        for (const scalarValue of value.valuesFromTopLeftCorner()) {\n          ret.push([scalarValue, true]);\n        }\n      } else {\n        ret.push([value, false]);\n      }\n    }\n    return ret;\n  }\n  coerceToType(arg, coercedType, state) {\n    let ret;\n    if (arg instanceof SimpleRangeValue) {\n      switch (coercedType.argumentType) {\n        case FunctionArgumentType.RANGE:\n        case FunctionArgumentType.ANY:\n          ret = arg;\n          break;\n        default:\n          {\n            const coerce = coerceRangeToScalar(arg, state);\n            if (coerce === undefined) {\n              return undefined;\n            }\n            arg = coerce;\n          }\n      }\n    }\n    if (!(arg instanceof SimpleRangeValue)) {\n      switch (coercedType.argumentType) {\n        case FunctionArgumentType.INTEGER:\n        case FunctionArgumentType.NUMBER:\n          // eslint-disable-next-line no-case-declarations\n          const coerced = this.coerceScalarToNumberOrError(arg);\n          if (!isExtendedNumber(coerced)) {\n            ret = coerced;\n            break;\n          }\n          // eslint-disable-next-line no-case-declarations\n          const value = getRawValue(coerced);\n          if (coercedType.maxValue !== undefined && value > coercedType.maxValue) {\n            return new CellError(ErrorType.NUM, ErrorMessage.ValueLarge);\n          }\n          if (coercedType.minValue !== undefined && value < coercedType.minValue) {\n            return new CellError(ErrorType.NUM, ErrorMessage.ValueSmall);\n          }\n          if (coercedType.lessThan !== undefined && value >= coercedType.lessThan) {\n            return new CellError(ErrorType.NUM, ErrorMessage.ValueLarge);\n          }\n          if (coercedType.greaterThan !== undefined && value <= coercedType.greaterThan) {\n            return new CellError(ErrorType.NUM, ErrorMessage.ValueSmall);\n          }\n          if (coercedType.argumentType === FunctionArgumentType.INTEGER && !Number.isInteger(value)) {\n            return new CellError(ErrorType.NUM, ErrorMessage.IntegerExpected);\n          }\n          ret = coerced;\n          break;\n        case FunctionArgumentType.STRING:\n          ret = coerceScalarToString(arg);\n          break;\n        case FunctionArgumentType.BOOLEAN:\n          ret = coerceScalarToBoolean(arg);\n          break;\n        case FunctionArgumentType.SCALAR:\n        case FunctionArgumentType.NOERROR:\n        case FunctionArgumentType.ANY:\n          ret = arg;\n          break;\n        case FunctionArgumentType.RANGE:\n          if (arg instanceof CellError) {\n            return arg;\n          }\n          ret = coerceToRange(arg);\n          break;\n        case FunctionArgumentType.COMPLEX:\n          return this.arithmeticHelper.coerceScalarToComplex(getRawValue(arg));\n      }\n    }\n    if (coercedType.passSubtype || ret === undefined) {\n      return ret;\n    } else {\n      return getRawValue(ret);\n    }\n  }\n  calculateSingleCellOfResultArray(state, vectorizedArguments, argumentsMetadata, argumentIgnorableFlags, functionImplementation, returnNumberType) {\n    const coercedArguments = this.coerceArgumentsToRequiredTypes(state, vectorizedArguments, argumentsMetadata, argumentIgnorableFlags);\n    if (coercedArguments instanceof CellError) {\n      return coercedArguments;\n    }\n    const functionCalculationResult = functionImplementation(...coercedArguments);\n    return this.returnNumberWrapper(functionCalculationResult, returnNumberType);\n  }\n  coerceArgumentsToRequiredTypes(state, vectorizedArguments, argumentsMetadata, argumentIgnorableFlags) {\n    const coercedArguments = [];\n    for (let i = 0; i < argumentsMetadata.length; i++) {\n      const argumentMetadata = argumentsMetadata[i];\n      const argumentValue = vectorizedArguments[i] !== undefined ? vectorizedArguments[i] : argumentMetadata === null || argumentMetadata === void 0 ? void 0 : argumentMetadata.defaultValue;\n      if (argumentValue === undefined) {\n        coercedArguments.push(undefined);\n        continue;\n      }\n      const coercedValue = this.coerceToType(argumentValue, argumentMetadata, state);\n      if (coercedValue === undefined && !argumentIgnorableFlags[i]) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.WrongType);\n      }\n      if (coercedValue instanceof CellError && argumentMetadata.argumentType !== FunctionArgumentType.SCALAR) {\n        return coercedValue;\n      }\n      coercedArguments.push(coercedValue);\n    }\n    return coercedArguments;\n  }\n  vectorizeAndBroadcastArgumentsIfNecessary(isVectorizationOn, argumentValues, argumentMetadata, row, col) {\n    return argumentValues.map((value, i) => isVectorizationOn && this.isRangePassedAsAScalarArgument(value, argumentMetadata[i]) ? this.vectorizeAndBroadcastRangeArgument(value, row, col) : value);\n  }\n  vectorizeAndBroadcastRangeArgument(argumentValue, rowNum, colNum) {\n    var _a;\n    const targetRowNum = argumentValue.height() === 1 ? 0 : rowNum;\n    const targetColNum = argumentValue.width() === 1 ? 0 : colNum;\n    return (_a = argumentValue.data[targetRowNum]) === null || _a === void 0 ? void 0 : _a[targetColNum];\n  }\n  evaluateArguments(args, state, metadata) {\n    return metadata.expandRanges ? this.listOfScalarValues(args, state) : args.map(ast => [this.evaluateAst(ast, state), false]);\n  }\n  buildMetadataForEachArgumentValue(numberOfArgumentValuesPassed, metadata) {\n    const argumentsMetadata = metadata.parameters ? [...metadata.parameters] : [];\n    const isRepeatLastArgsValid = metadata.repeatLastArgs !== undefined && Number.isInteger(metadata.repeatLastArgs) && metadata.repeatLastArgs > 0;\n    if (isRepeatLastArgsValid) {\n      while (numberOfArgumentValuesPassed > argumentsMetadata.length) {\n        argumentsMetadata.push(...argumentsMetadata.slice(argumentsMetadata.length - metadata.repeatLastArgs));\n      }\n    }\n    return argumentsMetadata;\n  }\n  isNumberOfArgumentValuesValid(argumentsMetadata, numberOfArgumentValuesPassed) {\n    if (numberOfArgumentValuesPassed > argumentsMetadata.length) {\n      return false;\n    }\n    if (numberOfArgumentValuesPassed < argumentsMetadata.length) {\n      const metadataForMissingArguments = argumentsMetadata.slice(numberOfArgumentValuesPassed);\n      const areMissingArgumentsOptional = metadataForMissingArguments.every(argMetadata => (argMetadata === null || argMetadata === void 0 ? void 0 : argMetadata.optionalArg) || (argMetadata === null || argMetadata === void 0 ? void 0 : argMetadata.defaultValue) !== undefined);\n      return areMissingArgumentsOptional;\n    }\n    return true;\n  }\n  calculateSizeOfVectorizedResultArray(argumentValues, argumentMetadata) {\n    const argumentsThatRequireVectorization = argumentValues.filter((value, i) => this.isRangePassedAsAScalarArgument(value, argumentMetadata[i]));\n    const height = Math.max(1, ...argumentsThatRequireVectorization.map(val => val.height()));\n    const width = Math.max(1, ...argumentsThatRequireVectorization.map(val => val.width()));\n    return [height, width];\n  }\n  isRangePassedAsAScalarArgument(argumentValue, argumentMetadata) {\n    if (argumentValue == null || argumentMetadata == null) {\n      return false;\n    }\n    return argumentValue instanceof SimpleRangeValue && ![FunctionArgumentType.RANGE, FunctionArgumentType.ANY].includes(argumentMetadata.argumentType);\n  }\n  metadata(name) {\n    const params = this.constructor.implementedFunctions[name];\n    if (params !== undefined) {\n      return params;\n    }\n    throw new Error(`No metadata for function ${name}.`);\n  }\n  returnNumberWrapper(val, type, format) {\n    if (type !== undefined && isExtendedNumber(val)) {\n      return this.arithmeticHelper.ExtendedNumberFactory(getRawValue(val), {\n        type,\n        format\n      });\n    } else {\n      return val;\n    }\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}