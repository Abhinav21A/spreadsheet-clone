{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AddressDependency, collectDependencies } from \"../parser/index.mjs\";\nimport { FormulaVertex } from \"./FormulaCellVertex.mjs\";\nimport { RangeVertex } from \"./RangeVertex.mjs\";\nexport const collectAddressesDependentToRange = (functionRegistry, vertex, range, lazilyTransformingAstService, dependencyGraph) => {\n  if (vertex instanceof RangeVertex) {\n    const intersection = vertex.range.intersectionWith(range);\n    if (intersection !== undefined) {\n      return Array.from(intersection.addresses(dependencyGraph));\n    } else {\n      return [];\n    }\n  }\n  let formula;\n  let address;\n  if (vertex instanceof FormulaVertex) {\n    formula = vertex.getFormula(lazilyTransformingAstService);\n    address = vertex.getAddress(lazilyTransformingAstService);\n  } else {\n    return [];\n  }\n  return collectDependencies(formula, functionRegistry).filter(d => d instanceof AddressDependency).map(d => d.dependency.toSimpleCellAddress(address)).filter(d => range.addressInRange(d));\n};","map":{"version":3,"names":["AddressDependency","collectDependencies","FormulaVertex","RangeVertex","collectAddressesDependentToRange","functionRegistry","vertex","range","lazilyTransformingAstService","dependencyGraph","intersection","intersectionWith","undefined","Array","from","addresses","formula","address","getFormula","getAddress","filter","d","map","dependency","toSimpleCellAddress","addressInRange"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/DependencyGraph/collectAddressesDependentToRange.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AddressDependency, collectDependencies } from \"../parser/index.mjs\";\nimport { FormulaVertex } from \"./FormulaCellVertex.mjs\";\nimport { RangeVertex } from \"./RangeVertex.mjs\";\nexport const collectAddressesDependentToRange = (functionRegistry, vertex, range, lazilyTransformingAstService, dependencyGraph) => {\n  if (vertex instanceof RangeVertex) {\n    const intersection = vertex.range.intersectionWith(range);\n    if (intersection !== undefined) {\n      return Array.from(intersection.addresses(dependencyGraph));\n    } else {\n      return [];\n    }\n  }\n  let formula;\n  let address;\n  if (vertex instanceof FormulaVertex) {\n    formula = vertex.getFormula(lazilyTransformingAstService);\n    address = vertex.getAddress(lazilyTransformingAstService);\n  } else {\n    return [];\n  }\n  return collectDependencies(formula, functionRegistry).filter(d => d instanceof AddressDependency).map(d => d.dependency.toSimpleCellAddress(address)).filter(d => range.addressInRange(d));\n};"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,iBAAiB,EAAEC,mBAAmB,QAAQ,qBAAqB;AAC5E,SAASC,aAAa,QAAQ,yBAAyB;AACvD,SAASC,WAAW,QAAQ,mBAAmB;AAC/C,OAAO,MAAMC,gCAAgC,GAAGA,CAACC,gBAAgB,EAAEC,MAAM,EAAEC,KAAK,EAAEC,4BAA4B,EAAEC,eAAe,KAAK;EAClI,IAAIH,MAAM,YAAYH,WAAW,EAAE;IACjC,MAAMO,YAAY,GAAGJ,MAAM,CAACC,KAAK,CAACI,gBAAgB,CAACJ,KAAK,CAAC;IACzD,IAAIG,YAAY,KAAKE,SAAS,EAAE;MAC9B,OAAOC,KAAK,CAACC,IAAI,CAACJ,YAAY,CAACK,SAAS,CAACN,eAAe,CAAC,CAAC;IAC5D,CAAC,MAAM;MACL,OAAO,EAAE;IACX;EACF;EACA,IAAIO,OAAO;EACX,IAAIC,OAAO;EACX,IAAIX,MAAM,YAAYJ,aAAa,EAAE;IACnCc,OAAO,GAAGV,MAAM,CAACY,UAAU,CAACV,4BAA4B,CAAC;IACzDS,OAAO,GAAGX,MAAM,CAACa,UAAU,CAACX,4BAA4B,CAAC;EAC3D,CAAC,MAAM;IACL,OAAO,EAAE;EACX;EACA,OAAOP,mBAAmB,CAACe,OAAO,EAAEX,gBAAgB,CAAC,CAACe,MAAM,CAACC,CAAC,IAAIA,CAAC,YAAYrB,iBAAiB,CAAC,CAACsB,GAAG,CAACD,CAAC,IAAIA,CAAC,CAACE,UAAU,CAACC,mBAAmB,CAACP,OAAO,CAAC,CAAC,CAACG,MAAM,CAACC,CAAC,IAAId,KAAK,CAACkB,cAAc,CAACJ,CAAC,CAAC,CAAC;AAC5L,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}