{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from \"./AbsoluteCellRange.mjs\";\nimport { invalidSimpleCellAddress } from \"./Cell.mjs\";\nimport { NamedExpressionDependency } from \"./parser/index.mjs\";\n/**\r\n * Converts dependencies from maybe relative addressing to absolute addressing.\r\n *\r\n * @param deps - list of addresses in R0C0 format\r\n * @param baseAddress - base address with regard to which make a convertion\r\n */\nexport const absolutizeDependencies = (deps, baseAddress) => {\n  return deps.map(dep => dep.absolutize(baseAddress));\n};\nexport const filterDependenciesOutOfScope = deps => {\n  return deps.filter(dep => {\n    if (dep instanceof NamedExpressionDependency) {\n      return true;\n    }\n    if (dep instanceof AbsoluteCellRange) {\n      return !(invalidSimpleCellAddress(dep.start) || invalidSimpleCellAddress(dep.end));\n    } else {\n      return !invalidSimpleCellAddress(dep);\n    }\n  });\n};","map":{"version":3,"names":["AbsoluteCellRange","invalidSimpleCellAddress","NamedExpressionDependency","absolutizeDependencies","deps","baseAddress","map","dep","absolutize","filterDependenciesOutOfScope","filter","start","end"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/absolutizeDependencies.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from \"./AbsoluteCellRange.mjs\";\nimport { invalidSimpleCellAddress } from \"./Cell.mjs\";\nimport { NamedExpressionDependency } from \"./parser/index.mjs\";\n/**\r\n * Converts dependencies from maybe relative addressing to absolute addressing.\r\n *\r\n * @param deps - list of addresses in R0C0 format\r\n * @param baseAddress - base address with regard to which make a convertion\r\n */\nexport const absolutizeDependencies = (deps, baseAddress) => {\n  return deps.map(dep => dep.absolutize(baseAddress));\n};\nexport const filterDependenciesOutOfScope = deps => {\n  return deps.filter(dep => {\n    if (dep instanceof NamedExpressionDependency) {\n      return true;\n    }\n    if (dep instanceof AbsoluteCellRange) {\n      return !(invalidSimpleCellAddress(dep.start) || invalidSimpleCellAddress(dep.end));\n    } else {\n      return !invalidSimpleCellAddress(dep);\n    }\n  });\n};"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,iBAAiB,QAAQ,yBAAyB;AAC3D,SAASC,wBAAwB,QAAQ,YAAY;AACrD,SAASC,yBAAyB,QAAQ,oBAAoB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,sBAAsB,GAAGA,CAACC,IAAI,EAAEC,WAAW,KAAK;EAC3D,OAAOD,IAAI,CAACE,GAAG,CAACC,GAAG,IAAIA,GAAG,CAACC,UAAU,CAACH,WAAW,CAAC,CAAC;AACrD,CAAC;AACD,OAAO,MAAMI,4BAA4B,GAAGL,IAAI,IAAI;EAClD,OAAOA,IAAI,CAACM,MAAM,CAACH,GAAG,IAAI;IACxB,IAAIA,GAAG,YAAYL,yBAAyB,EAAE;MAC5C,OAAO,IAAI;IACb;IACA,IAAIK,GAAG,YAAYP,iBAAiB,EAAE;MACpC,OAAO,EAAEC,wBAAwB,CAACM,GAAG,CAACI,KAAK,CAAC,IAAIV,wBAAwB,CAACM,GAAG,CAACK,GAAG,CAAC,CAAC;IACpF,CAAC,MAAM;MACL,OAAO,CAACX,wBAAwB,CAACM,GAAG,CAAC;IACvC;EACF,CAAC,CAAC;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}