{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { EmbeddedActionsParser, EMPTY_ALT, Lexer, tokenMatcher } from 'chevrotain';\nimport { CellError, ErrorType, simpleCellAddress } from \"../Cell.mjs\";\nimport { ErrorMessage } from \"../error-message.mjs\";\nimport { cellAddressFromString, columnAddressFromString, rowAddressFromString } from \"./addressRepresentationConverters.mjs\";\nimport { AstNodeType, buildArrayAst, buildCellErrorAst, buildCellRangeAst, buildCellReferenceAst, buildColumnRangeAst, buildConcatenateOpAst, buildDivOpAst, buildEmptyArgAst, buildEqualsOpAst, buildErrorWithRawInputAst, buildGreaterThanOpAst, buildGreaterThanOrEqualOpAst, buildLessThanOpAst, buildLessThanOrEqualOpAst, buildMinusOpAst, buildMinusUnaryOpAst, buildNamedExpressionAst, buildNotEqualOpAst, buildNumberAst, buildParenthesisAst, buildParsingErrorAst, buildPercentOpAst, buildPlusOpAst, buildPlusUnaryOpAst, buildPowerOpAst, buildProcedureAst, buildRowRangeAst, buildStringAst, buildTimesOpAst, parsingError, ParsingErrorType, RangeSheetReferenceType } from \"./Ast.mjs\";\nimport { CellAddress, CellReferenceType } from \"./CellAddress.mjs\";\nimport { AdditionOp, ArrayLParen, ArrayRParen, BooleanOp, CellReference, ColumnRange, ConcatenateOp, DivOp, EqualsOp, ErrorLiteral, GreaterThanOp, GreaterThanOrEqualOp, LessThanOp, LessThanOrEqualOp, LParen, MinusOp, MultiplicationOp, NamedExpression, NotEqualOp, PercentOp, PlusOp, PowerOp, ProcedureName, RangeSeparator, RowRange, RParen, StringLiteral, TimesOp } from \"./LexerConfig.mjs\";\n/**\r\n * LL(k) formula parser described using Chevrotain DSL\r\n *\r\n * It is equivalent to the grammar below:\r\n *\r\n * F -> '=' E <br/>\r\n * B -> K < B | K >= B ... | K <br/>\r\n * K -> E & K | E <br/>\r\n * E -> M + E | M - E | M <br/>\r\n * M -> W * M | W / M | W <br/>\r\n * W -> C * W | C <br/>\r\n * C -> N | R | O | A | P | num <br/>\r\n * N -> '(' E ')' <br/>\r\n * R -> A:OFFSET(..) | A:A <br/>\r\n * O -> OFFSET(..) | OFFSET(..):A | OFFSET(..):OFFSET(..) <br/>\r\n * A -> A1 | $A1 | A$1 | $A$1 <br/>\r\n * P -> SUM(..) <br/>\r\n */\nexport class FormulaParser extends EmbeddedActionsParser {\n  constructor(lexerConfig, sheetMapping) {\n    super(lexerConfig.allTokens, {\n      outputCst: false,\n      maxLookahead: 7\n    });\n    this.booleanExpressionOrEmpty = this.RULE('booleanExpressionOrEmpty', () => {\n      return this.OR([{\n        ALT: () => this.SUBRULE(this.booleanExpression)\n      }, {\n        ALT: EMPTY_ALT(buildEmptyArgAst())\n      }]);\n    });\n    /**\r\n     * Rule for procedure expressions: SUM(1,A1)\r\n     */\n    this.procedureExpression = this.RULE('procedureExpression', () => {\n      var _a;\n      const procedureNameToken = this.CONSUME(ProcedureName);\n      const procedureName = procedureNameToken.image.toUpperCase().slice(0, -1);\n      const canonicalProcedureName = (_a = this.lexerConfig.functionMapping[procedureName]) !== null && _a !== void 0 ? _a : procedureName;\n      const args = [];\n      let argument = this.SUBRULE(this.booleanExpressionOrEmpty);\n      this.MANY(() => {\n        var _a;\n        const separator = this.CONSUME(this.lexerConfig.ArgSeparator);\n        if (argument.type === AstNodeType.EMPTY) {\n          argument.leadingWhitespace = (_a = separator.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image;\n        }\n        args.push(argument);\n        argument = this.SUBRULE2(this.booleanExpressionOrEmpty);\n      });\n      args.push(argument);\n      if (args.length === 1 && args[0].type === AstNodeType.EMPTY) {\n        args.length = 0;\n      }\n      const rParenToken = this.CONSUME(RParen);\n      return buildProcedureAst(canonicalProcedureName, args, procedureNameToken.leadingWhitespace, rParenToken.leadingWhitespace);\n    });\n    this.namedExpressionExpression = this.RULE('namedExpressionExpression', () => {\n      const name = this.CONSUME(NamedExpression);\n      return buildNamedExpressionAst(name.image, name.leadingWhitespace);\n    });\n    /**\r\n     * Rule for OFFSET() function expression\r\n     */\n    this.offsetProcedureExpression = this.RULE('offsetProcedureExpression', () => {\n      const args = [];\n      this.CONSUME(this.lexerConfig.OffsetProcedureName);\n      this.CONSUME(LParen);\n      this.MANY_SEP({\n        SEP: this.lexerConfig.ArgSeparator,\n        DEF: () => {\n          args.push(this.SUBRULE(this.booleanExpression));\n        }\n      });\n      this.CONSUME(RParen);\n      return this.handleOffsetHeuristic(args);\n    });\n    /**\r\n     * Rule for column range, e.g., A:B, Sheet1!A:B, Sheet1!A:Sheet1!B\r\n     */\n    this.columnRangeExpression = this.RULE('columnRangeExpression', () => {\n      const range = this.CONSUME(ColumnRange);\n      const [startImage, endImage] = range.image.split(':');\n      const firstAddress = this.ACTION(() => columnAddressFromString(this.sheetMapping, startImage, this.formulaAddress));\n      const secondAddress = this.ACTION(() => columnAddressFromString(this.sheetMapping, endImage, this.formulaAddress));\n      if (firstAddress === undefined || secondAddress === undefined) {\n        return buildCellErrorAst(new CellError(ErrorType.REF));\n      }\n      if (firstAddress.exceedsSheetSizeLimits(this.lexerConfig.maxColumns) || secondAddress.exceedsSheetSizeLimits(this.lexerConfig.maxColumns)) {\n        return buildErrorWithRawInputAst(range.image, new CellError(ErrorType.NAME), range.leadingWhitespace);\n      }\n      if (firstAddress.sheet === undefined && secondAddress.sheet !== undefined) {\n        return this.parsingError(ParsingErrorType.ParserError, 'Malformed range expression');\n      }\n      const {\n        firstEnd,\n        secondEnd,\n        sheetRefType\n      } = FormulaParser.fixSheetIdsForRangeEnds(firstAddress, secondAddress);\n      return buildColumnRangeAst(firstEnd, secondEnd, sheetRefType, range.leadingWhitespace);\n    });\n    /**\r\n     * Rule for row range, e.g., 1:2, Sheet1!1:2, Sheet1!1:Sheet1!2\r\n     */\n    this.rowRangeExpression = this.RULE('rowRangeExpression', () => {\n      const range = this.CONSUME(RowRange);\n      const [startImage, endImage] = range.image.split(':');\n      const firstAddress = this.ACTION(() => rowAddressFromString(this.sheetMapping, startImage, this.formulaAddress));\n      const secondAddress = this.ACTION(() => rowAddressFromString(this.sheetMapping, endImage, this.formulaAddress));\n      if (firstAddress === undefined || secondAddress === undefined) {\n        return buildCellErrorAst(new CellError(ErrorType.REF));\n      }\n      if (firstAddress.exceedsSheetSizeLimits(this.lexerConfig.maxRows) || secondAddress.exceedsSheetSizeLimits(this.lexerConfig.maxRows)) {\n        return buildErrorWithRawInputAst(range.image, new CellError(ErrorType.NAME), range.leadingWhitespace);\n      }\n      if (firstAddress.sheet === undefined && secondAddress.sheet !== undefined) {\n        return this.parsingError(ParsingErrorType.ParserError, 'Malformed range expression');\n      }\n      const {\n        firstEnd,\n        secondEnd,\n        sheetRefType\n      } = FormulaParser.fixSheetIdsForRangeEnds(firstAddress, secondAddress);\n      return buildRowRangeAst(firstEnd, secondEnd, sheetRefType, range.leadingWhitespace);\n    });\n    /**\r\n     * Rule for cell reference expression (e.g., A1, $A1, A$1, $A$1, $Sheet42!A$17)\r\n     */\n    this.cellReference = this.RULE('cellReference', () => {\n      const cell = this.CONSUME(CellReference);\n      const address = this.ACTION(() => {\n        return cellAddressFromString(this.sheetMapping, cell.image, this.formulaAddress);\n      });\n      if (address === undefined) {\n        return buildErrorWithRawInputAst(cell.image, new CellError(ErrorType.REF), cell.leadingWhitespace);\n      } else if (address.exceedsSheetSizeLimits(this.lexerConfig.maxColumns, this.lexerConfig.maxRows)) {\n        return buildErrorWithRawInputAst(cell.image, new CellError(ErrorType.NAME), cell.leadingWhitespace);\n      } else {\n        return buildCellReferenceAst(address, cell.leadingWhitespace);\n      }\n    });\n    /**\r\n     * Rule for end range reference expression with additional checks considering range start\r\n     */\n    this.endRangeReference = this.RULE('endRangeReference', start => {\n      var _a;\n      const end = this.CONSUME(CellReference);\n      const startAddress = this.ACTION(() => {\n        return cellAddressFromString(this.sheetMapping, start.image, this.formulaAddress);\n      });\n      const endAddress = this.ACTION(() => {\n        return cellAddressFromString(this.sheetMapping, end.image, this.formulaAddress);\n      });\n      if (startAddress === undefined || endAddress === undefined) {\n        return this.ACTION(() => {\n          return buildErrorWithRawInputAst(`${start.image}:${end.image}`, new CellError(ErrorType.REF), start.leadingWhitespace);\n        });\n      } else if (startAddress.exceedsSheetSizeLimits(this.lexerConfig.maxColumns, this.lexerConfig.maxRows) || endAddress.exceedsSheetSizeLimits(this.lexerConfig.maxColumns, this.lexerConfig.maxRows)) {\n        return this.ACTION(() => {\n          return buildErrorWithRawInputAst(`${start.image}:${end.image}`, new CellError(ErrorType.NAME), start.leadingWhitespace);\n        });\n      }\n      return this.buildCellRange(startAddress, endAddress, (_a = start.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image);\n    });\n    /**\r\n     * Rule for end of range expression\r\n     *\r\n     * End of range may be a cell reference or OFFSET() function call\r\n     */\n    this.endOfRangeExpression = this.RULE('endOfRangeExpression', start => {\n      return this.OR([{\n        ALT: () => {\n          return this.SUBRULE(this.endRangeReference, {\n            ARGS: [start]\n          });\n        }\n      }, {\n        ALT: () => {\n          var _a;\n          const offsetProcedure = this.SUBRULE(this.offsetProcedureExpression);\n          const startAddress = this.ACTION(() => {\n            return cellAddressFromString(this.sheetMapping, start.image, this.formulaAddress);\n          });\n          if (startAddress === undefined) {\n            return buildCellErrorAst(new CellError(ErrorType.REF));\n          }\n          if (offsetProcedure.type === AstNodeType.CELL_REFERENCE) {\n            return this.buildCellRange(startAddress, offsetProcedure.reference, (_a = start.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image);\n          } else {\n            return this.parsingError(ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');\n          }\n        }\n      }]);\n    });\n    /**\r\n     * Rule for cell ranges (e.g., A1:B$3, A1:OFFSET())\r\n     */\n    this.cellRangeExpression = this.RULE('cellRangeExpression', () => {\n      const start = this.CONSUME(CellReference);\n      this.CONSUME2(RangeSeparator);\n      return this.SUBRULE(this.endOfRangeExpression, {\n        ARGS: [start]\n      });\n    });\n    /**\r\n     * Rule for end range reference expression starting with offset procedure with additional checks considering range start\r\n     */\n    this.endRangeWithOffsetStartReference = this.RULE('endRangeWithOffsetStartReference', start => {\n      const end = this.CONSUME(CellReference);\n      const endAddress = this.ACTION(() => {\n        return cellAddressFromString(this.sheetMapping, end.image, this.formulaAddress);\n      });\n      if (endAddress === undefined) {\n        return this.ACTION(() => {\n          return buildCellErrorAst(new CellError(ErrorType.REF));\n        });\n      }\n      return this.buildCellRange(start.reference, endAddress, start.leadingWhitespace);\n    });\n    /**\r\n     * Rule for end of range expression\r\n     *\r\n     * End of range may be a cell reference or OFFSET() function call\r\n     */\n    this.endOfRangeWithOffsetStartExpression = this.RULE('endOfRangeWithOffsetStartExpression', start => {\n      return this.OR([{\n        ALT: () => {\n          return this.SUBRULE(this.endRangeWithOffsetStartReference, {\n            ARGS: [start]\n          });\n        }\n      }, {\n        ALT: () => {\n          const offsetProcedure = this.SUBRULE(this.offsetProcedureExpression);\n          if (offsetProcedure.type === AstNodeType.CELL_REFERENCE) {\n            return this.buildCellRange(start.reference, offsetProcedure.reference, start.leadingWhitespace);\n          } else {\n            return this.parsingError(ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');\n          }\n        }\n      }]);\n    });\n    /**\r\n     * Rule for expressions that start with the OFFSET function.\r\n     *\r\n     * The OFFSET function can occur as a cell reference, or as a part of a cell range.\r\n     * To preserve LL(k) properties, expressions that start with the OFFSET function need a separate rule.\r\n     *\r\n     * Depending on the presence of the {@link RangeSeparator}, a proper {@link Ast} node type is built.\r\n     */\n    this.offsetExpression = this.RULE('offsetExpression', () => {\n      const offsetProcedure = this.SUBRULE(this.offsetProcedureExpression);\n      let end;\n      this.OPTION(() => {\n        this.CONSUME(RangeSeparator);\n        if (offsetProcedure.type === AstNodeType.CELL_RANGE) {\n          end = this.parsingError(ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');\n        } else {\n          end = this.SUBRULE(this.endOfRangeWithOffsetStartExpression, {\n            ARGS: [offsetProcedure]\n          });\n        }\n      });\n      if (end !== undefined) {\n        return end;\n      }\n      return offsetProcedure;\n    });\n    this.insideArrayExpression = this.RULE('insideArrayExpression', () => {\n      const ret = [[]];\n      ret[ret.length - 1].push(this.SUBRULE(this.booleanExpression));\n      this.MANY(() => {\n        this.OR([{\n          ALT: () => {\n            this.CONSUME(this.lexerConfig.ArrayColSeparator);\n            ret[ret.length - 1].push(this.SUBRULE2(this.booleanExpression));\n          }\n        }, {\n          ALT: () => {\n            this.CONSUME(this.lexerConfig.ArrayRowSeparator);\n            ret.push([]);\n            ret[ret.length - 1].push(this.SUBRULE3(this.booleanExpression));\n          }\n        }]);\n      });\n      return buildArrayAst(ret);\n    });\n    /**\r\n     * Rule for parenthesis expression\r\n     */\n    this.parenthesisExpression = this.RULE('parenthesisExpression', () => {\n      const lParenToken = this.CONSUME(LParen);\n      const expression = this.SUBRULE(this.booleanExpression);\n      const rParenToken = this.CONSUME(RParen);\n      return buildParenthesisAst(expression, lParenToken.leadingWhitespace, rParenToken.leadingWhitespace);\n    });\n    this.arrayExpression = this.RULE('arrayExpression', () => {\n      return this.OR([{\n        ALT: () => {\n          const ltoken = this.CONSUME(ArrayLParen);\n          const ret = this.SUBRULE(this.insideArrayExpression);\n          const rtoken = this.CONSUME(ArrayRParen);\n          return buildArrayAst(ret.args, ltoken.leadingWhitespace, rtoken.leadingWhitespace);\n        }\n      }, {\n        ALT: () => this.SUBRULE(this.parenthesisExpression)\n      }]);\n    });\n    this.numericStringToNumber = input => {\n      const normalized = input.replace(this.lexerConfig.decimalSeparator, '.');\n      return Number(normalized);\n    };\n    /**\r\n     * Rule for positive atomic expressions\r\n     */\n    this.positiveAtomicExpression = this.RULE('positiveAtomicExpression', () => {\n      var _a;\n      return this.OR((_a = this.atomicExpCache) !== null && _a !== void 0 ? _a : this.atomicExpCache = [{\n        ALT: () => this.SUBRULE(this.arrayExpression)\n      }, {\n        ALT: () => this.SUBRULE(this.cellRangeExpression)\n      }, {\n        ALT: () => this.SUBRULE(this.columnRangeExpression)\n      }, {\n        ALT: () => this.SUBRULE(this.rowRangeExpression)\n      }, {\n        ALT: () => this.SUBRULE(this.offsetExpression)\n      }, {\n        ALT: () => this.SUBRULE(this.cellReference)\n      }, {\n        ALT: () => this.SUBRULE(this.procedureExpression)\n      }, {\n        ALT: () => this.SUBRULE(this.namedExpressionExpression)\n      }, {\n        ALT: () => {\n          const number = this.CONSUME(this.lexerConfig.NumberLiteral);\n          return buildNumberAst(this.numericStringToNumber(number.image), number.leadingWhitespace);\n        }\n      }, {\n        ALT: () => {\n          const str = this.CONSUME(StringLiteral);\n          return buildStringAst(str);\n        }\n      }, {\n        ALT: () => {\n          const token = this.CONSUME(ErrorLiteral);\n          const errString = token.image.toUpperCase();\n          const errorType = this.lexerConfig.errorMapping[errString];\n          if (errorType) {\n            return buildCellErrorAst(new CellError(errorType), token.leadingWhitespace);\n          } else {\n            return this.parsingError(ParsingErrorType.ParserError, 'Unknown error literal');\n          }\n        }\n      }]);\n    });\n    this.rightUnaryOpAtomicExpression = this.RULE('rightUnaryOpAtomicExpression', () => {\n      const positiveAtomicExpression = this.SUBRULE(this.positiveAtomicExpression);\n      const percentage = this.OPTION(() => {\n        return this.CONSUME(PercentOp);\n      });\n      if (percentage) {\n        return buildPercentOpAst(positiveAtomicExpression, percentage.leadingWhitespace);\n      }\n      return positiveAtomicExpression;\n    });\n    /**\r\n     * Rule for atomic expressions, which is positive atomic expression or negation of it\r\n     */\n    this.atomicExpression = this.RULE('atomicExpression', () => {\n      return this.OR([{\n        ALT: () => {\n          const op = this.CONSUME(AdditionOp);\n          const value = this.SUBRULE(this.atomicExpression);\n          if (tokenMatcher(op, PlusOp)) {\n            return buildPlusUnaryOpAst(value, op.leadingWhitespace);\n          } else if (tokenMatcher(op, MinusOp)) {\n            return buildMinusUnaryOpAst(value, op.leadingWhitespace);\n          } else {\n            this.customParsingError = parsingError(ParsingErrorType.ParserError, 'Mismatched token type');\n            return this.customParsingError;\n          }\n        }\n      }, {\n        ALT: () => this.SUBRULE2(this.rightUnaryOpAtomicExpression)\n      }]);\n    });\n    /**\r\n     * Rule for power expression\r\n     */\n    this.powerExpression = this.RULE('powerExpression', () => {\n      let lhs = this.SUBRULE(this.atomicExpression);\n      this.MANY(() => {\n        const op = this.CONSUME(PowerOp);\n        const rhs = this.SUBRULE2(this.atomicExpression);\n        if (tokenMatcher(op, PowerOp)) {\n          lhs = buildPowerOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          this.ACTION(() => {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n      return lhs;\n    });\n    /**\r\n     * Rule for multiplication category operators (e.g., 1 * A1, 1 / A1)\r\n     */\n    this.multiplicationExpression = this.RULE('multiplicationExpression', () => {\n      let lhs = this.SUBRULE(this.powerExpression);\n      this.MANY(() => {\n        const op = this.CONSUME(MultiplicationOp);\n        const rhs = this.SUBRULE2(this.powerExpression);\n        if (tokenMatcher(op, TimesOp)) {\n          lhs = buildTimesOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, DivOp)) {\n          lhs = buildDivOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          this.ACTION(() => {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n      return lhs;\n    });\n    /**\r\n     * Rule for addition category operators (e.g., 1 + A1, 1 - A1)\r\n     */\n    this.additionExpression = this.RULE('additionExpression', () => {\n      let lhs = this.SUBRULE(this.multiplicationExpression);\n      this.MANY(() => {\n        const op = this.CONSUME(AdditionOp);\n        const rhs = this.SUBRULE2(this.multiplicationExpression);\n        if (tokenMatcher(op, PlusOp)) {\n          lhs = buildPlusOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, MinusOp)) {\n          lhs = buildMinusOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          this.ACTION(() => {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n      return lhs;\n    });\n    /**\r\n     * Rule for concatenation operator expression (e.g., \"=\" & A1)\r\n     */\n    this.concatenateExpression = this.RULE('concatenateExpression', () => {\n      let lhs = this.SUBRULE(this.additionExpression);\n      this.MANY(() => {\n        const op = this.CONSUME(ConcatenateOp);\n        const rhs = this.SUBRULE2(this.additionExpression);\n        lhs = buildConcatenateOpAst(lhs, rhs, op.leadingWhitespace);\n      });\n      return lhs;\n    });\n    /**\r\n     * Rule for boolean expression (e.g., 1 <= A1)\r\n     */\n    this.booleanExpression = this.RULE('booleanExpression', () => {\n      let lhs = this.SUBRULE(this.concatenateExpression);\n      this.MANY(() => {\n        const op = this.CONSUME(BooleanOp);\n        const rhs = this.SUBRULE2(this.concatenateExpression);\n        if (tokenMatcher(op, EqualsOp)) {\n          lhs = buildEqualsOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, NotEqualOp)) {\n          lhs = buildNotEqualOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, GreaterThanOp)) {\n          lhs = buildGreaterThanOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, LessThanOp)) {\n          lhs = buildLessThanOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, GreaterThanOrEqualOp)) {\n          lhs = buildGreaterThanOrEqualOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, LessThanOrEqualOp)) {\n          lhs = buildLessThanOrEqualOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          this.ACTION(() => {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n      return lhs;\n    });\n    /**\r\n     * Entry rule\r\n     */\n    this.formula = this.RULE('formula', () => {\n      this.CONSUME(EqualsOp);\n      return this.SUBRULE(this.booleanExpression);\n    });\n    this.lexerConfig = lexerConfig;\n    this.sheetMapping = sheetMapping;\n    this.formulaAddress = simpleCellAddress(0, 0, 0);\n    this.performSelfAnalysis();\n  }\n  /**\r\n   * Parses tokenized formula and builds abstract syntax tree\r\n   *\r\n   * @param {ExtendedToken[]} tokens - tokenized formula\r\n   * @param {SimpleCellAddress} formulaAddress - address of the cell in which formula is located\r\n   */\n  parseFromTokens(tokens, formulaAddress) {\n    this.input = tokens;\n    let ast = this.formulaWithContext(formulaAddress);\n    let errors = [];\n    if (this.customParsingError) {\n      errors.push(this.customParsingError);\n    }\n    errors = errors.concat(this.errors.map(e => ({\n      type: ParsingErrorType.ParserError,\n      message: e.message\n    })));\n    if (errors.length > 0) {\n      ast = buildParsingErrorAst();\n    }\n    return {\n      ast,\n      errors\n    };\n  }\n  reset() {\n    super.reset();\n    this.customParsingError = undefined;\n  }\n  /**\r\n   * Entry rule wrapper that sets formula address\r\n   *\r\n   * @param {SimpleCellAddress} address - address of the cell in which formula is located\r\n   */\n  formulaWithContext(address) {\n    this.formulaAddress = address;\n    return this.formula();\n  }\n  buildCellRange(firstAddress, secondAddress, leadingWhitespace) {\n    if (firstAddress.sheet === undefined && secondAddress.sheet !== undefined) {\n      return this.parsingError(ParsingErrorType.ParserError, 'Malformed range expression');\n    }\n    const {\n      firstEnd,\n      secondEnd,\n      sheetRefType\n    } = FormulaParser.fixSheetIdsForRangeEnds(firstAddress, secondAddress);\n    return buildCellRangeAst(firstEnd, secondEnd, sheetRefType, leadingWhitespace);\n  }\n  static fixSheetIdsForRangeEnds(firstEnd, secondEnd) {\n    const sheetRefType = FormulaParser.rangeSheetReferenceType(firstEnd.sheet, secondEnd.sheet);\n    const secondEndFixed = firstEnd.sheet !== undefined && secondEnd.sheet === undefined ? secondEnd.withSheet(firstEnd.sheet) : secondEnd;\n    return {\n      firstEnd,\n      secondEnd: secondEndFixed,\n      sheetRefType\n    };\n  }\n  /**\r\n   * Returns {@link CellReferenceAst} or {@link CellRangeAst} based on OFFSET function arguments\r\n   *\r\n   * @param {Ast[]} args - OFFSET function arguments\r\n   */\n  handleOffsetHeuristic(args) {\n    const cellArg = args[0];\n    if (cellArg.type !== AstNodeType.CELL_REFERENCE) {\n      return this.parsingError(ParsingErrorType.StaticOffsetError, 'First argument to OFFSET is not a reference');\n    }\n    const rowsArg = args[1];\n    let rowShift;\n    if (rowsArg.type === AstNodeType.NUMBER && Number.isInteger(rowsArg.value)) {\n      rowShift = rowsArg.value;\n    } else if (rowsArg.type === AstNodeType.PLUS_UNARY_OP && rowsArg.value.type === AstNodeType.NUMBER && Number.isInteger(rowsArg.value.value)) {\n      rowShift = rowsArg.value.value;\n    } else if (rowsArg.type === AstNodeType.MINUS_UNARY_OP && rowsArg.value.type === AstNodeType.NUMBER && Number.isInteger(rowsArg.value.value)) {\n      rowShift = -rowsArg.value.value;\n    } else {\n      return this.parsingError(ParsingErrorType.StaticOffsetError, 'Second argument to OFFSET is not a static number');\n    }\n    const columnsArg = args[2];\n    let colShift;\n    if (columnsArg.type === AstNodeType.NUMBER && Number.isInteger(columnsArg.value)) {\n      colShift = columnsArg.value;\n    } else if (columnsArg.type === AstNodeType.PLUS_UNARY_OP && columnsArg.value.type === AstNodeType.NUMBER && Number.isInteger(columnsArg.value.value)) {\n      colShift = columnsArg.value.value;\n    } else if (columnsArg.type === AstNodeType.MINUS_UNARY_OP && columnsArg.value.type === AstNodeType.NUMBER && Number.isInteger(columnsArg.value.value)) {\n      colShift = -columnsArg.value.value;\n    } else {\n      return this.parsingError(ParsingErrorType.StaticOffsetError, 'Third argument to OFFSET is not a static number');\n    }\n    const heightArg = args[3];\n    let height;\n    if (heightArg === undefined) {\n      height = 1;\n    } else if (heightArg.type === AstNodeType.NUMBER) {\n      height = heightArg.value;\n      if (height < 1) {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is too small number');\n      } else if (!Number.isInteger(height)) {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is not integer');\n      }\n    } else {\n      return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is not a static number');\n    }\n    const widthArg = args[4];\n    let width;\n    if (widthArg === undefined) {\n      width = 1;\n    } else if (widthArg.type === AstNodeType.NUMBER) {\n      width = widthArg.value;\n      if (width < 1) {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is too small number');\n      } else if (!Number.isInteger(width)) {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is not integer');\n      }\n    } else {\n      return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is not a static number');\n    }\n    const topLeftCorner = new CellAddress(cellArg.reference.col + colShift, cellArg.reference.row + rowShift, cellArg.reference.type);\n    let absoluteCol = topLeftCorner.col;\n    let absoluteRow = topLeftCorner.row;\n    if (cellArg.reference.type === CellReferenceType.CELL_REFERENCE_RELATIVE || cellArg.reference.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL) {\n      absoluteRow = absoluteRow + this.formulaAddress.row;\n    }\n    if (cellArg.reference.type === CellReferenceType.CELL_REFERENCE_RELATIVE || cellArg.reference.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      absoluteCol = absoluteCol + this.formulaAddress.col;\n    }\n    if (absoluteCol < 0 || absoluteRow < 0) {\n      return buildCellErrorAst(new CellError(ErrorType.REF, ErrorMessage.OutOfSheet));\n    }\n    if (width === 1 && height === 1) {\n      return buildCellReferenceAst(topLeftCorner);\n    } else {\n      const bottomRightCorner = new CellAddress(topLeftCorner.col + width - 1, topLeftCorner.row + height - 1, topLeftCorner.type);\n      return buildCellRangeAst(topLeftCorner, bottomRightCorner, RangeSheetReferenceType.RELATIVE);\n    }\n  }\n  parsingError(type, message) {\n    this.customParsingError = parsingError(type, message);\n    return buildParsingErrorAst();\n  }\n  static rangeSheetReferenceType(start, end) {\n    if (start === undefined) {\n      return RangeSheetReferenceType.RELATIVE;\n    } else if (end === undefined) {\n      return RangeSheetReferenceType.START_ABSOLUTE;\n    } else {\n      return RangeSheetReferenceType.BOTH_ABSOLUTE;\n    }\n  }\n}\nexport class FormulaLexer {\n  constructor(lexerConfig) {\n    this.lexerConfig = lexerConfig;\n    this.lexer = new Lexer(lexerConfig.allTokens, {\n      ensureOptimizations: true\n    });\n  }\n  /**\r\n   * Returns Lexer tokens from formula string\r\n   *\r\n   * @param {string} text - string representation of a formula\r\n   */\n  tokenizeFormula(text) {\n    const lexingResult = this.lexer.tokenize(text);\n    let tokens = lexingResult.tokens;\n    tokens = this.trimTrailingWhitespaces(tokens);\n    tokens = this.skipWhitespacesInsideRanges(tokens);\n    tokens = this.skipWhitespacesBeforeArgSeparators(tokens);\n    lexingResult.tokens = tokens;\n    return lexingResult;\n  }\n  skipWhitespacesInsideRanges(tokens) {\n    return FormulaLexer.filterTokensByNeighbors(tokens, (previous, current, next) => {\n      return (tokenMatcher(previous, CellReference) || tokenMatcher(previous, RangeSeparator)) && tokenMatcher(current, this.lexerConfig.WhiteSpace) && (tokenMatcher(next, CellReference) || tokenMatcher(next, RangeSeparator));\n    });\n  }\n  skipWhitespacesBeforeArgSeparators(tokens) {\n    return FormulaLexer.filterTokensByNeighbors(tokens, (previous, current, next) => {\n      return !tokenMatcher(previous, this.lexerConfig.ArgSeparator) && tokenMatcher(current, this.lexerConfig.WhiteSpace) && tokenMatcher(next, this.lexerConfig.ArgSeparator);\n    });\n  }\n  static filterTokensByNeighbors(tokens, shouldBeSkipped) {\n    if (tokens.length < 3) {\n      return tokens;\n    }\n    let i = 0;\n    const filteredTokens = [tokens[i++]];\n    while (i < tokens.length - 1) {\n      if (!shouldBeSkipped(tokens[i - 1], tokens[i], tokens[i + 1])) {\n        filteredTokens.push(tokens[i]);\n      }\n      ++i;\n    }\n    filteredTokens.push(tokens[i]);\n    return filteredTokens;\n  }\n  trimTrailingWhitespaces(tokens) {\n    if (tokens.length > 0 && tokenMatcher(tokens[tokens.length - 1], this.lexerConfig.WhiteSpace)) {\n      tokens.pop();\n    }\n    return tokens;\n  }\n}","map":{"version":3,"names":["EmbeddedActionsParser","EMPTY_ALT","Lexer","tokenMatcher","CellError","ErrorType","simpleCellAddress","ErrorMessage","cellAddressFromString","columnAddressFromString","rowAddressFromString","AstNodeType","buildArrayAst","buildCellErrorAst","buildCellRangeAst","buildCellReferenceAst","buildColumnRangeAst","buildConcatenateOpAst","buildDivOpAst","buildEmptyArgAst","buildEqualsOpAst","buildErrorWithRawInputAst","buildGreaterThanOpAst","buildGreaterThanOrEqualOpAst","buildLessThanOpAst","buildLessThanOrEqualOpAst","buildMinusOpAst","buildMinusUnaryOpAst","buildNamedExpressionAst","buildNotEqualOpAst","buildNumberAst","buildParenthesisAst","buildParsingErrorAst","buildPercentOpAst","buildPlusOpAst","buildPlusUnaryOpAst","buildPowerOpAst","buildProcedureAst","buildRowRangeAst","buildStringAst","buildTimesOpAst","parsingError","ParsingErrorType","RangeSheetReferenceType","CellAddress","CellReferenceType","AdditionOp","ArrayLParen","ArrayRParen","BooleanOp","CellReference","ColumnRange","ConcatenateOp","DivOp","EqualsOp","ErrorLiteral","GreaterThanOp","GreaterThanOrEqualOp","LessThanOp","LessThanOrEqualOp","LParen","MinusOp","MultiplicationOp","NamedExpression","NotEqualOp","PercentOp","PlusOp","PowerOp","ProcedureName","RangeSeparator","RowRange","RParen","StringLiteral","TimesOp","FormulaParser","constructor","lexerConfig","sheetMapping","allTokens","outputCst","maxLookahead","booleanExpressionOrEmpty","RULE","OR","ALT","SUBRULE","booleanExpression","procedureExpression","_a","procedureNameToken","CONSUME","procedureName","image","toUpperCase","slice","canonicalProcedureName","functionMapping","args","argument","MANY","separator","ArgSeparator","type","EMPTY","leadingWhitespace","push","SUBRULE2","length","rParenToken","namedExpressionExpression","name","offsetProcedureExpression","OffsetProcedureName","MANY_SEP","SEP","DEF","handleOffsetHeuristic","columnRangeExpression","range","startImage","endImage","split","firstAddress","ACTION","formulaAddress","secondAddress","undefined","REF","exceedsSheetSizeLimits","maxColumns","NAME","sheet","ParserError","firstEnd","secondEnd","sheetRefType","fixSheetIdsForRangeEnds","rowRangeExpression","maxRows","cellReference","cell","address","endRangeReference","start","end","startAddress","endAddress","buildCellRange","endOfRangeExpression","ARGS","offsetProcedure","CELL_REFERENCE","reference","RangeOffsetNotAllowed","cellRangeExpression","CONSUME2","endRangeWithOffsetStartReference","endOfRangeWithOffsetStartExpression","offsetExpression","OPTION","CELL_RANGE","insideArrayExpression","ret","ArrayColSeparator","ArrayRowSeparator","SUBRULE3","parenthesisExpression","lParenToken","expression","arrayExpression","ltoken","rtoken","numericStringToNumber","input","normalized","replace","decimalSeparator","Number","positiveAtomicExpression","atomicExpCache","number","NumberLiteral","str","token","errString","errorType","errorMapping","rightUnaryOpAtomicExpression","percentage","atomicExpression","op","value","customParsingError","powerExpression","lhs","rhs","Error","multiplicationExpression","additionExpression","concatenateExpression","formula","performSelfAnalysis","parseFromTokens","tokens","ast","formulaWithContext","errors","concat","map","e","message","reset","rangeSheetReferenceType","secondEndFixed","withSheet","cellArg","StaticOffsetError","rowsArg","rowShift","NUMBER","isInteger","PLUS_UNARY_OP","MINUS_UNARY_OP","columnsArg","colShift","heightArg","height","widthArg","width","topLeftCorner","col","row","absoluteCol","absoluteRow","CELL_REFERENCE_RELATIVE","CELL_REFERENCE_ABSOLUTE_COL","CELL_REFERENCE_ABSOLUTE_ROW","OutOfSheet","bottomRightCorner","RELATIVE","START_ABSOLUTE","BOTH_ABSOLUTE","FormulaLexer","lexer","ensureOptimizations","tokenizeFormula","text","lexingResult","tokenize","trimTrailingWhitespaces","skipWhitespacesInsideRanges","skipWhitespacesBeforeArgSeparators","filterTokensByNeighbors","previous","current","next","WhiteSpace","shouldBeSkipped","i","filteredTokens","pop"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/parser/FormulaParser.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { EmbeddedActionsParser, EMPTY_ALT, Lexer, tokenMatcher } from 'chevrotain';\nimport { CellError, ErrorType, simpleCellAddress } from \"../Cell.mjs\";\nimport { ErrorMessage } from \"../error-message.mjs\";\nimport { cellAddressFromString, columnAddressFromString, rowAddressFromString } from \"./addressRepresentationConverters.mjs\";\nimport { AstNodeType, buildArrayAst, buildCellErrorAst, buildCellRangeAst, buildCellReferenceAst, buildColumnRangeAst, buildConcatenateOpAst, buildDivOpAst, buildEmptyArgAst, buildEqualsOpAst, buildErrorWithRawInputAst, buildGreaterThanOpAst, buildGreaterThanOrEqualOpAst, buildLessThanOpAst, buildLessThanOrEqualOpAst, buildMinusOpAst, buildMinusUnaryOpAst, buildNamedExpressionAst, buildNotEqualOpAst, buildNumberAst, buildParenthesisAst, buildParsingErrorAst, buildPercentOpAst, buildPlusOpAst, buildPlusUnaryOpAst, buildPowerOpAst, buildProcedureAst, buildRowRangeAst, buildStringAst, buildTimesOpAst, parsingError, ParsingErrorType, RangeSheetReferenceType } from \"./Ast.mjs\";\nimport { CellAddress, CellReferenceType } from \"./CellAddress.mjs\";\nimport { AdditionOp, ArrayLParen, ArrayRParen, BooleanOp, CellReference, ColumnRange, ConcatenateOp, DivOp, EqualsOp, ErrorLiteral, GreaterThanOp, GreaterThanOrEqualOp, LessThanOp, LessThanOrEqualOp, LParen, MinusOp, MultiplicationOp, NamedExpression, NotEqualOp, PercentOp, PlusOp, PowerOp, ProcedureName, RangeSeparator, RowRange, RParen, StringLiteral, TimesOp } from \"./LexerConfig.mjs\";\n/**\r\n * LL(k) formula parser described using Chevrotain DSL\r\n *\r\n * It is equivalent to the grammar below:\r\n *\r\n * F -> '=' E <br/>\r\n * B -> K < B | K >= B ... | K <br/>\r\n * K -> E & K | E <br/>\r\n * E -> M + E | M - E | M <br/>\r\n * M -> W * M | W / M | W <br/>\r\n * W -> C * W | C <br/>\r\n * C -> N | R | O | A | P | num <br/>\r\n * N -> '(' E ')' <br/>\r\n * R -> A:OFFSET(..) | A:A <br/>\r\n * O -> OFFSET(..) | OFFSET(..):A | OFFSET(..):OFFSET(..) <br/>\r\n * A -> A1 | $A1 | A$1 | $A$1 <br/>\r\n * P -> SUM(..) <br/>\r\n */\nexport class FormulaParser extends EmbeddedActionsParser {\n  constructor(lexerConfig, sheetMapping) {\n    super(lexerConfig.allTokens, {\n      outputCst: false,\n      maxLookahead: 7\n    });\n    this.booleanExpressionOrEmpty = this.RULE('booleanExpressionOrEmpty', () => {\n      return this.OR([{\n        ALT: () => this.SUBRULE(this.booleanExpression)\n      }, {\n        ALT: EMPTY_ALT(buildEmptyArgAst())\n      }]);\n    });\n    /**\r\n     * Rule for procedure expressions: SUM(1,A1)\r\n     */\n    this.procedureExpression = this.RULE('procedureExpression', () => {\n      var _a;\n      const procedureNameToken = this.CONSUME(ProcedureName);\n      const procedureName = procedureNameToken.image.toUpperCase().slice(0, -1);\n      const canonicalProcedureName = (_a = this.lexerConfig.functionMapping[procedureName]) !== null && _a !== void 0 ? _a : procedureName;\n      const args = [];\n      let argument = this.SUBRULE(this.booleanExpressionOrEmpty);\n      this.MANY(() => {\n        var _a;\n        const separator = this.CONSUME(this.lexerConfig.ArgSeparator);\n        if (argument.type === AstNodeType.EMPTY) {\n          argument.leadingWhitespace = (_a = separator.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image;\n        }\n        args.push(argument);\n        argument = this.SUBRULE2(this.booleanExpressionOrEmpty);\n      });\n      args.push(argument);\n      if (args.length === 1 && args[0].type === AstNodeType.EMPTY) {\n        args.length = 0;\n      }\n      const rParenToken = this.CONSUME(RParen);\n      return buildProcedureAst(canonicalProcedureName, args, procedureNameToken.leadingWhitespace, rParenToken.leadingWhitespace);\n    });\n    this.namedExpressionExpression = this.RULE('namedExpressionExpression', () => {\n      const name = this.CONSUME(NamedExpression);\n      return buildNamedExpressionAst(name.image, name.leadingWhitespace);\n    });\n    /**\r\n     * Rule for OFFSET() function expression\r\n     */\n    this.offsetProcedureExpression = this.RULE('offsetProcedureExpression', () => {\n      const args = [];\n      this.CONSUME(this.lexerConfig.OffsetProcedureName);\n      this.CONSUME(LParen);\n      this.MANY_SEP({\n        SEP: this.lexerConfig.ArgSeparator,\n        DEF: () => {\n          args.push(this.SUBRULE(this.booleanExpression));\n        }\n      });\n      this.CONSUME(RParen);\n      return this.handleOffsetHeuristic(args);\n    });\n    /**\r\n     * Rule for column range, e.g., A:B, Sheet1!A:B, Sheet1!A:Sheet1!B\r\n     */\n    this.columnRangeExpression = this.RULE('columnRangeExpression', () => {\n      const range = this.CONSUME(ColumnRange);\n      const [startImage, endImage] = range.image.split(':');\n      const firstAddress = this.ACTION(() => columnAddressFromString(this.sheetMapping, startImage, this.formulaAddress));\n      const secondAddress = this.ACTION(() => columnAddressFromString(this.sheetMapping, endImage, this.formulaAddress));\n      if (firstAddress === undefined || secondAddress === undefined) {\n        return buildCellErrorAst(new CellError(ErrorType.REF));\n      }\n      if (firstAddress.exceedsSheetSizeLimits(this.lexerConfig.maxColumns) || secondAddress.exceedsSheetSizeLimits(this.lexerConfig.maxColumns)) {\n        return buildErrorWithRawInputAst(range.image, new CellError(ErrorType.NAME), range.leadingWhitespace);\n      }\n      if (firstAddress.sheet === undefined && secondAddress.sheet !== undefined) {\n        return this.parsingError(ParsingErrorType.ParserError, 'Malformed range expression');\n      }\n      const {\n        firstEnd,\n        secondEnd,\n        sheetRefType\n      } = FormulaParser.fixSheetIdsForRangeEnds(firstAddress, secondAddress);\n      return buildColumnRangeAst(firstEnd, secondEnd, sheetRefType, range.leadingWhitespace);\n    });\n    /**\r\n     * Rule for row range, e.g., 1:2, Sheet1!1:2, Sheet1!1:Sheet1!2\r\n     */\n    this.rowRangeExpression = this.RULE('rowRangeExpression', () => {\n      const range = this.CONSUME(RowRange);\n      const [startImage, endImage] = range.image.split(':');\n      const firstAddress = this.ACTION(() => rowAddressFromString(this.sheetMapping, startImage, this.formulaAddress));\n      const secondAddress = this.ACTION(() => rowAddressFromString(this.sheetMapping, endImage, this.formulaAddress));\n      if (firstAddress === undefined || secondAddress === undefined) {\n        return buildCellErrorAst(new CellError(ErrorType.REF));\n      }\n      if (firstAddress.exceedsSheetSizeLimits(this.lexerConfig.maxRows) || secondAddress.exceedsSheetSizeLimits(this.lexerConfig.maxRows)) {\n        return buildErrorWithRawInputAst(range.image, new CellError(ErrorType.NAME), range.leadingWhitespace);\n      }\n      if (firstAddress.sheet === undefined && secondAddress.sheet !== undefined) {\n        return this.parsingError(ParsingErrorType.ParserError, 'Malformed range expression');\n      }\n      const {\n        firstEnd,\n        secondEnd,\n        sheetRefType\n      } = FormulaParser.fixSheetIdsForRangeEnds(firstAddress, secondAddress);\n      return buildRowRangeAst(firstEnd, secondEnd, sheetRefType, range.leadingWhitespace);\n    });\n    /**\r\n     * Rule for cell reference expression (e.g., A1, $A1, A$1, $A$1, $Sheet42!A$17)\r\n     */\n    this.cellReference = this.RULE('cellReference', () => {\n      const cell = this.CONSUME(CellReference);\n      const address = this.ACTION(() => {\n        return cellAddressFromString(this.sheetMapping, cell.image, this.formulaAddress);\n      });\n      if (address === undefined) {\n        return buildErrorWithRawInputAst(cell.image, new CellError(ErrorType.REF), cell.leadingWhitespace);\n      } else if (address.exceedsSheetSizeLimits(this.lexerConfig.maxColumns, this.lexerConfig.maxRows)) {\n        return buildErrorWithRawInputAst(cell.image, new CellError(ErrorType.NAME), cell.leadingWhitespace);\n      } else {\n        return buildCellReferenceAst(address, cell.leadingWhitespace);\n      }\n    });\n    /**\r\n     * Rule for end range reference expression with additional checks considering range start\r\n     */\n    this.endRangeReference = this.RULE('endRangeReference', start => {\n      var _a;\n      const end = this.CONSUME(CellReference);\n      const startAddress = this.ACTION(() => {\n        return cellAddressFromString(this.sheetMapping, start.image, this.formulaAddress);\n      });\n      const endAddress = this.ACTION(() => {\n        return cellAddressFromString(this.sheetMapping, end.image, this.formulaAddress);\n      });\n      if (startAddress === undefined || endAddress === undefined) {\n        return this.ACTION(() => {\n          return buildErrorWithRawInputAst(`${start.image}:${end.image}`, new CellError(ErrorType.REF), start.leadingWhitespace);\n        });\n      } else if (startAddress.exceedsSheetSizeLimits(this.lexerConfig.maxColumns, this.lexerConfig.maxRows) || endAddress.exceedsSheetSizeLimits(this.lexerConfig.maxColumns, this.lexerConfig.maxRows)) {\n        return this.ACTION(() => {\n          return buildErrorWithRawInputAst(`${start.image}:${end.image}`, new CellError(ErrorType.NAME), start.leadingWhitespace);\n        });\n      }\n      return this.buildCellRange(startAddress, endAddress, (_a = start.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image);\n    });\n    /**\r\n     * Rule for end of range expression\r\n     *\r\n     * End of range may be a cell reference or OFFSET() function call\r\n     */\n    this.endOfRangeExpression = this.RULE('endOfRangeExpression', start => {\n      return this.OR([{\n        ALT: () => {\n          return this.SUBRULE(this.endRangeReference, {\n            ARGS: [start]\n          });\n        }\n      }, {\n        ALT: () => {\n          var _a;\n          const offsetProcedure = this.SUBRULE(this.offsetProcedureExpression);\n          const startAddress = this.ACTION(() => {\n            return cellAddressFromString(this.sheetMapping, start.image, this.formulaAddress);\n          });\n          if (startAddress === undefined) {\n            return buildCellErrorAst(new CellError(ErrorType.REF));\n          }\n          if (offsetProcedure.type === AstNodeType.CELL_REFERENCE) {\n            return this.buildCellRange(startAddress, offsetProcedure.reference, (_a = start.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image);\n          } else {\n            return this.parsingError(ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');\n          }\n        }\n      }]);\n    });\n    /**\r\n     * Rule for cell ranges (e.g., A1:B$3, A1:OFFSET())\r\n     */\n    this.cellRangeExpression = this.RULE('cellRangeExpression', () => {\n      const start = this.CONSUME(CellReference);\n      this.CONSUME2(RangeSeparator);\n      return this.SUBRULE(this.endOfRangeExpression, {\n        ARGS: [start]\n      });\n    });\n    /**\r\n     * Rule for end range reference expression starting with offset procedure with additional checks considering range start\r\n     */\n    this.endRangeWithOffsetStartReference = this.RULE('endRangeWithOffsetStartReference', start => {\n      const end = this.CONSUME(CellReference);\n      const endAddress = this.ACTION(() => {\n        return cellAddressFromString(this.sheetMapping, end.image, this.formulaAddress);\n      });\n      if (endAddress === undefined) {\n        return this.ACTION(() => {\n          return buildCellErrorAst(new CellError(ErrorType.REF));\n        });\n      }\n      return this.buildCellRange(start.reference, endAddress, start.leadingWhitespace);\n    });\n    /**\r\n     * Rule for end of range expression\r\n     *\r\n     * End of range may be a cell reference or OFFSET() function call\r\n     */\n    this.endOfRangeWithOffsetStartExpression = this.RULE('endOfRangeWithOffsetStartExpression', start => {\n      return this.OR([{\n        ALT: () => {\n          return this.SUBRULE(this.endRangeWithOffsetStartReference, {\n            ARGS: [start]\n          });\n        }\n      }, {\n        ALT: () => {\n          const offsetProcedure = this.SUBRULE(this.offsetProcedureExpression);\n          if (offsetProcedure.type === AstNodeType.CELL_REFERENCE) {\n            return this.buildCellRange(start.reference, offsetProcedure.reference, start.leadingWhitespace);\n          } else {\n            return this.parsingError(ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');\n          }\n        }\n      }]);\n    });\n    /**\r\n     * Rule for expressions that start with the OFFSET function.\r\n     *\r\n     * The OFFSET function can occur as a cell reference, or as a part of a cell range.\r\n     * To preserve LL(k) properties, expressions that start with the OFFSET function need a separate rule.\r\n     *\r\n     * Depending on the presence of the {@link RangeSeparator}, a proper {@link Ast} node type is built.\r\n     */\n    this.offsetExpression = this.RULE('offsetExpression', () => {\n      const offsetProcedure = this.SUBRULE(this.offsetProcedureExpression);\n      let end;\n      this.OPTION(() => {\n        this.CONSUME(RangeSeparator);\n        if (offsetProcedure.type === AstNodeType.CELL_RANGE) {\n          end = this.parsingError(ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');\n        } else {\n          end = this.SUBRULE(this.endOfRangeWithOffsetStartExpression, {\n            ARGS: [offsetProcedure]\n          });\n        }\n      });\n      if (end !== undefined) {\n        return end;\n      }\n      return offsetProcedure;\n    });\n    this.insideArrayExpression = this.RULE('insideArrayExpression', () => {\n      const ret = [[]];\n      ret[ret.length - 1].push(this.SUBRULE(this.booleanExpression));\n      this.MANY(() => {\n        this.OR([{\n          ALT: () => {\n            this.CONSUME(this.lexerConfig.ArrayColSeparator);\n            ret[ret.length - 1].push(this.SUBRULE2(this.booleanExpression));\n          }\n        }, {\n          ALT: () => {\n            this.CONSUME(this.lexerConfig.ArrayRowSeparator);\n            ret.push([]);\n            ret[ret.length - 1].push(this.SUBRULE3(this.booleanExpression));\n          }\n        }]);\n      });\n      return buildArrayAst(ret);\n    });\n    /**\r\n     * Rule for parenthesis expression\r\n     */\n    this.parenthesisExpression = this.RULE('parenthesisExpression', () => {\n      const lParenToken = this.CONSUME(LParen);\n      const expression = this.SUBRULE(this.booleanExpression);\n      const rParenToken = this.CONSUME(RParen);\n      return buildParenthesisAst(expression, lParenToken.leadingWhitespace, rParenToken.leadingWhitespace);\n    });\n    this.arrayExpression = this.RULE('arrayExpression', () => {\n      return this.OR([{\n        ALT: () => {\n          const ltoken = this.CONSUME(ArrayLParen);\n          const ret = this.SUBRULE(this.insideArrayExpression);\n          const rtoken = this.CONSUME(ArrayRParen);\n          return buildArrayAst(ret.args, ltoken.leadingWhitespace, rtoken.leadingWhitespace);\n        }\n      }, {\n        ALT: () => this.SUBRULE(this.parenthesisExpression)\n      }]);\n    });\n    this.numericStringToNumber = input => {\n      const normalized = input.replace(this.lexerConfig.decimalSeparator, '.');\n      return Number(normalized);\n    };\n    /**\r\n     * Rule for positive atomic expressions\r\n     */\n    this.positiveAtomicExpression = this.RULE('positiveAtomicExpression', () => {\n      var _a;\n      return this.OR((_a = this.atomicExpCache) !== null && _a !== void 0 ? _a : this.atomicExpCache = [{\n        ALT: () => this.SUBRULE(this.arrayExpression)\n      }, {\n        ALT: () => this.SUBRULE(this.cellRangeExpression)\n      }, {\n        ALT: () => this.SUBRULE(this.columnRangeExpression)\n      }, {\n        ALT: () => this.SUBRULE(this.rowRangeExpression)\n      }, {\n        ALT: () => this.SUBRULE(this.offsetExpression)\n      }, {\n        ALT: () => this.SUBRULE(this.cellReference)\n      }, {\n        ALT: () => this.SUBRULE(this.procedureExpression)\n      }, {\n        ALT: () => this.SUBRULE(this.namedExpressionExpression)\n      }, {\n        ALT: () => {\n          const number = this.CONSUME(this.lexerConfig.NumberLiteral);\n          return buildNumberAst(this.numericStringToNumber(number.image), number.leadingWhitespace);\n        }\n      }, {\n        ALT: () => {\n          const str = this.CONSUME(StringLiteral);\n          return buildStringAst(str);\n        }\n      }, {\n        ALT: () => {\n          const token = this.CONSUME(ErrorLiteral);\n          const errString = token.image.toUpperCase();\n          const errorType = this.lexerConfig.errorMapping[errString];\n          if (errorType) {\n            return buildCellErrorAst(new CellError(errorType), token.leadingWhitespace);\n          } else {\n            return this.parsingError(ParsingErrorType.ParserError, 'Unknown error literal');\n          }\n        }\n      }]);\n    });\n    this.rightUnaryOpAtomicExpression = this.RULE('rightUnaryOpAtomicExpression', () => {\n      const positiveAtomicExpression = this.SUBRULE(this.positiveAtomicExpression);\n      const percentage = this.OPTION(() => {\n        return this.CONSUME(PercentOp);\n      });\n      if (percentage) {\n        return buildPercentOpAst(positiveAtomicExpression, percentage.leadingWhitespace);\n      }\n      return positiveAtomicExpression;\n    });\n    /**\r\n     * Rule for atomic expressions, which is positive atomic expression or negation of it\r\n     */\n    this.atomicExpression = this.RULE('atomicExpression', () => {\n      return this.OR([{\n        ALT: () => {\n          const op = this.CONSUME(AdditionOp);\n          const value = this.SUBRULE(this.atomicExpression);\n          if (tokenMatcher(op, PlusOp)) {\n            return buildPlusUnaryOpAst(value, op.leadingWhitespace);\n          } else if (tokenMatcher(op, MinusOp)) {\n            return buildMinusUnaryOpAst(value, op.leadingWhitespace);\n          } else {\n            this.customParsingError = parsingError(ParsingErrorType.ParserError, 'Mismatched token type');\n            return this.customParsingError;\n          }\n        }\n      }, {\n        ALT: () => this.SUBRULE2(this.rightUnaryOpAtomicExpression)\n      }]);\n    });\n    /**\r\n     * Rule for power expression\r\n     */\n    this.powerExpression = this.RULE('powerExpression', () => {\n      let lhs = this.SUBRULE(this.atomicExpression);\n      this.MANY(() => {\n        const op = this.CONSUME(PowerOp);\n        const rhs = this.SUBRULE2(this.atomicExpression);\n        if (tokenMatcher(op, PowerOp)) {\n          lhs = buildPowerOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          this.ACTION(() => {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n      return lhs;\n    });\n    /**\r\n     * Rule for multiplication category operators (e.g., 1 * A1, 1 / A1)\r\n     */\n    this.multiplicationExpression = this.RULE('multiplicationExpression', () => {\n      let lhs = this.SUBRULE(this.powerExpression);\n      this.MANY(() => {\n        const op = this.CONSUME(MultiplicationOp);\n        const rhs = this.SUBRULE2(this.powerExpression);\n        if (tokenMatcher(op, TimesOp)) {\n          lhs = buildTimesOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, DivOp)) {\n          lhs = buildDivOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          this.ACTION(() => {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n      return lhs;\n    });\n    /**\r\n     * Rule for addition category operators (e.g., 1 + A1, 1 - A1)\r\n     */\n    this.additionExpression = this.RULE('additionExpression', () => {\n      let lhs = this.SUBRULE(this.multiplicationExpression);\n      this.MANY(() => {\n        const op = this.CONSUME(AdditionOp);\n        const rhs = this.SUBRULE2(this.multiplicationExpression);\n        if (tokenMatcher(op, PlusOp)) {\n          lhs = buildPlusOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, MinusOp)) {\n          lhs = buildMinusOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          this.ACTION(() => {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n      return lhs;\n    });\n    /**\r\n     * Rule for concatenation operator expression (e.g., \"=\" & A1)\r\n     */\n    this.concatenateExpression = this.RULE('concatenateExpression', () => {\n      let lhs = this.SUBRULE(this.additionExpression);\n      this.MANY(() => {\n        const op = this.CONSUME(ConcatenateOp);\n        const rhs = this.SUBRULE2(this.additionExpression);\n        lhs = buildConcatenateOpAst(lhs, rhs, op.leadingWhitespace);\n      });\n      return lhs;\n    });\n    /**\r\n     * Rule for boolean expression (e.g., 1 <= A1)\r\n     */\n    this.booleanExpression = this.RULE('booleanExpression', () => {\n      let lhs = this.SUBRULE(this.concatenateExpression);\n      this.MANY(() => {\n        const op = this.CONSUME(BooleanOp);\n        const rhs = this.SUBRULE2(this.concatenateExpression);\n        if (tokenMatcher(op, EqualsOp)) {\n          lhs = buildEqualsOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, NotEqualOp)) {\n          lhs = buildNotEqualOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, GreaterThanOp)) {\n          lhs = buildGreaterThanOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, LessThanOp)) {\n          lhs = buildLessThanOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, GreaterThanOrEqualOp)) {\n          lhs = buildGreaterThanOrEqualOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, LessThanOrEqualOp)) {\n          lhs = buildLessThanOrEqualOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          this.ACTION(() => {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n      return lhs;\n    });\n    /**\r\n     * Entry rule\r\n     */\n    this.formula = this.RULE('formula', () => {\n      this.CONSUME(EqualsOp);\n      return this.SUBRULE(this.booleanExpression);\n    });\n    this.lexerConfig = lexerConfig;\n    this.sheetMapping = sheetMapping;\n    this.formulaAddress = simpleCellAddress(0, 0, 0);\n    this.performSelfAnalysis();\n  }\n  /**\r\n   * Parses tokenized formula and builds abstract syntax tree\r\n   *\r\n   * @param {ExtendedToken[]} tokens - tokenized formula\r\n   * @param {SimpleCellAddress} formulaAddress - address of the cell in which formula is located\r\n   */\n  parseFromTokens(tokens, formulaAddress) {\n    this.input = tokens;\n    let ast = this.formulaWithContext(formulaAddress);\n    let errors = [];\n    if (this.customParsingError) {\n      errors.push(this.customParsingError);\n    }\n    errors = errors.concat(this.errors.map(e => ({\n      type: ParsingErrorType.ParserError,\n      message: e.message\n    })));\n    if (errors.length > 0) {\n      ast = buildParsingErrorAst();\n    }\n    return {\n      ast,\n      errors\n    };\n  }\n  reset() {\n    super.reset();\n    this.customParsingError = undefined;\n  }\n  /**\r\n   * Entry rule wrapper that sets formula address\r\n   *\r\n   * @param {SimpleCellAddress} address - address of the cell in which formula is located\r\n   */\n  formulaWithContext(address) {\n    this.formulaAddress = address;\n    return this.formula();\n  }\n  buildCellRange(firstAddress, secondAddress, leadingWhitespace) {\n    if (firstAddress.sheet === undefined && secondAddress.sheet !== undefined) {\n      return this.parsingError(ParsingErrorType.ParserError, 'Malformed range expression');\n    }\n    const {\n      firstEnd,\n      secondEnd,\n      sheetRefType\n    } = FormulaParser.fixSheetIdsForRangeEnds(firstAddress, secondAddress);\n    return buildCellRangeAst(firstEnd, secondEnd, sheetRefType, leadingWhitespace);\n  }\n  static fixSheetIdsForRangeEnds(firstEnd, secondEnd) {\n    const sheetRefType = FormulaParser.rangeSheetReferenceType(firstEnd.sheet, secondEnd.sheet);\n    const secondEndFixed = firstEnd.sheet !== undefined && secondEnd.sheet === undefined ? secondEnd.withSheet(firstEnd.sheet) : secondEnd;\n    return {\n      firstEnd,\n      secondEnd: secondEndFixed,\n      sheetRefType\n    };\n  }\n  /**\r\n   * Returns {@link CellReferenceAst} or {@link CellRangeAst} based on OFFSET function arguments\r\n   *\r\n   * @param {Ast[]} args - OFFSET function arguments\r\n   */\n  handleOffsetHeuristic(args) {\n    const cellArg = args[0];\n    if (cellArg.type !== AstNodeType.CELL_REFERENCE) {\n      return this.parsingError(ParsingErrorType.StaticOffsetError, 'First argument to OFFSET is not a reference');\n    }\n    const rowsArg = args[1];\n    let rowShift;\n    if (rowsArg.type === AstNodeType.NUMBER && Number.isInteger(rowsArg.value)) {\n      rowShift = rowsArg.value;\n    } else if (rowsArg.type === AstNodeType.PLUS_UNARY_OP && rowsArg.value.type === AstNodeType.NUMBER && Number.isInteger(rowsArg.value.value)) {\n      rowShift = rowsArg.value.value;\n    } else if (rowsArg.type === AstNodeType.MINUS_UNARY_OP && rowsArg.value.type === AstNodeType.NUMBER && Number.isInteger(rowsArg.value.value)) {\n      rowShift = -rowsArg.value.value;\n    } else {\n      return this.parsingError(ParsingErrorType.StaticOffsetError, 'Second argument to OFFSET is not a static number');\n    }\n    const columnsArg = args[2];\n    let colShift;\n    if (columnsArg.type === AstNodeType.NUMBER && Number.isInteger(columnsArg.value)) {\n      colShift = columnsArg.value;\n    } else if (columnsArg.type === AstNodeType.PLUS_UNARY_OP && columnsArg.value.type === AstNodeType.NUMBER && Number.isInteger(columnsArg.value.value)) {\n      colShift = columnsArg.value.value;\n    } else if (columnsArg.type === AstNodeType.MINUS_UNARY_OP && columnsArg.value.type === AstNodeType.NUMBER && Number.isInteger(columnsArg.value.value)) {\n      colShift = -columnsArg.value.value;\n    } else {\n      return this.parsingError(ParsingErrorType.StaticOffsetError, 'Third argument to OFFSET is not a static number');\n    }\n    const heightArg = args[3];\n    let height;\n    if (heightArg === undefined) {\n      height = 1;\n    } else if (heightArg.type === AstNodeType.NUMBER) {\n      height = heightArg.value;\n      if (height < 1) {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is too small number');\n      } else if (!Number.isInteger(height)) {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is not integer');\n      }\n    } else {\n      return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is not a static number');\n    }\n    const widthArg = args[4];\n    let width;\n    if (widthArg === undefined) {\n      width = 1;\n    } else if (widthArg.type === AstNodeType.NUMBER) {\n      width = widthArg.value;\n      if (width < 1) {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is too small number');\n      } else if (!Number.isInteger(width)) {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is not integer');\n      }\n    } else {\n      return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is not a static number');\n    }\n    const topLeftCorner = new CellAddress(cellArg.reference.col + colShift, cellArg.reference.row + rowShift, cellArg.reference.type);\n    let absoluteCol = topLeftCorner.col;\n    let absoluteRow = topLeftCorner.row;\n    if (cellArg.reference.type === CellReferenceType.CELL_REFERENCE_RELATIVE || cellArg.reference.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL) {\n      absoluteRow = absoluteRow + this.formulaAddress.row;\n    }\n    if (cellArg.reference.type === CellReferenceType.CELL_REFERENCE_RELATIVE || cellArg.reference.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      absoluteCol = absoluteCol + this.formulaAddress.col;\n    }\n    if (absoluteCol < 0 || absoluteRow < 0) {\n      return buildCellErrorAst(new CellError(ErrorType.REF, ErrorMessage.OutOfSheet));\n    }\n    if (width === 1 && height === 1) {\n      return buildCellReferenceAst(topLeftCorner);\n    } else {\n      const bottomRightCorner = new CellAddress(topLeftCorner.col + width - 1, topLeftCorner.row + height - 1, topLeftCorner.type);\n      return buildCellRangeAst(topLeftCorner, bottomRightCorner, RangeSheetReferenceType.RELATIVE);\n    }\n  }\n  parsingError(type, message) {\n    this.customParsingError = parsingError(type, message);\n    return buildParsingErrorAst();\n  }\n  static rangeSheetReferenceType(start, end) {\n    if (start === undefined) {\n      return RangeSheetReferenceType.RELATIVE;\n    } else if (end === undefined) {\n      return RangeSheetReferenceType.START_ABSOLUTE;\n    } else {\n      return RangeSheetReferenceType.BOTH_ABSOLUTE;\n    }\n  }\n}\nexport class FormulaLexer {\n  constructor(lexerConfig) {\n    this.lexerConfig = lexerConfig;\n    this.lexer = new Lexer(lexerConfig.allTokens, {\n      ensureOptimizations: true\n    });\n  }\n  /**\r\n   * Returns Lexer tokens from formula string\r\n   *\r\n   * @param {string} text - string representation of a formula\r\n   */\n  tokenizeFormula(text) {\n    const lexingResult = this.lexer.tokenize(text);\n    let tokens = lexingResult.tokens;\n    tokens = this.trimTrailingWhitespaces(tokens);\n    tokens = this.skipWhitespacesInsideRanges(tokens);\n    tokens = this.skipWhitespacesBeforeArgSeparators(tokens);\n    lexingResult.tokens = tokens;\n    return lexingResult;\n  }\n  skipWhitespacesInsideRanges(tokens) {\n    return FormulaLexer.filterTokensByNeighbors(tokens, (previous, current, next) => {\n      return (tokenMatcher(previous, CellReference) || tokenMatcher(previous, RangeSeparator)) && tokenMatcher(current, this.lexerConfig.WhiteSpace) && (tokenMatcher(next, CellReference) || tokenMatcher(next, RangeSeparator));\n    });\n  }\n  skipWhitespacesBeforeArgSeparators(tokens) {\n    return FormulaLexer.filterTokensByNeighbors(tokens, (previous, current, next) => {\n      return !tokenMatcher(previous, this.lexerConfig.ArgSeparator) && tokenMatcher(current, this.lexerConfig.WhiteSpace) && tokenMatcher(next, this.lexerConfig.ArgSeparator);\n    });\n  }\n  static filterTokensByNeighbors(tokens, shouldBeSkipped) {\n    if (tokens.length < 3) {\n      return tokens;\n    }\n    let i = 0;\n    const filteredTokens = [tokens[i++]];\n    while (i < tokens.length - 1) {\n      if (!shouldBeSkipped(tokens[i - 1], tokens[i], tokens[i + 1])) {\n        filteredTokens.push(tokens[i]);\n      }\n      ++i;\n    }\n    filteredTokens.push(tokens[i]);\n    return filteredTokens;\n  }\n  trimTrailingWhitespaces(tokens) {\n    if (tokens.length > 0 && tokenMatcher(tokens[tokens.length - 1], this.lexerConfig.WhiteSpace)) {\n      tokens.pop();\n    }\n    return tokens;\n  }\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,qBAAqB,EAAEC,SAAS,EAAEC,KAAK,EAAEC,YAAY,QAAQ,YAAY;AAClF,SAASC,SAAS,EAAEC,SAAS,EAAEC,iBAAiB,QAAQ,aAAa;AACrE,SAASC,YAAY,QAAQ,sBAAsB;AACnD,SAASC,qBAAqB,EAAEC,uBAAuB,EAAEC,oBAAoB,QAAQ,uCAAuC;AAC5H,SAASC,WAAW,EAAEC,aAAa,EAAEC,iBAAiB,EAAEC,iBAAiB,EAAEC,qBAAqB,EAAEC,mBAAmB,EAAEC,qBAAqB,EAAEC,aAAa,EAAEC,gBAAgB,EAAEC,gBAAgB,EAAEC,yBAAyB,EAAEC,qBAAqB,EAAEC,4BAA4B,EAAEC,kBAAkB,EAAEC,yBAAyB,EAAEC,eAAe,EAAEC,oBAAoB,EAAEC,uBAAuB,EAAEC,kBAAkB,EAAEC,cAAc,EAAEC,mBAAmB,EAAEC,oBAAoB,EAAEC,iBAAiB,EAAEC,cAAc,EAAEC,mBAAmB,EAAEC,eAAe,EAAEC,iBAAiB,EAAEC,gBAAgB,EAAEC,cAAc,EAAEC,eAAe,EAAEC,YAAY,EAAEC,gBAAgB,EAAEC,uBAAuB,QAAQ,WAAW;AACxqB,SAASC,WAAW,EAAEC,iBAAiB,QAAQ,mBAAmB;AAClE,SAASC,UAAU,EAAEC,WAAW,EAAEC,WAAW,EAAEC,SAAS,EAAEC,aAAa,EAAEC,WAAW,EAAEC,aAAa,EAAEC,KAAK,EAAEC,QAAQ,EAAEC,YAAY,EAAEC,aAAa,EAAEC,oBAAoB,EAAEC,UAAU,EAAEC,iBAAiB,EAAEC,MAAM,EAAEC,OAAO,EAAEC,gBAAgB,EAAEC,eAAe,EAAEC,UAAU,EAAEC,SAAS,EAAEC,MAAM,EAAEC,OAAO,EAAEC,aAAa,EAAEC,cAAc,EAAEC,QAAQ,EAAEC,MAAM,EAAEC,aAAa,EAAEC,OAAO,QAAQ,mBAAmB;AACtY;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,aAAa,SAAS1E,qBAAqB,CAAC;EACvD2E,WAAWA,CAACC,WAAW,EAAEC,YAAY,EAAE;IACrC,KAAK,CAACD,WAAW,CAACE,SAAS,EAAE;MAC3BC,SAAS,EAAE,KAAK;MAChBC,YAAY,EAAE;IAChB,CAAC,CAAC;IACF,IAAI,CAACC,wBAAwB,GAAG,IAAI,CAACC,IAAI,CAAC,0BAA0B,EAAE,MAAM;MAC1E,OAAO,IAAI,CAACC,EAAE,CAAC,CAAC;QACdC,GAAG,EAAEA,CAAA,KAAM,IAAI,CAACC,OAAO,CAAC,IAAI,CAACC,iBAAiB;MAChD,CAAC,EAAE;QACDF,GAAG,EAAEnF,SAAS,CAACkB,gBAAgB,CAAC,CAAC;MACnC,CAAC,CAAC,CAAC;IACL,CAAC,CAAC;IACF;AACJ;AACA;IACI,IAAI,CAACoE,mBAAmB,GAAG,IAAI,CAACL,IAAI,CAAC,qBAAqB,EAAE,MAAM;MAChE,IAAIM,EAAE;MACN,MAAMC,kBAAkB,GAAG,IAAI,CAACC,OAAO,CAACtB,aAAa,CAAC;MACtD,MAAMuB,aAAa,GAAGF,kBAAkB,CAACG,KAAK,CAACC,WAAW,CAAC,CAAC,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MACzE,MAAMC,sBAAsB,GAAG,CAACP,EAAE,GAAG,IAAI,CAACZ,WAAW,CAACoB,eAAe,CAACL,aAAa,CAAC,MAAM,IAAI,IAAIH,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAGG,aAAa;MACpI,MAAMM,IAAI,GAAG,EAAE;MACf,IAAIC,QAAQ,GAAG,IAAI,CAACb,OAAO,CAAC,IAAI,CAACJ,wBAAwB,CAAC;MAC1D,IAAI,CAACkB,IAAI,CAAC,MAAM;QACd,IAAIX,EAAE;QACN,MAAMY,SAAS,GAAG,IAAI,CAACV,OAAO,CAAC,IAAI,CAACd,WAAW,CAACyB,YAAY,CAAC;QAC7D,IAAIH,QAAQ,CAACI,IAAI,KAAK3F,WAAW,CAAC4F,KAAK,EAAE;UACvCL,QAAQ,CAACM,iBAAiB,GAAG,CAAChB,EAAE,GAAGY,SAAS,CAACI,iBAAiB,MAAM,IAAI,IAAIhB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACI,KAAK;QAC/G;QACAK,IAAI,CAACQ,IAAI,CAACP,QAAQ,CAAC;QACnBA,QAAQ,GAAG,IAAI,CAACQ,QAAQ,CAAC,IAAI,CAACzB,wBAAwB,CAAC;MACzD,CAAC,CAAC;MACFgB,IAAI,CAACQ,IAAI,CAACP,QAAQ,CAAC;MACnB,IAAID,IAAI,CAACU,MAAM,KAAK,CAAC,IAAIV,IAAI,CAAC,CAAC,CAAC,CAACK,IAAI,KAAK3F,WAAW,CAAC4F,KAAK,EAAE;QAC3DN,IAAI,CAACU,MAAM,GAAG,CAAC;MACjB;MACA,MAAMC,WAAW,GAAG,IAAI,CAAClB,OAAO,CAACnB,MAAM,CAAC;MACxC,OAAOlC,iBAAiB,CAAC0D,sBAAsB,EAAEE,IAAI,EAAER,kBAAkB,CAACe,iBAAiB,EAAEI,WAAW,CAACJ,iBAAiB,CAAC;IAC7H,CAAC,CAAC;IACF,IAAI,CAACK,yBAAyB,GAAG,IAAI,CAAC3B,IAAI,CAAC,2BAA2B,EAAE,MAAM;MAC5E,MAAM4B,IAAI,GAAG,IAAI,CAACpB,OAAO,CAAC3B,eAAe,CAAC;MAC1C,OAAOnC,uBAAuB,CAACkF,IAAI,CAAClB,KAAK,EAAEkB,IAAI,CAACN,iBAAiB,CAAC;IACpE,CAAC,CAAC;IACF;AACJ;AACA;IACI,IAAI,CAACO,yBAAyB,GAAG,IAAI,CAAC7B,IAAI,CAAC,2BAA2B,EAAE,MAAM;MAC5E,MAAMe,IAAI,GAAG,EAAE;MACf,IAAI,CAACP,OAAO,CAAC,IAAI,CAACd,WAAW,CAACoC,mBAAmB,CAAC;MAClD,IAAI,CAACtB,OAAO,CAAC9B,MAAM,CAAC;MACpB,IAAI,CAACqD,QAAQ,CAAC;QACZC,GAAG,EAAE,IAAI,CAACtC,WAAW,CAACyB,YAAY;QAClCc,GAAG,EAAEA,CAAA,KAAM;UACTlB,IAAI,CAACQ,IAAI,CAAC,IAAI,CAACpB,OAAO,CAAC,IAAI,CAACC,iBAAiB,CAAC,CAAC;QACjD;MACF,CAAC,CAAC;MACF,IAAI,CAACI,OAAO,CAACnB,MAAM,CAAC;MACpB,OAAO,IAAI,CAAC6C,qBAAqB,CAACnB,IAAI,CAAC;IACzC,CAAC,CAAC;IACF;AACJ;AACA;IACI,IAAI,CAACoB,qBAAqB,GAAG,IAAI,CAACnC,IAAI,CAAC,uBAAuB,EAAE,MAAM;MACpE,MAAMoC,KAAK,GAAG,IAAI,CAAC5B,OAAO,CAACvC,WAAW,CAAC;MACvC,MAAM,CAACoE,UAAU,EAAEC,QAAQ,CAAC,GAAGF,KAAK,CAAC1B,KAAK,CAAC6B,KAAK,CAAC,GAAG,CAAC;MACrD,MAAMC,YAAY,GAAG,IAAI,CAACC,MAAM,CAAC,MAAMlH,uBAAuB,CAAC,IAAI,CAACoE,YAAY,EAAE0C,UAAU,EAAE,IAAI,CAACK,cAAc,CAAC,CAAC;MACnH,MAAMC,aAAa,GAAG,IAAI,CAACF,MAAM,CAAC,MAAMlH,uBAAuB,CAAC,IAAI,CAACoE,YAAY,EAAE2C,QAAQ,EAAE,IAAI,CAACI,cAAc,CAAC,CAAC;MAClH,IAAIF,YAAY,KAAKI,SAAS,IAAID,aAAa,KAAKC,SAAS,EAAE;QAC7D,OAAOjH,iBAAiB,CAAC,IAAIT,SAAS,CAACC,SAAS,CAAC0H,GAAG,CAAC,CAAC;MACxD;MACA,IAAIL,YAAY,CAACM,sBAAsB,CAAC,IAAI,CAACpD,WAAW,CAACqD,UAAU,CAAC,IAAIJ,aAAa,CAACG,sBAAsB,CAAC,IAAI,CAACpD,WAAW,CAACqD,UAAU,CAAC,EAAE;QACzI,OAAO5G,yBAAyB,CAACiG,KAAK,CAAC1B,KAAK,EAAE,IAAIxF,SAAS,CAACC,SAAS,CAAC6H,IAAI,CAAC,EAAEZ,KAAK,CAACd,iBAAiB,CAAC;MACvG;MACA,IAAIkB,YAAY,CAACS,KAAK,KAAKL,SAAS,IAAID,aAAa,CAACM,KAAK,KAAKL,SAAS,EAAE;QACzE,OAAO,IAAI,CAACrF,YAAY,CAACC,gBAAgB,CAAC0F,WAAW,EAAE,4BAA4B,CAAC;MACtF;MACA,MAAM;QACJC,QAAQ;QACRC,SAAS;QACTC;MACF,CAAC,GAAG7D,aAAa,CAAC8D,uBAAuB,CAACd,YAAY,EAAEG,aAAa,CAAC;MACtE,OAAO7G,mBAAmB,CAACqH,QAAQ,EAAEC,SAAS,EAAEC,YAAY,EAAEjB,KAAK,CAACd,iBAAiB,CAAC;IACxF,CAAC,CAAC;IACF;AACJ;AACA;IACI,IAAI,CAACiC,kBAAkB,GAAG,IAAI,CAACvD,IAAI,CAAC,oBAAoB,EAAE,MAAM;MAC9D,MAAMoC,KAAK,GAAG,IAAI,CAAC5B,OAAO,CAACpB,QAAQ,CAAC;MACpC,MAAM,CAACiD,UAAU,EAAEC,QAAQ,CAAC,GAAGF,KAAK,CAAC1B,KAAK,CAAC6B,KAAK,CAAC,GAAG,CAAC;MACrD,MAAMC,YAAY,GAAG,IAAI,CAACC,MAAM,CAAC,MAAMjH,oBAAoB,CAAC,IAAI,CAACmE,YAAY,EAAE0C,UAAU,EAAE,IAAI,CAACK,cAAc,CAAC,CAAC;MAChH,MAAMC,aAAa,GAAG,IAAI,CAACF,MAAM,CAAC,MAAMjH,oBAAoB,CAAC,IAAI,CAACmE,YAAY,EAAE2C,QAAQ,EAAE,IAAI,CAACI,cAAc,CAAC,CAAC;MAC/G,IAAIF,YAAY,KAAKI,SAAS,IAAID,aAAa,KAAKC,SAAS,EAAE;QAC7D,OAAOjH,iBAAiB,CAAC,IAAIT,SAAS,CAACC,SAAS,CAAC0H,GAAG,CAAC,CAAC;MACxD;MACA,IAAIL,YAAY,CAACM,sBAAsB,CAAC,IAAI,CAACpD,WAAW,CAAC8D,OAAO,CAAC,IAAIb,aAAa,CAACG,sBAAsB,CAAC,IAAI,CAACpD,WAAW,CAAC8D,OAAO,CAAC,EAAE;QACnI,OAAOrH,yBAAyB,CAACiG,KAAK,CAAC1B,KAAK,EAAE,IAAIxF,SAAS,CAACC,SAAS,CAAC6H,IAAI,CAAC,EAAEZ,KAAK,CAACd,iBAAiB,CAAC;MACvG;MACA,IAAIkB,YAAY,CAACS,KAAK,KAAKL,SAAS,IAAID,aAAa,CAACM,KAAK,KAAKL,SAAS,EAAE;QACzE,OAAO,IAAI,CAACrF,YAAY,CAACC,gBAAgB,CAAC0F,WAAW,EAAE,4BAA4B,CAAC;MACtF;MACA,MAAM;QACJC,QAAQ;QACRC,SAAS;QACTC;MACF,CAAC,GAAG7D,aAAa,CAAC8D,uBAAuB,CAACd,YAAY,EAAEG,aAAa,CAAC;MACtE,OAAOvF,gBAAgB,CAAC+F,QAAQ,EAAEC,SAAS,EAAEC,YAAY,EAAEjB,KAAK,CAACd,iBAAiB,CAAC;IACrF,CAAC,CAAC;IACF;AACJ;AACA;IACI,IAAI,CAACmC,aAAa,GAAG,IAAI,CAACzD,IAAI,CAAC,eAAe,EAAE,MAAM;MACpD,MAAM0D,IAAI,GAAG,IAAI,CAAClD,OAAO,CAACxC,aAAa,CAAC;MACxC,MAAM2F,OAAO,GAAG,IAAI,CAAClB,MAAM,CAAC,MAAM;QAChC,OAAOnH,qBAAqB,CAAC,IAAI,CAACqE,YAAY,EAAE+D,IAAI,CAAChD,KAAK,EAAE,IAAI,CAACgC,cAAc,CAAC;MAClF,CAAC,CAAC;MACF,IAAIiB,OAAO,KAAKf,SAAS,EAAE;QACzB,OAAOzG,yBAAyB,CAACuH,IAAI,CAAChD,KAAK,EAAE,IAAIxF,SAAS,CAACC,SAAS,CAAC0H,GAAG,CAAC,EAAEa,IAAI,CAACpC,iBAAiB,CAAC;MACpG,CAAC,MAAM,IAAIqC,OAAO,CAACb,sBAAsB,CAAC,IAAI,CAACpD,WAAW,CAACqD,UAAU,EAAE,IAAI,CAACrD,WAAW,CAAC8D,OAAO,CAAC,EAAE;QAChG,OAAOrH,yBAAyB,CAACuH,IAAI,CAAChD,KAAK,EAAE,IAAIxF,SAAS,CAACC,SAAS,CAAC6H,IAAI,CAAC,EAAEU,IAAI,CAACpC,iBAAiB,CAAC;MACrG,CAAC,MAAM;QACL,OAAOzF,qBAAqB,CAAC8H,OAAO,EAAED,IAAI,CAACpC,iBAAiB,CAAC;MAC/D;IACF,CAAC,CAAC;IACF;AACJ;AACA;IACI,IAAI,CAACsC,iBAAiB,GAAG,IAAI,CAAC5D,IAAI,CAAC,mBAAmB,EAAE6D,KAAK,IAAI;MAC/D,IAAIvD,EAAE;MACN,MAAMwD,GAAG,GAAG,IAAI,CAACtD,OAAO,CAACxC,aAAa,CAAC;MACvC,MAAM+F,YAAY,GAAG,IAAI,CAACtB,MAAM,CAAC,MAAM;QACrC,OAAOnH,qBAAqB,CAAC,IAAI,CAACqE,YAAY,EAAEkE,KAAK,CAACnD,KAAK,EAAE,IAAI,CAACgC,cAAc,CAAC;MACnF,CAAC,CAAC;MACF,MAAMsB,UAAU,GAAG,IAAI,CAACvB,MAAM,CAAC,MAAM;QACnC,OAAOnH,qBAAqB,CAAC,IAAI,CAACqE,YAAY,EAAEmE,GAAG,CAACpD,KAAK,EAAE,IAAI,CAACgC,cAAc,CAAC;MACjF,CAAC,CAAC;MACF,IAAIqB,YAAY,KAAKnB,SAAS,IAAIoB,UAAU,KAAKpB,SAAS,EAAE;QAC1D,OAAO,IAAI,CAACH,MAAM,CAAC,MAAM;UACvB,OAAOtG,yBAAyB,CAAC,GAAG0H,KAAK,CAACnD,KAAK,IAAIoD,GAAG,CAACpD,KAAK,EAAE,EAAE,IAAIxF,SAAS,CAACC,SAAS,CAAC0H,GAAG,CAAC,EAAEgB,KAAK,CAACvC,iBAAiB,CAAC;QACxH,CAAC,CAAC;MACJ,CAAC,MAAM,IAAIyC,YAAY,CAACjB,sBAAsB,CAAC,IAAI,CAACpD,WAAW,CAACqD,UAAU,EAAE,IAAI,CAACrD,WAAW,CAAC8D,OAAO,CAAC,IAAIQ,UAAU,CAAClB,sBAAsB,CAAC,IAAI,CAACpD,WAAW,CAACqD,UAAU,EAAE,IAAI,CAACrD,WAAW,CAAC8D,OAAO,CAAC,EAAE;QACjM,OAAO,IAAI,CAACf,MAAM,CAAC,MAAM;UACvB,OAAOtG,yBAAyB,CAAC,GAAG0H,KAAK,CAACnD,KAAK,IAAIoD,GAAG,CAACpD,KAAK,EAAE,EAAE,IAAIxF,SAAS,CAACC,SAAS,CAAC6H,IAAI,CAAC,EAAEa,KAAK,CAACvC,iBAAiB,CAAC;QACzH,CAAC,CAAC;MACJ;MACA,OAAO,IAAI,CAAC2C,cAAc,CAACF,YAAY,EAAEC,UAAU,EAAE,CAAC1D,EAAE,GAAGuD,KAAK,CAACvC,iBAAiB,MAAM,IAAI,IAAIhB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACI,KAAK,CAAC;IACpI,CAAC,CAAC;IACF;AACJ;AACA;AACA;AACA;IACI,IAAI,CAACwD,oBAAoB,GAAG,IAAI,CAAClE,IAAI,CAAC,sBAAsB,EAAE6D,KAAK,IAAI;MACrE,OAAO,IAAI,CAAC5D,EAAE,CAAC,CAAC;QACdC,GAAG,EAAEA,CAAA,KAAM;UACT,OAAO,IAAI,CAACC,OAAO,CAAC,IAAI,CAACyD,iBAAiB,EAAE;YAC1CO,IAAI,EAAE,CAACN,KAAK;UACd,CAAC,CAAC;QACJ;MACF,CAAC,EAAE;QACD3D,GAAG,EAAEA,CAAA,KAAM;UACT,IAAII,EAAE;UACN,MAAM8D,eAAe,GAAG,IAAI,CAACjE,OAAO,CAAC,IAAI,CAAC0B,yBAAyB,CAAC;UACpE,MAAMkC,YAAY,GAAG,IAAI,CAACtB,MAAM,CAAC,MAAM;YACrC,OAAOnH,qBAAqB,CAAC,IAAI,CAACqE,YAAY,EAAEkE,KAAK,CAACnD,KAAK,EAAE,IAAI,CAACgC,cAAc,CAAC;UACnF,CAAC,CAAC;UACF,IAAIqB,YAAY,KAAKnB,SAAS,EAAE;YAC9B,OAAOjH,iBAAiB,CAAC,IAAIT,SAAS,CAACC,SAAS,CAAC0H,GAAG,CAAC,CAAC;UACxD;UACA,IAAIuB,eAAe,CAAChD,IAAI,KAAK3F,WAAW,CAAC4I,cAAc,EAAE;YACvD,OAAO,IAAI,CAACJ,cAAc,CAACF,YAAY,EAAEK,eAAe,CAACE,SAAS,EAAE,CAAChE,EAAE,GAAGuD,KAAK,CAACvC,iBAAiB,MAAM,IAAI,IAAIhB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACI,KAAK,CAAC;UACnJ,CAAC,MAAM;YACL,OAAO,IAAI,CAACnD,YAAY,CAACC,gBAAgB,CAAC+G,qBAAqB,EAAE,+BAA+B,CAAC;UACnG;QACF;MACF,CAAC,CAAC,CAAC;IACL,CAAC,CAAC;IACF;AACJ;AACA;IACI,IAAI,CAACC,mBAAmB,GAAG,IAAI,CAACxE,IAAI,CAAC,qBAAqB,EAAE,MAAM;MAChE,MAAM6D,KAAK,GAAG,IAAI,CAACrD,OAAO,CAACxC,aAAa,CAAC;MACzC,IAAI,CAACyG,QAAQ,CAACtF,cAAc,CAAC;MAC7B,OAAO,IAAI,CAACgB,OAAO,CAAC,IAAI,CAAC+D,oBAAoB,EAAE;QAC7CC,IAAI,EAAE,CAACN,KAAK;MACd,CAAC,CAAC;IACJ,CAAC,CAAC;IACF;AACJ;AACA;IACI,IAAI,CAACa,gCAAgC,GAAG,IAAI,CAAC1E,IAAI,CAAC,kCAAkC,EAAE6D,KAAK,IAAI;MAC7F,MAAMC,GAAG,GAAG,IAAI,CAACtD,OAAO,CAACxC,aAAa,CAAC;MACvC,MAAMgG,UAAU,GAAG,IAAI,CAACvB,MAAM,CAAC,MAAM;QACnC,OAAOnH,qBAAqB,CAAC,IAAI,CAACqE,YAAY,EAAEmE,GAAG,CAACpD,KAAK,EAAE,IAAI,CAACgC,cAAc,CAAC;MACjF,CAAC,CAAC;MACF,IAAIsB,UAAU,KAAKpB,SAAS,EAAE;QAC5B,OAAO,IAAI,CAACH,MAAM,CAAC,MAAM;UACvB,OAAO9G,iBAAiB,CAAC,IAAIT,SAAS,CAACC,SAAS,CAAC0H,GAAG,CAAC,CAAC;QACxD,CAAC,CAAC;MACJ;MACA,OAAO,IAAI,CAACoB,cAAc,CAACJ,KAAK,CAACS,SAAS,EAAEN,UAAU,EAAEH,KAAK,CAACvC,iBAAiB,CAAC;IAClF,CAAC,CAAC;IACF;AACJ;AACA;AACA;AACA;IACI,IAAI,CAACqD,mCAAmC,GAAG,IAAI,CAAC3E,IAAI,CAAC,qCAAqC,EAAE6D,KAAK,IAAI;MACnG,OAAO,IAAI,CAAC5D,EAAE,CAAC,CAAC;QACdC,GAAG,EAAEA,CAAA,KAAM;UACT,OAAO,IAAI,CAACC,OAAO,CAAC,IAAI,CAACuE,gCAAgC,EAAE;YACzDP,IAAI,EAAE,CAACN,KAAK;UACd,CAAC,CAAC;QACJ;MACF,CAAC,EAAE;QACD3D,GAAG,EAAEA,CAAA,KAAM;UACT,MAAMkE,eAAe,GAAG,IAAI,CAACjE,OAAO,CAAC,IAAI,CAAC0B,yBAAyB,CAAC;UACpE,IAAIuC,eAAe,CAAChD,IAAI,KAAK3F,WAAW,CAAC4I,cAAc,EAAE;YACvD,OAAO,IAAI,CAACJ,cAAc,CAACJ,KAAK,CAACS,SAAS,EAAEF,eAAe,CAACE,SAAS,EAAET,KAAK,CAACvC,iBAAiB,CAAC;UACjG,CAAC,MAAM;YACL,OAAO,IAAI,CAAC/D,YAAY,CAACC,gBAAgB,CAAC+G,qBAAqB,EAAE,+BAA+B,CAAC;UACnG;QACF;MACF,CAAC,CAAC,CAAC;IACL,CAAC,CAAC;IACF;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACK,gBAAgB,GAAG,IAAI,CAAC5E,IAAI,CAAC,kBAAkB,EAAE,MAAM;MAC1D,MAAMoE,eAAe,GAAG,IAAI,CAACjE,OAAO,CAAC,IAAI,CAAC0B,yBAAyB,CAAC;MACpE,IAAIiC,GAAG;MACP,IAAI,CAACe,MAAM,CAAC,MAAM;QAChB,IAAI,CAACrE,OAAO,CAACrB,cAAc,CAAC;QAC5B,IAAIiF,eAAe,CAAChD,IAAI,KAAK3F,WAAW,CAACqJ,UAAU,EAAE;UACnDhB,GAAG,GAAG,IAAI,CAACvG,YAAY,CAACC,gBAAgB,CAAC+G,qBAAqB,EAAE,+BAA+B,CAAC;QAClG,CAAC,MAAM;UACLT,GAAG,GAAG,IAAI,CAAC3D,OAAO,CAAC,IAAI,CAACwE,mCAAmC,EAAE;YAC3DR,IAAI,EAAE,CAACC,eAAe;UACxB,CAAC,CAAC;QACJ;MACF,CAAC,CAAC;MACF,IAAIN,GAAG,KAAKlB,SAAS,EAAE;QACrB,OAAOkB,GAAG;MACZ;MACA,OAAOM,eAAe;IACxB,CAAC,CAAC;IACF,IAAI,CAACW,qBAAqB,GAAG,IAAI,CAAC/E,IAAI,CAAC,uBAAuB,EAAE,MAAM;MACpE,MAAMgF,GAAG,GAAG,CAAC,EAAE,CAAC;MAChBA,GAAG,CAACA,GAAG,CAACvD,MAAM,GAAG,CAAC,CAAC,CAACF,IAAI,CAAC,IAAI,CAACpB,OAAO,CAAC,IAAI,CAACC,iBAAiB,CAAC,CAAC;MAC9D,IAAI,CAACa,IAAI,CAAC,MAAM;QACd,IAAI,CAAChB,EAAE,CAAC,CAAC;UACPC,GAAG,EAAEA,CAAA,KAAM;YACT,IAAI,CAACM,OAAO,CAAC,IAAI,CAACd,WAAW,CAACuF,iBAAiB,CAAC;YAChDD,GAAG,CAACA,GAAG,CAACvD,MAAM,GAAG,CAAC,CAAC,CAACF,IAAI,CAAC,IAAI,CAACC,QAAQ,CAAC,IAAI,CAACpB,iBAAiB,CAAC,CAAC;UACjE;QACF,CAAC,EAAE;UACDF,GAAG,EAAEA,CAAA,KAAM;YACT,IAAI,CAACM,OAAO,CAAC,IAAI,CAACd,WAAW,CAACwF,iBAAiB,CAAC;YAChDF,GAAG,CAACzD,IAAI,CAAC,EAAE,CAAC;YACZyD,GAAG,CAACA,GAAG,CAACvD,MAAM,GAAG,CAAC,CAAC,CAACF,IAAI,CAAC,IAAI,CAAC4D,QAAQ,CAAC,IAAI,CAAC/E,iBAAiB,CAAC,CAAC;UACjE;QACF,CAAC,CAAC,CAAC;MACL,CAAC,CAAC;MACF,OAAO1E,aAAa,CAACsJ,GAAG,CAAC;IAC3B,CAAC,CAAC;IACF;AACJ;AACA;IACI,IAAI,CAACI,qBAAqB,GAAG,IAAI,CAACpF,IAAI,CAAC,uBAAuB,EAAE,MAAM;MACpE,MAAMqF,WAAW,GAAG,IAAI,CAAC7E,OAAO,CAAC9B,MAAM,CAAC;MACxC,MAAM4G,UAAU,GAAG,IAAI,CAACnF,OAAO,CAAC,IAAI,CAACC,iBAAiB,CAAC;MACvD,MAAMsB,WAAW,GAAG,IAAI,CAAClB,OAAO,CAACnB,MAAM,CAAC;MACxC,OAAOxC,mBAAmB,CAACyI,UAAU,EAAED,WAAW,CAAC/D,iBAAiB,EAAEI,WAAW,CAACJ,iBAAiB,CAAC;IACtG,CAAC,CAAC;IACF,IAAI,CAACiE,eAAe,GAAG,IAAI,CAACvF,IAAI,CAAC,iBAAiB,EAAE,MAAM;MACxD,OAAO,IAAI,CAACC,EAAE,CAAC,CAAC;QACdC,GAAG,EAAEA,CAAA,KAAM;UACT,MAAMsF,MAAM,GAAG,IAAI,CAAChF,OAAO,CAAC3C,WAAW,CAAC;UACxC,MAAMmH,GAAG,GAAG,IAAI,CAAC7E,OAAO,CAAC,IAAI,CAAC4E,qBAAqB,CAAC;UACpD,MAAMU,MAAM,GAAG,IAAI,CAACjF,OAAO,CAAC1C,WAAW,CAAC;UACxC,OAAOpC,aAAa,CAACsJ,GAAG,CAACjE,IAAI,EAAEyE,MAAM,CAAClE,iBAAiB,EAAEmE,MAAM,CAACnE,iBAAiB,CAAC;QACpF;MACF,CAAC,EAAE;QACDpB,GAAG,EAAEA,CAAA,KAAM,IAAI,CAACC,OAAO,CAAC,IAAI,CAACiF,qBAAqB;MACpD,CAAC,CAAC,CAAC;IACL,CAAC,CAAC;IACF,IAAI,CAACM,qBAAqB,GAAGC,KAAK,IAAI;MACpC,MAAMC,UAAU,GAAGD,KAAK,CAACE,OAAO,CAAC,IAAI,CAACnG,WAAW,CAACoG,gBAAgB,EAAE,GAAG,CAAC;MACxE,OAAOC,MAAM,CAACH,UAAU,CAAC;IAC3B,CAAC;IACD;AACJ;AACA;IACI,IAAI,CAACI,wBAAwB,GAAG,IAAI,CAAChG,IAAI,CAAC,0BAA0B,EAAE,MAAM;MAC1E,IAAIM,EAAE;MACN,OAAO,IAAI,CAACL,EAAE,CAAC,CAACK,EAAE,GAAG,IAAI,CAAC2F,cAAc,MAAM,IAAI,IAAI3F,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,IAAI,CAAC2F,cAAc,GAAG,CAAC;QAChG/F,GAAG,EAAEA,CAAA,KAAM,IAAI,CAACC,OAAO,CAAC,IAAI,CAACoF,eAAe;MAC9C,CAAC,EAAE;QACDrF,GAAG,EAAEA,CAAA,KAAM,IAAI,CAACC,OAAO,CAAC,IAAI,CAACqE,mBAAmB;MAClD,CAAC,EAAE;QACDtE,GAAG,EAAEA,CAAA,KAAM,IAAI,CAACC,OAAO,CAAC,IAAI,CAACgC,qBAAqB;MACpD,CAAC,EAAE;QACDjC,GAAG,EAAEA,CAAA,KAAM,IAAI,CAACC,OAAO,CAAC,IAAI,CAACoD,kBAAkB;MACjD,CAAC,EAAE;QACDrD,GAAG,EAAEA,CAAA,KAAM,IAAI,CAACC,OAAO,CAAC,IAAI,CAACyE,gBAAgB;MAC/C,CAAC,EAAE;QACD1E,GAAG,EAAEA,CAAA,KAAM,IAAI,CAACC,OAAO,CAAC,IAAI,CAACsD,aAAa;MAC5C,CAAC,EAAE;QACDvD,GAAG,EAAEA,CAAA,KAAM,IAAI,CAACC,OAAO,CAAC,IAAI,CAACE,mBAAmB;MAClD,CAAC,EAAE;QACDH,GAAG,EAAEA,CAAA,KAAM,IAAI,CAACC,OAAO,CAAC,IAAI,CAACwB,yBAAyB;MACxD,CAAC,EAAE;QACDzB,GAAG,EAAEA,CAAA,KAAM;UACT,MAAMgG,MAAM,GAAG,IAAI,CAAC1F,OAAO,CAAC,IAAI,CAACd,WAAW,CAACyG,aAAa,CAAC;UAC3D,OAAOvJ,cAAc,CAAC,IAAI,CAAC8I,qBAAqB,CAACQ,MAAM,CAACxF,KAAK,CAAC,EAAEwF,MAAM,CAAC5E,iBAAiB,CAAC;QAC3F;MACF,CAAC,EAAE;QACDpB,GAAG,EAAEA,CAAA,KAAM;UACT,MAAMkG,GAAG,GAAG,IAAI,CAAC5F,OAAO,CAAClB,aAAa,CAAC;UACvC,OAAOjC,cAAc,CAAC+I,GAAG,CAAC;QAC5B;MACF,CAAC,EAAE;QACDlG,GAAG,EAAEA,CAAA,KAAM;UACT,MAAMmG,KAAK,GAAG,IAAI,CAAC7F,OAAO,CAACnC,YAAY,CAAC;UACxC,MAAMiI,SAAS,GAAGD,KAAK,CAAC3F,KAAK,CAACC,WAAW,CAAC,CAAC;UAC3C,MAAM4F,SAAS,GAAG,IAAI,CAAC7G,WAAW,CAAC8G,YAAY,CAACF,SAAS,CAAC;UAC1D,IAAIC,SAAS,EAAE;YACb,OAAO5K,iBAAiB,CAAC,IAAIT,SAAS,CAACqL,SAAS,CAAC,EAAEF,KAAK,CAAC/E,iBAAiB,CAAC;UAC7E,CAAC,MAAM;YACL,OAAO,IAAI,CAAC/D,YAAY,CAACC,gBAAgB,CAAC0F,WAAW,EAAE,uBAAuB,CAAC;UACjF;QACF;MACF,CAAC,CAAC,CAAC;IACL,CAAC,CAAC;IACF,IAAI,CAACuD,4BAA4B,GAAG,IAAI,CAACzG,IAAI,CAAC,8BAA8B,EAAE,MAAM;MAClF,MAAMgG,wBAAwB,GAAG,IAAI,CAAC7F,OAAO,CAAC,IAAI,CAAC6F,wBAAwB,CAAC;MAC5E,MAAMU,UAAU,GAAG,IAAI,CAAC7B,MAAM,CAAC,MAAM;QACnC,OAAO,IAAI,CAACrE,OAAO,CAACzB,SAAS,CAAC;MAChC,CAAC,CAAC;MACF,IAAI2H,UAAU,EAAE;QACd,OAAO3J,iBAAiB,CAACiJ,wBAAwB,EAAEU,UAAU,CAACpF,iBAAiB,CAAC;MAClF;MACA,OAAO0E,wBAAwB;IACjC,CAAC,CAAC;IACF;AACJ;AACA;IACI,IAAI,CAACW,gBAAgB,GAAG,IAAI,CAAC3G,IAAI,CAAC,kBAAkB,EAAE,MAAM;MAC1D,OAAO,IAAI,CAACC,EAAE,CAAC,CAAC;QACdC,GAAG,EAAEA,CAAA,KAAM;UACT,MAAM0G,EAAE,GAAG,IAAI,CAACpG,OAAO,CAAC5C,UAAU,CAAC;UACnC,MAAMiJ,KAAK,GAAG,IAAI,CAAC1G,OAAO,CAAC,IAAI,CAACwG,gBAAgB,CAAC;UACjD,IAAI1L,YAAY,CAAC2L,EAAE,EAAE5H,MAAM,CAAC,EAAE;YAC5B,OAAO/B,mBAAmB,CAAC4J,KAAK,EAAED,EAAE,CAACtF,iBAAiB,CAAC;UACzD,CAAC,MAAM,IAAIrG,YAAY,CAAC2L,EAAE,EAAEjI,OAAO,CAAC,EAAE;YACpC,OAAOlC,oBAAoB,CAACoK,KAAK,EAAED,EAAE,CAACtF,iBAAiB,CAAC;UAC1D,CAAC,MAAM;YACL,IAAI,CAACwF,kBAAkB,GAAGvJ,YAAY,CAACC,gBAAgB,CAAC0F,WAAW,EAAE,uBAAuB,CAAC;YAC7F,OAAO,IAAI,CAAC4D,kBAAkB;UAChC;QACF;MACF,CAAC,EAAE;QACD5G,GAAG,EAAEA,CAAA,KAAM,IAAI,CAACsB,QAAQ,CAAC,IAAI,CAACiF,4BAA4B;MAC5D,CAAC,CAAC,CAAC;IACL,CAAC,CAAC;IACF;AACJ;AACA;IACI,IAAI,CAACM,eAAe,GAAG,IAAI,CAAC/G,IAAI,CAAC,iBAAiB,EAAE,MAAM;MACxD,IAAIgH,GAAG,GAAG,IAAI,CAAC7G,OAAO,CAAC,IAAI,CAACwG,gBAAgB,CAAC;MAC7C,IAAI,CAAC1F,IAAI,CAAC,MAAM;QACd,MAAM2F,EAAE,GAAG,IAAI,CAACpG,OAAO,CAACvB,OAAO,CAAC;QAChC,MAAMgI,GAAG,GAAG,IAAI,CAACzF,QAAQ,CAAC,IAAI,CAACmF,gBAAgB,CAAC;QAChD,IAAI1L,YAAY,CAAC2L,EAAE,EAAE3H,OAAO,CAAC,EAAE;UAC7B+H,GAAG,GAAG9J,eAAe,CAAC8J,GAAG,EAAEC,GAAG,EAAEL,EAAE,CAACtF,iBAAiB,CAAC;QACvD,CAAC,MAAM;UACL,IAAI,CAACmB,MAAM,CAAC,MAAM;YAChB,MAAMyE,KAAK,CAAC,wBAAwB,CAAC;UACvC,CAAC,CAAC;QACJ;MACF,CAAC,CAAC;MACF,OAAOF,GAAG;IACZ,CAAC,CAAC;IACF;AACJ;AACA;IACI,IAAI,CAACG,wBAAwB,GAAG,IAAI,CAACnH,IAAI,CAAC,0BAA0B,EAAE,MAAM;MAC1E,IAAIgH,GAAG,GAAG,IAAI,CAAC7G,OAAO,CAAC,IAAI,CAAC4G,eAAe,CAAC;MAC5C,IAAI,CAAC9F,IAAI,CAAC,MAAM;QACd,MAAM2F,EAAE,GAAG,IAAI,CAACpG,OAAO,CAAC5B,gBAAgB,CAAC;QACzC,MAAMqI,GAAG,GAAG,IAAI,CAACzF,QAAQ,CAAC,IAAI,CAACuF,eAAe,CAAC;QAC/C,IAAI9L,YAAY,CAAC2L,EAAE,EAAErH,OAAO,CAAC,EAAE;UAC7ByH,GAAG,GAAG1J,eAAe,CAAC0J,GAAG,EAAEC,GAAG,EAAEL,EAAE,CAACtF,iBAAiB,CAAC;QACvD,CAAC,MAAM,IAAIrG,YAAY,CAAC2L,EAAE,EAAEzI,KAAK,CAAC,EAAE;UAClC6I,GAAG,GAAGhL,aAAa,CAACgL,GAAG,EAAEC,GAAG,EAAEL,EAAE,CAACtF,iBAAiB,CAAC;QACrD,CAAC,MAAM;UACL,IAAI,CAACmB,MAAM,CAAC,MAAM;YAChB,MAAMyE,KAAK,CAAC,wBAAwB,CAAC;UACvC,CAAC,CAAC;QACJ;MACF,CAAC,CAAC;MACF,OAAOF,GAAG;IACZ,CAAC,CAAC;IACF;AACJ;AACA;IACI,IAAI,CAACI,kBAAkB,GAAG,IAAI,CAACpH,IAAI,CAAC,oBAAoB,EAAE,MAAM;MAC9D,IAAIgH,GAAG,GAAG,IAAI,CAAC7G,OAAO,CAAC,IAAI,CAACgH,wBAAwB,CAAC;MACrD,IAAI,CAAClG,IAAI,CAAC,MAAM;QACd,MAAM2F,EAAE,GAAG,IAAI,CAACpG,OAAO,CAAC5C,UAAU,CAAC;QACnC,MAAMqJ,GAAG,GAAG,IAAI,CAACzF,QAAQ,CAAC,IAAI,CAAC2F,wBAAwB,CAAC;QACxD,IAAIlM,YAAY,CAAC2L,EAAE,EAAE5H,MAAM,CAAC,EAAE;UAC5BgI,GAAG,GAAGhK,cAAc,CAACgK,GAAG,EAAEC,GAAG,EAAEL,EAAE,CAACtF,iBAAiB,CAAC;QACtD,CAAC,MAAM,IAAIrG,YAAY,CAAC2L,EAAE,EAAEjI,OAAO,CAAC,EAAE;UACpCqI,GAAG,GAAGxK,eAAe,CAACwK,GAAG,EAAEC,GAAG,EAAEL,EAAE,CAACtF,iBAAiB,CAAC;QACvD,CAAC,MAAM;UACL,IAAI,CAACmB,MAAM,CAAC,MAAM;YAChB,MAAMyE,KAAK,CAAC,wBAAwB,CAAC;UACvC,CAAC,CAAC;QACJ;MACF,CAAC,CAAC;MACF,OAAOF,GAAG;IACZ,CAAC,CAAC;IACF;AACJ;AACA;IACI,IAAI,CAACK,qBAAqB,GAAG,IAAI,CAACrH,IAAI,CAAC,uBAAuB,EAAE,MAAM;MACpE,IAAIgH,GAAG,GAAG,IAAI,CAAC7G,OAAO,CAAC,IAAI,CAACiH,kBAAkB,CAAC;MAC/C,IAAI,CAACnG,IAAI,CAAC,MAAM;QACd,MAAM2F,EAAE,GAAG,IAAI,CAACpG,OAAO,CAACtC,aAAa,CAAC;QACtC,MAAM+I,GAAG,GAAG,IAAI,CAACzF,QAAQ,CAAC,IAAI,CAAC4F,kBAAkB,CAAC;QAClDJ,GAAG,GAAGjL,qBAAqB,CAACiL,GAAG,EAAEC,GAAG,EAAEL,EAAE,CAACtF,iBAAiB,CAAC;MAC7D,CAAC,CAAC;MACF,OAAO0F,GAAG;IACZ,CAAC,CAAC;IACF;AACJ;AACA;IACI,IAAI,CAAC5G,iBAAiB,GAAG,IAAI,CAACJ,IAAI,CAAC,mBAAmB,EAAE,MAAM;MAC5D,IAAIgH,GAAG,GAAG,IAAI,CAAC7G,OAAO,CAAC,IAAI,CAACkH,qBAAqB,CAAC;MAClD,IAAI,CAACpG,IAAI,CAAC,MAAM;QACd,MAAM2F,EAAE,GAAG,IAAI,CAACpG,OAAO,CAACzC,SAAS,CAAC;QAClC,MAAMkJ,GAAG,GAAG,IAAI,CAACzF,QAAQ,CAAC,IAAI,CAAC6F,qBAAqB,CAAC;QACrD,IAAIpM,YAAY,CAAC2L,EAAE,EAAExI,QAAQ,CAAC,EAAE;UAC9B4I,GAAG,GAAG9K,gBAAgB,CAAC8K,GAAG,EAAEC,GAAG,EAAEL,EAAE,CAACtF,iBAAiB,CAAC;QACxD,CAAC,MAAM,IAAIrG,YAAY,CAAC2L,EAAE,EAAE9H,UAAU,CAAC,EAAE;UACvCkI,GAAG,GAAGrK,kBAAkB,CAACqK,GAAG,EAAEC,GAAG,EAAEL,EAAE,CAACtF,iBAAiB,CAAC;QAC1D,CAAC,MAAM,IAAIrG,YAAY,CAAC2L,EAAE,EAAEtI,aAAa,CAAC,EAAE;UAC1C0I,GAAG,GAAG5K,qBAAqB,CAAC4K,GAAG,EAAEC,GAAG,EAAEL,EAAE,CAACtF,iBAAiB,CAAC;QAC7D,CAAC,MAAM,IAAIrG,YAAY,CAAC2L,EAAE,EAAEpI,UAAU,CAAC,EAAE;UACvCwI,GAAG,GAAG1K,kBAAkB,CAAC0K,GAAG,EAAEC,GAAG,EAAEL,EAAE,CAACtF,iBAAiB,CAAC;QAC1D,CAAC,MAAM,IAAIrG,YAAY,CAAC2L,EAAE,EAAErI,oBAAoB,CAAC,EAAE;UACjDyI,GAAG,GAAG3K,4BAA4B,CAAC2K,GAAG,EAAEC,GAAG,EAAEL,EAAE,CAACtF,iBAAiB,CAAC;QACpE,CAAC,MAAM,IAAIrG,YAAY,CAAC2L,EAAE,EAAEnI,iBAAiB,CAAC,EAAE;UAC9CuI,GAAG,GAAGzK,yBAAyB,CAACyK,GAAG,EAAEC,GAAG,EAAEL,EAAE,CAACtF,iBAAiB,CAAC;QACjE,CAAC,MAAM;UACL,IAAI,CAACmB,MAAM,CAAC,MAAM;YAChB,MAAMyE,KAAK,CAAC,wBAAwB,CAAC;UACvC,CAAC,CAAC;QACJ;MACF,CAAC,CAAC;MACF,OAAOF,GAAG;IACZ,CAAC,CAAC;IACF;AACJ;AACA;IACI,IAAI,CAACM,OAAO,GAAG,IAAI,CAACtH,IAAI,CAAC,SAAS,EAAE,MAAM;MACxC,IAAI,CAACQ,OAAO,CAACpC,QAAQ,CAAC;MACtB,OAAO,IAAI,CAAC+B,OAAO,CAAC,IAAI,CAACC,iBAAiB,CAAC;IAC7C,CAAC,CAAC;IACF,IAAI,CAACV,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACC,YAAY,GAAGA,YAAY;IAChC,IAAI,CAAC+C,cAAc,GAAGtH,iBAAiB,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAChD,IAAI,CAACmM,mBAAmB,CAAC,CAAC;EAC5B;EACA;AACF;AACA;AACA;AACA;AACA;EACEC,eAAeA,CAACC,MAAM,EAAE/E,cAAc,EAAE;IACtC,IAAI,CAACiD,KAAK,GAAG8B,MAAM;IACnB,IAAIC,GAAG,GAAG,IAAI,CAACC,kBAAkB,CAACjF,cAAc,CAAC;IACjD,IAAIkF,MAAM,GAAG,EAAE;IACf,IAAI,IAAI,CAACd,kBAAkB,EAAE;MAC3Bc,MAAM,CAACrG,IAAI,CAAC,IAAI,CAACuF,kBAAkB,CAAC;IACtC;IACAc,MAAM,GAAGA,MAAM,CAACC,MAAM,CAAC,IAAI,CAACD,MAAM,CAACE,GAAG,CAACC,CAAC,KAAK;MAC3C3G,IAAI,EAAE5D,gBAAgB,CAAC0F,WAAW;MAClC8E,OAAO,EAAED,CAAC,CAACC;IACb,CAAC,CAAC,CAAC,CAAC;IACJ,IAAIJ,MAAM,CAACnG,MAAM,GAAG,CAAC,EAAE;MACrBiG,GAAG,GAAG5K,oBAAoB,CAAC,CAAC;IAC9B;IACA,OAAO;MACL4K,GAAG;MACHE;IACF,CAAC;EACH;EACAK,KAAKA,CAAA,EAAG;IACN,KAAK,CAACA,KAAK,CAAC,CAAC;IACb,IAAI,CAACnB,kBAAkB,GAAGlE,SAAS;EACrC;EACA;AACF;AACA;AACA;AACA;EACE+E,kBAAkBA,CAAChE,OAAO,EAAE;IAC1B,IAAI,CAACjB,cAAc,GAAGiB,OAAO;IAC7B,OAAO,IAAI,CAAC2D,OAAO,CAAC,CAAC;EACvB;EACArD,cAAcA,CAACzB,YAAY,EAAEG,aAAa,EAAErB,iBAAiB,EAAE;IAC7D,IAAIkB,YAAY,CAACS,KAAK,KAAKL,SAAS,IAAID,aAAa,CAACM,KAAK,KAAKL,SAAS,EAAE;MACzE,OAAO,IAAI,CAACrF,YAAY,CAACC,gBAAgB,CAAC0F,WAAW,EAAE,4BAA4B,CAAC;IACtF;IACA,MAAM;MACJC,QAAQ;MACRC,SAAS;MACTC;IACF,CAAC,GAAG7D,aAAa,CAAC8D,uBAAuB,CAACd,YAAY,EAAEG,aAAa,CAAC;IACtE,OAAO/G,iBAAiB,CAACuH,QAAQ,EAAEC,SAAS,EAAEC,YAAY,EAAE/B,iBAAiB,CAAC;EAChF;EACA,OAAOgC,uBAAuBA,CAACH,QAAQ,EAAEC,SAAS,EAAE;IAClD,MAAMC,YAAY,GAAG7D,aAAa,CAAC0I,uBAAuB,CAAC/E,QAAQ,CAACF,KAAK,EAAEG,SAAS,CAACH,KAAK,CAAC;IAC3F,MAAMkF,cAAc,GAAGhF,QAAQ,CAACF,KAAK,KAAKL,SAAS,IAAIQ,SAAS,CAACH,KAAK,KAAKL,SAAS,GAAGQ,SAAS,CAACgF,SAAS,CAACjF,QAAQ,CAACF,KAAK,CAAC,GAAGG,SAAS;IACtI,OAAO;MACLD,QAAQ;MACRC,SAAS,EAAE+E,cAAc;MACzB9E;IACF,CAAC;EACH;EACA;AACF;AACA;AACA;AACA;EACEnB,qBAAqBA,CAACnB,IAAI,EAAE;IAC1B,MAAMsH,OAAO,GAAGtH,IAAI,CAAC,CAAC,CAAC;IACvB,IAAIsH,OAAO,CAACjH,IAAI,KAAK3F,WAAW,CAAC4I,cAAc,EAAE;MAC/C,OAAO,IAAI,CAAC9G,YAAY,CAACC,gBAAgB,CAAC8K,iBAAiB,EAAE,6CAA6C,CAAC;IAC7G;IACA,MAAMC,OAAO,GAAGxH,IAAI,CAAC,CAAC,CAAC;IACvB,IAAIyH,QAAQ;IACZ,IAAID,OAAO,CAACnH,IAAI,KAAK3F,WAAW,CAACgN,MAAM,IAAI1C,MAAM,CAAC2C,SAAS,CAACH,OAAO,CAAC1B,KAAK,CAAC,EAAE;MAC1E2B,QAAQ,GAAGD,OAAO,CAAC1B,KAAK;IAC1B,CAAC,MAAM,IAAI0B,OAAO,CAACnH,IAAI,KAAK3F,WAAW,CAACkN,aAAa,IAAIJ,OAAO,CAAC1B,KAAK,CAACzF,IAAI,KAAK3F,WAAW,CAACgN,MAAM,IAAI1C,MAAM,CAAC2C,SAAS,CAACH,OAAO,CAAC1B,KAAK,CAACA,KAAK,CAAC,EAAE;MAC3I2B,QAAQ,GAAGD,OAAO,CAAC1B,KAAK,CAACA,KAAK;IAChC,CAAC,MAAM,IAAI0B,OAAO,CAACnH,IAAI,KAAK3F,WAAW,CAACmN,cAAc,IAAIL,OAAO,CAAC1B,KAAK,CAACzF,IAAI,KAAK3F,WAAW,CAACgN,MAAM,IAAI1C,MAAM,CAAC2C,SAAS,CAACH,OAAO,CAAC1B,KAAK,CAACA,KAAK,CAAC,EAAE;MAC5I2B,QAAQ,GAAG,CAACD,OAAO,CAAC1B,KAAK,CAACA,KAAK;IACjC,CAAC,MAAM;MACL,OAAO,IAAI,CAACtJ,YAAY,CAACC,gBAAgB,CAAC8K,iBAAiB,EAAE,kDAAkD,CAAC;IAClH;IACA,MAAMO,UAAU,GAAG9H,IAAI,CAAC,CAAC,CAAC;IAC1B,IAAI+H,QAAQ;IACZ,IAAID,UAAU,CAACzH,IAAI,KAAK3F,WAAW,CAACgN,MAAM,IAAI1C,MAAM,CAAC2C,SAAS,CAACG,UAAU,CAAChC,KAAK,CAAC,EAAE;MAChFiC,QAAQ,GAAGD,UAAU,CAAChC,KAAK;IAC7B,CAAC,MAAM,IAAIgC,UAAU,CAACzH,IAAI,KAAK3F,WAAW,CAACkN,aAAa,IAAIE,UAAU,CAAChC,KAAK,CAACzF,IAAI,KAAK3F,WAAW,CAACgN,MAAM,IAAI1C,MAAM,CAAC2C,SAAS,CAACG,UAAU,CAAChC,KAAK,CAACA,KAAK,CAAC,EAAE;MACpJiC,QAAQ,GAAGD,UAAU,CAAChC,KAAK,CAACA,KAAK;IACnC,CAAC,MAAM,IAAIgC,UAAU,CAACzH,IAAI,KAAK3F,WAAW,CAACmN,cAAc,IAAIC,UAAU,CAAChC,KAAK,CAACzF,IAAI,KAAK3F,WAAW,CAACgN,MAAM,IAAI1C,MAAM,CAAC2C,SAAS,CAACG,UAAU,CAAChC,KAAK,CAACA,KAAK,CAAC,EAAE;MACrJiC,QAAQ,GAAG,CAACD,UAAU,CAAChC,KAAK,CAACA,KAAK;IACpC,CAAC,MAAM;MACL,OAAO,IAAI,CAACtJ,YAAY,CAACC,gBAAgB,CAAC8K,iBAAiB,EAAE,iDAAiD,CAAC;IACjH;IACA,MAAMS,SAAS,GAAGhI,IAAI,CAAC,CAAC,CAAC;IACzB,IAAIiI,MAAM;IACV,IAAID,SAAS,KAAKnG,SAAS,EAAE;MAC3BoG,MAAM,GAAG,CAAC;IACZ,CAAC,MAAM,IAAID,SAAS,CAAC3H,IAAI,KAAK3F,WAAW,CAACgN,MAAM,EAAE;MAChDO,MAAM,GAAGD,SAAS,CAAClC,KAAK;MACxB,IAAImC,MAAM,GAAG,CAAC,EAAE;QACd,OAAO,IAAI,CAACzL,YAAY,CAACC,gBAAgB,CAAC8K,iBAAiB,EAAE,+CAA+C,CAAC;MAC/G,CAAC,MAAM,IAAI,CAACvC,MAAM,CAAC2C,SAAS,CAACM,MAAM,CAAC,EAAE;QACpC,OAAO,IAAI,CAACzL,YAAY,CAACC,gBAAgB,CAAC8K,iBAAiB,EAAE,0CAA0C,CAAC;MAC1G;IACF,CAAC,MAAM;MACL,OAAO,IAAI,CAAC/K,YAAY,CAACC,gBAAgB,CAAC8K,iBAAiB,EAAE,kDAAkD,CAAC;IAClH;IACA,MAAMW,QAAQ,GAAGlI,IAAI,CAAC,CAAC,CAAC;IACxB,IAAImI,KAAK;IACT,IAAID,QAAQ,KAAKrG,SAAS,EAAE;MAC1BsG,KAAK,GAAG,CAAC;IACX,CAAC,MAAM,IAAID,QAAQ,CAAC7H,IAAI,KAAK3F,WAAW,CAACgN,MAAM,EAAE;MAC/CS,KAAK,GAAGD,QAAQ,CAACpC,KAAK;MACtB,IAAIqC,KAAK,GAAG,CAAC,EAAE;QACb,OAAO,IAAI,CAAC3L,YAAY,CAACC,gBAAgB,CAAC8K,iBAAiB,EAAE,8CAA8C,CAAC;MAC9G,CAAC,MAAM,IAAI,CAACvC,MAAM,CAAC2C,SAAS,CAACQ,KAAK,CAAC,EAAE;QACnC,OAAO,IAAI,CAAC3L,YAAY,CAACC,gBAAgB,CAAC8K,iBAAiB,EAAE,yCAAyC,CAAC;MACzG;IACF,CAAC,MAAM;MACL,OAAO,IAAI,CAAC/K,YAAY,CAACC,gBAAgB,CAAC8K,iBAAiB,EAAE,iDAAiD,CAAC;IACjH;IACA,MAAMa,aAAa,GAAG,IAAIzL,WAAW,CAAC2K,OAAO,CAAC/D,SAAS,CAAC8E,GAAG,GAAGN,QAAQ,EAAET,OAAO,CAAC/D,SAAS,CAAC+E,GAAG,GAAGb,QAAQ,EAAEH,OAAO,CAAC/D,SAAS,CAAClD,IAAI,CAAC;IACjI,IAAIkI,WAAW,GAAGH,aAAa,CAACC,GAAG;IACnC,IAAIG,WAAW,GAAGJ,aAAa,CAACE,GAAG;IACnC,IAAIhB,OAAO,CAAC/D,SAAS,CAAClD,IAAI,KAAKzD,iBAAiB,CAAC6L,uBAAuB,IAAInB,OAAO,CAAC/D,SAAS,CAAClD,IAAI,KAAKzD,iBAAiB,CAAC8L,2BAA2B,EAAE;MACpJF,WAAW,GAAGA,WAAW,GAAG,IAAI,CAAC7G,cAAc,CAAC2G,GAAG;IACrD;IACA,IAAIhB,OAAO,CAAC/D,SAAS,CAAClD,IAAI,KAAKzD,iBAAiB,CAAC6L,uBAAuB,IAAInB,OAAO,CAAC/D,SAAS,CAAClD,IAAI,KAAKzD,iBAAiB,CAAC+L,2BAA2B,EAAE;MACpJ;MACAJ,WAAW,GAAGA,WAAW,GAAG,IAAI,CAAC5G,cAAc,CAAC0G,GAAG;IACrD;IACA,IAAIE,WAAW,GAAG,CAAC,IAAIC,WAAW,GAAG,CAAC,EAAE;MACtC,OAAO5N,iBAAiB,CAAC,IAAIT,SAAS,CAACC,SAAS,CAAC0H,GAAG,EAAExH,YAAY,CAACsO,UAAU,CAAC,CAAC;IACjF;IACA,IAAIT,KAAK,KAAK,CAAC,IAAIF,MAAM,KAAK,CAAC,EAAE;MAC/B,OAAOnN,qBAAqB,CAACsN,aAAa,CAAC;IAC7C,CAAC,MAAM;MACL,MAAMS,iBAAiB,GAAG,IAAIlM,WAAW,CAACyL,aAAa,CAACC,GAAG,GAAGF,KAAK,GAAG,CAAC,EAAEC,aAAa,CAACE,GAAG,GAAGL,MAAM,GAAG,CAAC,EAAEG,aAAa,CAAC/H,IAAI,CAAC;MAC5H,OAAOxF,iBAAiB,CAACuN,aAAa,EAAES,iBAAiB,EAAEnM,uBAAuB,CAACoM,QAAQ,CAAC;IAC9F;EACF;EACAtM,YAAYA,CAAC6D,IAAI,EAAE4G,OAAO,EAAE;IAC1B,IAAI,CAAClB,kBAAkB,GAAGvJ,YAAY,CAAC6D,IAAI,EAAE4G,OAAO,CAAC;IACrD,OAAOlL,oBAAoB,CAAC,CAAC;EAC/B;EACA,OAAOoL,uBAAuBA,CAACrE,KAAK,EAAEC,GAAG,EAAE;IACzC,IAAID,KAAK,KAAKjB,SAAS,EAAE;MACvB,OAAOnF,uBAAuB,CAACoM,QAAQ;IACzC,CAAC,MAAM,IAAI/F,GAAG,KAAKlB,SAAS,EAAE;MAC5B,OAAOnF,uBAAuB,CAACqM,cAAc;IAC/C,CAAC,MAAM;MACL,OAAOrM,uBAAuB,CAACsM,aAAa;IAC9C;EACF;AACF;AACA,OAAO,MAAMC,YAAY,CAAC;EACxBvK,WAAWA,CAACC,WAAW,EAAE;IACvB,IAAI,CAACA,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACuK,KAAK,GAAG,IAAIjP,KAAK,CAAC0E,WAAW,CAACE,SAAS,EAAE;MAC5CsK,mBAAmB,EAAE;IACvB,CAAC,CAAC;EACJ;EACA;AACF;AACA;AACA;AACA;EACEC,eAAeA,CAACC,IAAI,EAAE;IACpB,MAAMC,YAAY,GAAG,IAAI,CAACJ,KAAK,CAACK,QAAQ,CAACF,IAAI,CAAC;IAC9C,IAAI3C,MAAM,GAAG4C,YAAY,CAAC5C,MAAM;IAChCA,MAAM,GAAG,IAAI,CAAC8C,uBAAuB,CAAC9C,MAAM,CAAC;IAC7CA,MAAM,GAAG,IAAI,CAAC+C,2BAA2B,CAAC/C,MAAM,CAAC;IACjDA,MAAM,GAAG,IAAI,CAACgD,kCAAkC,CAAChD,MAAM,CAAC;IACxD4C,YAAY,CAAC5C,MAAM,GAAGA,MAAM;IAC5B,OAAO4C,YAAY;EACrB;EACAG,2BAA2BA,CAAC/C,MAAM,EAAE;IAClC,OAAOuC,YAAY,CAACU,uBAAuB,CAACjD,MAAM,EAAE,CAACkD,QAAQ,EAAEC,OAAO,EAAEC,IAAI,KAAK;MAC/E,OAAO,CAAC5P,YAAY,CAAC0P,QAAQ,EAAE3M,aAAa,CAAC,IAAI/C,YAAY,CAAC0P,QAAQ,EAAExL,cAAc,CAAC,KAAKlE,YAAY,CAAC2P,OAAO,EAAE,IAAI,CAAClL,WAAW,CAACoL,UAAU,CAAC,KAAK7P,YAAY,CAAC4P,IAAI,EAAE7M,aAAa,CAAC,IAAI/C,YAAY,CAAC4P,IAAI,EAAE1L,cAAc,CAAC,CAAC;IAC7N,CAAC,CAAC;EACJ;EACAsL,kCAAkCA,CAAChD,MAAM,EAAE;IACzC,OAAOuC,YAAY,CAACU,uBAAuB,CAACjD,MAAM,EAAE,CAACkD,QAAQ,EAAEC,OAAO,EAAEC,IAAI,KAAK;MAC/E,OAAO,CAAC5P,YAAY,CAAC0P,QAAQ,EAAE,IAAI,CAACjL,WAAW,CAACyB,YAAY,CAAC,IAAIlG,YAAY,CAAC2P,OAAO,EAAE,IAAI,CAAClL,WAAW,CAACoL,UAAU,CAAC,IAAI7P,YAAY,CAAC4P,IAAI,EAAE,IAAI,CAACnL,WAAW,CAACyB,YAAY,CAAC;IAC1K,CAAC,CAAC;EACJ;EACA,OAAOuJ,uBAAuBA,CAACjD,MAAM,EAAEsD,eAAe,EAAE;IACtD,IAAItD,MAAM,CAAChG,MAAM,GAAG,CAAC,EAAE;MACrB,OAAOgG,MAAM;IACf;IACA,IAAIuD,CAAC,GAAG,CAAC;IACT,MAAMC,cAAc,GAAG,CAACxD,MAAM,CAACuD,CAAC,EAAE,CAAC,CAAC;IACpC,OAAOA,CAAC,GAAGvD,MAAM,CAAChG,MAAM,GAAG,CAAC,EAAE;MAC5B,IAAI,CAACsJ,eAAe,CAACtD,MAAM,CAACuD,CAAC,GAAG,CAAC,CAAC,EAAEvD,MAAM,CAACuD,CAAC,CAAC,EAAEvD,MAAM,CAACuD,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE;QAC7DC,cAAc,CAAC1J,IAAI,CAACkG,MAAM,CAACuD,CAAC,CAAC,CAAC;MAChC;MACA,EAAEA,CAAC;IACL;IACAC,cAAc,CAAC1J,IAAI,CAACkG,MAAM,CAACuD,CAAC,CAAC,CAAC;IAC9B,OAAOC,cAAc;EACvB;EACAV,uBAAuBA,CAAC9C,MAAM,EAAE;IAC9B,IAAIA,MAAM,CAAChG,MAAM,GAAG,CAAC,IAAIxG,YAAY,CAACwM,MAAM,CAACA,MAAM,CAAChG,MAAM,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC/B,WAAW,CAACoL,UAAU,CAAC,EAAE;MAC7FrD,MAAM,CAACyD,GAAG,CAAC,CAAC;IACd;IACA,OAAOzD,MAAM;EACf;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}