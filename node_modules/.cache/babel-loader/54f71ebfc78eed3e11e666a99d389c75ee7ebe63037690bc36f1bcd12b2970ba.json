{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from \"../AbsoluteCellRange.mjs\";\nimport { ArraySize } from \"../ArraySize.mjs\";\nimport { ArrayValue, ErroredArray, NotComputedArray } from \"../ArrayValue.mjs\";\nimport { CellError, equalSimpleCellAddress, ErrorType } from \"../Cell.mjs\";\nimport { ErrorMessage } from \"../error-message.mjs\";\nimport { EmptyValue, getRawValue } from \"../interpreter/InterpreterValue.mjs\";\nimport { ColumnsSpan, RowsSpan } from \"../Span.mjs\";\nexport class FormulaVertex {\n  constructor(formula, cellAddress, version) {\n    this.formula = formula;\n    this.cellAddress = cellAddress;\n    this.version = version;\n  }\n  get width() {\n    return 1;\n  }\n  get height() {\n    return 1;\n  }\n  static fromAst(formula, address, size, version) {\n    if (size.isScalar()) {\n      return new FormulaCellVertex(formula, address, version);\n    } else {\n      return new ArrayVertex(formula, address, size, version);\n    }\n  }\n  /**\r\n   * Returns formula stored in this vertex\r\n   */\n  getFormula(updatingService) {\n    this.ensureRecentData(updatingService);\n    return this.formula;\n  }\n  ensureRecentData(updatingService) {\n    if (this.version != updatingService.version()) {\n      const [newAst, newAddress, newVersion] = updatingService.applyTransformations(this.formula, this.cellAddress, this.version);\n      this.formula = newAst;\n      this.cellAddress = newAddress;\n      this.version = newVersion;\n    }\n  }\n  /**\r\n   * Returns address of the cell associated with vertex\r\n   */\n  getAddress(updatingService) {\n    this.ensureRecentData(updatingService);\n    return this.cellAddress;\n  }\n}\nexport class ArrayVertex extends FormulaVertex {\n  constructor(formula, cellAddress, size, version = 0) {\n    super(formula, cellAddress, version);\n    if (size.isRef) {\n      this.array = new ErroredArray(new CellError(ErrorType.REF, ErrorMessage.NoSpaceForArrayResult), ArraySize.error());\n    } else {\n      this.array = new NotComputedArray(size);\n    }\n  }\n  get width() {\n    return this.array.width();\n  }\n  get height() {\n    return this.array.height();\n  }\n  get sheet() {\n    return this.cellAddress.sheet;\n  }\n  get leftCorner() {\n    return this.cellAddress;\n  }\n  setCellValue(value) {\n    if (value instanceof CellError) {\n      this.setErrorValue(value);\n      return value;\n    }\n    const array = ArrayValue.fromInterpreterValue(value);\n    array.resize(this.array.size);\n    this.array = array;\n    return value;\n  }\n  getCellValue() {\n    if (this.array instanceof NotComputedArray) {\n      throw Error('Array not computed yet.');\n    }\n    return this.array.simpleRangeValue();\n  }\n  valueOrUndef() {\n    if (this.array instanceof NotComputedArray) {\n      return undefined;\n    }\n    return this.array.simpleRangeValue();\n  }\n  getArrayCellValue(address) {\n    const col = address.col - this.cellAddress.col;\n    const row = address.row - this.cellAddress.row;\n    try {\n      return this.array.get(col, row);\n    } catch (e) {\n      return new CellError(ErrorType.REF);\n    }\n  }\n  getArrayCellRawValue(address) {\n    const val = this.getArrayCellValue(address);\n    if (val instanceof CellError || val === EmptyValue) {\n      return undefined;\n    } else {\n      return getRawValue(val);\n    }\n  }\n  setArrayCellValue(address, value) {\n    const col = address.col - this.cellAddress.col;\n    const row = address.row - this.cellAddress.row;\n    if (this.array instanceof ArrayValue) {\n      this.array.set(col, row, value);\n    }\n  }\n  setNoSpace() {\n    this.array = new ErroredArray(new CellError(ErrorType.SPILL, ErrorMessage.NoSpaceForArrayResult), ArraySize.error());\n    return this.getCellValue();\n  }\n  getRange() {\n    return AbsoluteCellRange.spanFrom(this.cellAddress, this.width, this.height);\n  }\n  getRangeOrUndef() {\n    return AbsoluteCellRange.spanFromOrUndef(this.cellAddress, this.width, this.height);\n  }\n  setAddress(address) {\n    this.cellAddress = address;\n  }\n  setFormula(newFormula) {\n    this.formula = newFormula;\n  }\n  spansThroughSheetRows(sheet, startRow, endRow = startRow) {\n    return this.cellAddress.sheet === sheet && this.cellAddress.row <= endRow && startRow < this.cellAddress.row + this.height;\n  }\n  spansThroughSheetColumn(sheet, col, columnEnd = col) {\n    return this.cellAddress.sheet === sheet && this.cellAddress.col <= columnEnd && col < this.cellAddress.col + this.width;\n  }\n  isComputed() {\n    return !(this.array instanceof NotComputedArray);\n  }\n  columnsFromArray() {\n    return ColumnsSpan.fromNumberOfColumns(this.cellAddress.sheet, this.cellAddress.col, this.width);\n  }\n  rowsFromArray() {\n    return RowsSpan.fromNumberOfRows(this.cellAddress.sheet, this.cellAddress.row, this.height);\n  }\n  /**\r\n   * No-op as array vertices are transformed eagerly.\r\n   */\n  ensureRecentData(_updatingService) {}\n  isLeftCorner(address) {\n    return equalSimpleCellAddress(this.cellAddress, address);\n  }\n  setErrorValue(error) {\n    this.array = new ErroredArray(error, this.array.size);\n  }\n}\n/**\r\n * Represents vertex which keeps formula\r\n */\nexport class FormulaCellVertex extends FormulaVertex {\n  constructor(/** Formula in AST format */\n  formula, /** Address which this vertex represents */\n  address, version) {\n    super(formula, address, version);\n  }\n  valueOrUndef() {\n    return this.cachedCellValue;\n  }\n  /**\r\n   * Sets computed cell value stored in this vertex\r\n   */\n  setCellValue(cellValue) {\n    this.cachedCellValue = cellValue;\n    return this.cachedCellValue;\n  }\n  /**\r\n   * Returns cell value stored in vertex\r\n   */\n  getCellValue() {\n    if (this.cachedCellValue !== undefined) {\n      return this.cachedCellValue;\n    } else {\n      throw Error('Value of the formula cell is not computed.');\n    }\n  }\n  isComputed() {\n    return this.cachedCellValue !== undefined;\n  }\n}","map":{"version":3,"names":["AbsoluteCellRange","ArraySize","ArrayValue","ErroredArray","NotComputedArray","CellError","equalSimpleCellAddress","ErrorType","ErrorMessage","EmptyValue","getRawValue","ColumnsSpan","RowsSpan","FormulaVertex","constructor","formula","cellAddress","version","width","height","fromAst","address","size","isScalar","FormulaCellVertex","ArrayVertex","getFormula","updatingService","ensureRecentData","newAst","newAddress","newVersion","applyTransformations","getAddress","isRef","array","REF","NoSpaceForArrayResult","error","sheet","leftCorner","setCellValue","value","setErrorValue","fromInterpreterValue","resize","getCellValue","Error","simpleRangeValue","valueOrUndef","undefined","getArrayCellValue","col","row","get","e","getArrayCellRawValue","val","setArrayCellValue","set","setNoSpace","SPILL","getRange","spanFrom","getRangeOrUndef","spanFromOrUndef","setAddress","setFormula","newFormula","spansThroughSheetRows","startRow","endRow","spansThroughSheetColumn","columnEnd","isComputed","columnsFromArray","fromNumberOfColumns","rowsFromArray","fromNumberOfRows","_updatingService","isLeftCorner","cachedCellValue","cellValue"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/DependencyGraph/FormulaCellVertex.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from \"../AbsoluteCellRange.mjs\";\nimport { ArraySize } from \"../ArraySize.mjs\";\nimport { ArrayValue, ErroredArray, NotComputedArray } from \"../ArrayValue.mjs\";\nimport { CellError, equalSimpleCellAddress, ErrorType } from \"../Cell.mjs\";\nimport { ErrorMessage } from \"../error-message.mjs\";\nimport { EmptyValue, getRawValue } from \"../interpreter/InterpreterValue.mjs\";\nimport { ColumnsSpan, RowsSpan } from \"../Span.mjs\";\nexport class FormulaVertex {\n  constructor(formula, cellAddress, version) {\n    this.formula = formula;\n    this.cellAddress = cellAddress;\n    this.version = version;\n  }\n  get width() {\n    return 1;\n  }\n  get height() {\n    return 1;\n  }\n  static fromAst(formula, address, size, version) {\n    if (size.isScalar()) {\n      return new FormulaCellVertex(formula, address, version);\n    } else {\n      return new ArrayVertex(formula, address, size, version);\n    }\n  }\n  /**\r\n   * Returns formula stored in this vertex\r\n   */\n  getFormula(updatingService) {\n    this.ensureRecentData(updatingService);\n    return this.formula;\n  }\n  ensureRecentData(updatingService) {\n    if (this.version != updatingService.version()) {\n      const [newAst, newAddress, newVersion] = updatingService.applyTransformations(this.formula, this.cellAddress, this.version);\n      this.formula = newAst;\n      this.cellAddress = newAddress;\n      this.version = newVersion;\n    }\n  }\n  /**\r\n   * Returns address of the cell associated with vertex\r\n   */\n  getAddress(updatingService) {\n    this.ensureRecentData(updatingService);\n    return this.cellAddress;\n  }\n}\nexport class ArrayVertex extends FormulaVertex {\n  constructor(formula, cellAddress, size, version = 0) {\n    super(formula, cellAddress, version);\n    if (size.isRef) {\n      this.array = new ErroredArray(new CellError(ErrorType.REF, ErrorMessage.NoSpaceForArrayResult), ArraySize.error());\n    } else {\n      this.array = new NotComputedArray(size);\n    }\n  }\n  get width() {\n    return this.array.width();\n  }\n  get height() {\n    return this.array.height();\n  }\n  get sheet() {\n    return this.cellAddress.sheet;\n  }\n  get leftCorner() {\n    return this.cellAddress;\n  }\n  setCellValue(value) {\n    if (value instanceof CellError) {\n      this.setErrorValue(value);\n      return value;\n    }\n    const array = ArrayValue.fromInterpreterValue(value);\n    array.resize(this.array.size);\n    this.array = array;\n    return value;\n  }\n  getCellValue() {\n    if (this.array instanceof NotComputedArray) {\n      throw Error('Array not computed yet.');\n    }\n    return this.array.simpleRangeValue();\n  }\n  valueOrUndef() {\n    if (this.array instanceof NotComputedArray) {\n      return undefined;\n    }\n    return this.array.simpleRangeValue();\n  }\n  getArrayCellValue(address) {\n    const col = address.col - this.cellAddress.col;\n    const row = address.row - this.cellAddress.row;\n    try {\n      return this.array.get(col, row);\n    } catch (e) {\n      return new CellError(ErrorType.REF);\n    }\n  }\n  getArrayCellRawValue(address) {\n    const val = this.getArrayCellValue(address);\n    if (val instanceof CellError || val === EmptyValue) {\n      return undefined;\n    } else {\n      return getRawValue(val);\n    }\n  }\n  setArrayCellValue(address, value) {\n    const col = address.col - this.cellAddress.col;\n    const row = address.row - this.cellAddress.row;\n    if (this.array instanceof ArrayValue) {\n      this.array.set(col, row, value);\n    }\n  }\n  setNoSpace() {\n    this.array = new ErroredArray(new CellError(ErrorType.SPILL, ErrorMessage.NoSpaceForArrayResult), ArraySize.error());\n    return this.getCellValue();\n  }\n  getRange() {\n    return AbsoluteCellRange.spanFrom(this.cellAddress, this.width, this.height);\n  }\n  getRangeOrUndef() {\n    return AbsoluteCellRange.spanFromOrUndef(this.cellAddress, this.width, this.height);\n  }\n  setAddress(address) {\n    this.cellAddress = address;\n  }\n  setFormula(newFormula) {\n    this.formula = newFormula;\n  }\n  spansThroughSheetRows(sheet, startRow, endRow = startRow) {\n    return this.cellAddress.sheet === sheet && this.cellAddress.row <= endRow && startRow < this.cellAddress.row + this.height;\n  }\n  spansThroughSheetColumn(sheet, col, columnEnd = col) {\n    return this.cellAddress.sheet === sheet && this.cellAddress.col <= columnEnd && col < this.cellAddress.col + this.width;\n  }\n  isComputed() {\n    return !(this.array instanceof NotComputedArray);\n  }\n  columnsFromArray() {\n    return ColumnsSpan.fromNumberOfColumns(this.cellAddress.sheet, this.cellAddress.col, this.width);\n  }\n  rowsFromArray() {\n    return RowsSpan.fromNumberOfRows(this.cellAddress.sheet, this.cellAddress.row, this.height);\n  }\n  /**\r\n   * No-op as array vertices are transformed eagerly.\r\n   */\n  ensureRecentData(_updatingService) {}\n  isLeftCorner(address) {\n    return equalSimpleCellAddress(this.cellAddress, address);\n  }\n  setErrorValue(error) {\n    this.array = new ErroredArray(error, this.array.size);\n  }\n}\n/**\r\n * Represents vertex which keeps formula\r\n */\nexport class FormulaCellVertex extends FormulaVertex {\n  constructor(/** Formula in AST format */\n  formula, /** Address which this vertex represents */\n  address, version) {\n    super(formula, address, version);\n  }\n  valueOrUndef() {\n    return this.cachedCellValue;\n  }\n  /**\r\n   * Sets computed cell value stored in this vertex\r\n   */\n  setCellValue(cellValue) {\n    this.cachedCellValue = cellValue;\n    return this.cachedCellValue;\n  }\n  /**\r\n   * Returns cell value stored in vertex\r\n   */\n  getCellValue() {\n    if (this.cachedCellValue !== undefined) {\n      return this.cachedCellValue;\n    } else {\n      throw Error('Value of the formula cell is not computed.');\n    }\n  }\n  isComputed() {\n    return this.cachedCellValue !== undefined;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}