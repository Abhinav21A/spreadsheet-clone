{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { ArraySize } from \"../../ArraySize.mjs\";\nimport { CellError, ErrorType } from \"../../Cell.mjs\";\nimport { ErrorMessage } from \"../../error-message.mjs\";\nimport { AstNodeType } from \"../../parser/index.mjs\";\nimport { InterpreterState } from \"../InterpreterState.mjs\";\nimport { SimpleRangeValue } from \"../../SimpleRangeValue.mjs\";\nimport { FunctionArgumentType, FunctionPlugin } from \"./FunctionPlugin.mjs\";\nfunction arraySizeForMultiplication(leftArraySize, rightArraySize) {\n  return new ArraySize(rightArraySize.width, leftArraySize.height);\n}\nfunction arraySizeForPoolFunction(inputArray, windowSize, stride) {\n  return new ArraySize(1 + (inputArray.width - windowSize) / stride, 1 + (inputArray.height - windowSize) / stride);\n}\nexport class MatrixPlugin extends FunctionPlugin {\n  mmult(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('MMULT'), (leftMatrix, rightMatrix) => {\n      if (!leftMatrix.hasOnlyNumbers() || !rightMatrix.hasOnlyNumbers()) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.NumberRange);\n      }\n      if (rightMatrix.height() !== leftMatrix.width()) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.ArrayDimensions);\n      }\n      const outputSize = arraySizeForMultiplication(leftMatrix.size, rightMatrix.size);\n      const result = this.createKernel(function (a, b, width) {\n        let sum = 0;\n        for (let i = 0; i < width; ++i) {\n          sum += a[this.thread.y][i] * b[i][this.thread.x];\n        }\n        return sum;\n      }, outputSize)(leftMatrix.rawNumbers(), rightMatrix.rawNumbers(), leftMatrix.width());\n      return SimpleRangeValue.onlyNumbers(result);\n    });\n  }\n  mmultArraySize(ast, state) {\n    if (ast.args.length !== 2) {\n      return ArraySize.error();\n    }\n    const metadata = this.metadata('MMULT');\n    const subChecks = ast.args.map(arg => {\n      var _a;\n      return this.arraySizeForAst(arg, new InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));\n    });\n    const [left, right] = subChecks;\n    return arraySizeForMultiplication(left, right);\n  }\n  maxpool(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('MAXPOOL'), (matrix, windowSize, stride = windowSize) => {\n      if (!matrix.hasOnlyNumbers()) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.NumberRange);\n      }\n      const outputSize = arraySizeForPoolFunction(matrix.size, windowSize, stride);\n      const result = this.createKernel(function (a, windowSize, stride) {\n        const leftCornerX = this.thread.x * stride;\n        const leftCornerY = this.thread.y * stride;\n        let currentMax = a[leftCornerY][leftCornerX];\n        for (let i = 0; i < windowSize; i++) {\n          for (let j = 0; j < windowSize; j++) {\n            currentMax = Math.max(currentMax, a[leftCornerY + i][leftCornerX + j]);\n          }\n        }\n        return currentMax;\n      }, outputSize)(matrix.rawNumbers(), windowSize, stride);\n      return SimpleRangeValue.onlyNumbers(result);\n    });\n  }\n  medianpool(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('MEDIANPOOL'), (matrix, windowSize, stride = windowSize) => {\n      if (!matrix.hasOnlyNumbers()) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.NumberRange);\n      }\n      const outputSize = arraySizeForPoolFunction(matrix.size, windowSize, stride);\n      const result = this.createKernel(function (a, windowSize, stride) {\n        const leftCornerX = this.thread.x * stride;\n        const leftCornerY = this.thread.y * stride;\n        let currentMax = a[leftCornerY][leftCornerX];\n        for (let i = 0; i < windowSize; i++) {\n          for (let j = 0; j < windowSize; j++) {\n            currentMax = Math.max(currentMax, a[leftCornerY + i][leftCornerX + j]);\n          }\n        }\n        let currentMin = a[leftCornerY][leftCornerX];\n        for (let i2 = 0; i2 < windowSize; i2++) {\n          for (let j2 = 0; j2 < windowSize; j2++) {\n            currentMin = Math.min(currentMin, a[leftCornerY + i2][leftCornerX + j2]);\n          }\n        }\n        const numberOfElements = windowSize * windowSize;\n        let leftEnd = currentMin;\n        let rightEnd = currentMax;\n        let result = 42;\n        for (let iter = 0; iter < 32; iter++) {\n          const medianGuess = (leftEnd + rightEnd) / 2;\n          let medianGuessCount = 0;\n          for (let i3 = 0; i3 < windowSize; i3++) {\n            for (let j3 = 0; j3 < windowSize; j3++) {\n              if (a[leftCornerY + i3][leftCornerX + j3] > medianGuess) {\n                medianGuessCount++;\n              }\n            }\n          }\n          if (windowSize % 2 === 0) {\n            if (medianGuessCount === numberOfElements / 2) {\n              result = medianGuess;\n              break;\n            } else if (medianGuessCount > numberOfElements / 2) {\n              leftEnd = medianGuess;\n            } else {\n              rightEnd = medianGuess;\n            }\n          } else {\n            if (medianGuessCount === (numberOfElements - 1) / 2) {\n              result = medianGuess;\n              break;\n            } else if (medianGuessCount > (numberOfElements - 1) / 2) {\n              leftEnd = medianGuess;\n            } else {\n              rightEnd = medianGuess;\n            }\n          }\n        }\n        return result;\n      }, outputSize)(matrix.rawNumbers(), windowSize, stride);\n      return SimpleRangeValue.onlyNumbers(result);\n    });\n  }\n  maxpoolArraySize(ast, state) {\n    if (ast.args.length < 2 || ast.args.length > 3) {\n      return ArraySize.error();\n    }\n    const metadata = this.metadata('MAXPOOL');\n    const subChecks = ast.args.map(arg => {\n      var _a;\n      return this.arraySizeForAst(arg, new InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));\n    });\n    const array = subChecks[0];\n    const windowArg = ast.args[1];\n    let window;\n    if (windowArg.type === AstNodeType.NUMBER) {\n      window = windowArg.value;\n    } else {\n      window = 1;\n    }\n    let stride = window;\n    if (ast.args.length === 3) {\n      const strideArg = ast.args[2];\n      if (strideArg.type === AstNodeType.NUMBER) {\n        stride = strideArg.value;\n      } else {\n        stride = 1; // codecov: unreachable - strideArg is always type AstNodeType.NUMBER due to FunctionPlugin argument checking+coersion\n      }\n    }\n    if (window > array.width || window > array.height || stride > window || (array.width - window) % stride !== 0 || (array.height - window) % stride !== 0) {\n      return ArraySize.error();\n    }\n    return arraySizeForPoolFunction(array, window, stride);\n  }\n  medianpoolArraySize(ast, state) {\n    return this.maxpoolArraySize(ast, state);\n  }\n  transpose(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('TRANSPOSE'), matrix => {\n      const input = matrix.rawData();\n      const inputSize = matrix.size;\n      const result = [];\n      for (let i = 0; i < inputSize.width; ++i) {\n        result[i] = [];\n        for (let j = 0; j < inputSize.height; ++j) {\n          result[i][j] = input[j][i];\n        }\n      }\n      return SimpleRangeValue.onlyValues(result);\n    });\n  }\n  transposeArraySize(ast, state) {\n    if (ast.args.length !== 1) {\n      return ArraySize.error();\n    }\n    const metadata = this.metadata('TRANSPOSE');\n    const subChecks = ast.args.map(arg => {\n      var _a;\n      return this.arraySizeForAst(arg, new InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));\n    });\n    const [size] = subChecks;\n    return new ArraySize(size.height, size.width);\n  }\n  createKernel(kernel, outputSize) {\n    return function (...args) {\n      const result = [];\n      for (let y = 0; y < outputSize.height; ++y) {\n        result.push([]);\n        for (let x = 0; x < outputSize.width; ++x) {\n          result[y][x] = kernel.apply({\n            thread: {\n              x,\n              y\n            }\n          }, args);\n        }\n      }\n      return result;\n    };\n  }\n}\nMatrixPlugin.implementedFunctions = {\n  'MMULT': {\n    method: 'mmult',\n    arraySizeMethod: 'mmultArraySize',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.RANGE\n    }],\n    vectorizationForbidden: true\n  },\n  'TRANSPOSE': {\n    method: 'transpose',\n    arraySizeMethod: 'transposeArraySize',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }],\n    vectorizationForbidden: true\n  },\n  'MAXPOOL': {\n    method: 'maxpool',\n    arraySizeMethod: 'maxpoolArraySize',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      optionalArg: true\n    }],\n    vectorizationForbidden: true\n  },\n  'MEDIANPOOL': {\n    method: 'medianpool',\n    arraySizeMethod: 'medianpoolArraySize',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      optionalArg: true\n    }],\n    vectorizationForbidden: true\n  }\n};","map":{"version":3,"names":["ArraySize","CellError","ErrorType","ErrorMessage","AstNodeType","InterpreterState","SimpleRangeValue","FunctionArgumentType","FunctionPlugin","arraySizeForMultiplication","leftArraySize","rightArraySize","width","height","arraySizeForPoolFunction","inputArray","windowSize","stride","MatrixPlugin","mmult","ast","state","runFunction","args","metadata","leftMatrix","rightMatrix","hasOnlyNumbers","VALUE","NumberRange","ArrayDimensions","outputSize","size","result","createKernel","a","b","sum","i","thread","y","x","rawNumbers","onlyNumbers","mmultArraySize","length","error","subChecks","map","arg","_a","arraySizeForAst","formulaAddress","arraysFlag","arrayFunction","left","right","maxpool","matrix","leftCornerX","leftCornerY","currentMax","j","Math","max","medianpool","currentMin","i2","j2","min","numberOfElements","leftEnd","rightEnd","iter","medianGuess","medianGuessCount","i3","j3","maxpoolArraySize","array","windowArg","window","type","NUMBER","value","strideArg","medianpoolArraySize","transpose","input","rawData","inputSize","onlyValues","transposeArraySize","kernel","push","apply","implementedFunctions","method","arraySizeMethod","parameters","argumentType","RANGE","vectorizationForbidden","optionalArg"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/interpreter/plugin/MatrixPlugin.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { ArraySize } from \"../../ArraySize.mjs\";\nimport { CellError, ErrorType } from \"../../Cell.mjs\";\nimport { ErrorMessage } from \"../../error-message.mjs\";\nimport { AstNodeType } from \"../../parser/index.mjs\";\nimport { InterpreterState } from \"../InterpreterState.mjs\";\nimport { SimpleRangeValue } from \"../../SimpleRangeValue.mjs\";\nimport { FunctionArgumentType, FunctionPlugin } from \"./FunctionPlugin.mjs\";\nfunction arraySizeForMultiplication(leftArraySize, rightArraySize) {\n  return new ArraySize(rightArraySize.width, leftArraySize.height);\n}\nfunction arraySizeForPoolFunction(inputArray, windowSize, stride) {\n  return new ArraySize(1 + (inputArray.width - windowSize) / stride, 1 + (inputArray.height - windowSize) / stride);\n}\nexport class MatrixPlugin extends FunctionPlugin {\n  mmult(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('MMULT'), (leftMatrix, rightMatrix) => {\n      if (!leftMatrix.hasOnlyNumbers() || !rightMatrix.hasOnlyNumbers()) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.NumberRange);\n      }\n      if (rightMatrix.height() !== leftMatrix.width()) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.ArrayDimensions);\n      }\n      const outputSize = arraySizeForMultiplication(leftMatrix.size, rightMatrix.size);\n      const result = this.createKernel(function (a, b, width) {\n        let sum = 0;\n        for (let i = 0; i < width; ++i) {\n          sum += a[this.thread.y][i] * b[i][this.thread.x];\n        }\n        return sum;\n      }, outputSize)(leftMatrix.rawNumbers(), rightMatrix.rawNumbers(), leftMatrix.width());\n      return SimpleRangeValue.onlyNumbers(result);\n    });\n  }\n  mmultArraySize(ast, state) {\n    if (ast.args.length !== 2) {\n      return ArraySize.error();\n    }\n    const metadata = this.metadata('MMULT');\n    const subChecks = ast.args.map(arg => {\n      var _a;\n      return this.arraySizeForAst(arg, new InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));\n    });\n    const [left, right] = subChecks;\n    return arraySizeForMultiplication(left, right);\n  }\n  maxpool(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('MAXPOOL'), (matrix, windowSize, stride = windowSize) => {\n      if (!matrix.hasOnlyNumbers()) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.NumberRange);\n      }\n      const outputSize = arraySizeForPoolFunction(matrix.size, windowSize, stride);\n      const result = this.createKernel(function (a, windowSize, stride) {\n        const leftCornerX = this.thread.x * stride;\n        const leftCornerY = this.thread.y * stride;\n        let currentMax = a[leftCornerY][leftCornerX];\n        for (let i = 0; i < windowSize; i++) {\n          for (let j = 0; j < windowSize; j++) {\n            currentMax = Math.max(currentMax, a[leftCornerY + i][leftCornerX + j]);\n          }\n        }\n        return currentMax;\n      }, outputSize)(matrix.rawNumbers(), windowSize, stride);\n      return SimpleRangeValue.onlyNumbers(result);\n    });\n  }\n  medianpool(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('MEDIANPOOL'), (matrix, windowSize, stride = windowSize) => {\n      if (!matrix.hasOnlyNumbers()) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.NumberRange);\n      }\n      const outputSize = arraySizeForPoolFunction(matrix.size, windowSize, stride);\n      const result = this.createKernel(function (a, windowSize, stride) {\n        const leftCornerX = this.thread.x * stride;\n        const leftCornerY = this.thread.y * stride;\n        let currentMax = a[leftCornerY][leftCornerX];\n        for (let i = 0; i < windowSize; i++) {\n          for (let j = 0; j < windowSize; j++) {\n            currentMax = Math.max(currentMax, a[leftCornerY + i][leftCornerX + j]);\n          }\n        }\n        let currentMin = a[leftCornerY][leftCornerX];\n        for (let i2 = 0; i2 < windowSize; i2++) {\n          for (let j2 = 0; j2 < windowSize; j2++) {\n            currentMin = Math.min(currentMin, a[leftCornerY + i2][leftCornerX + j2]);\n          }\n        }\n        const numberOfElements = windowSize * windowSize;\n        let leftEnd = currentMin;\n        let rightEnd = currentMax;\n        let result = 42;\n        for (let iter = 0; iter < 32; iter++) {\n          const medianGuess = (leftEnd + rightEnd) / 2;\n          let medianGuessCount = 0;\n          for (let i3 = 0; i3 < windowSize; i3++) {\n            for (let j3 = 0; j3 < windowSize; j3++) {\n              if (a[leftCornerY + i3][leftCornerX + j3] > medianGuess) {\n                medianGuessCount++;\n              }\n            }\n          }\n          if (windowSize % 2 === 0) {\n            if (medianGuessCount === numberOfElements / 2) {\n              result = medianGuess;\n              break;\n            } else if (medianGuessCount > numberOfElements / 2) {\n              leftEnd = medianGuess;\n            } else {\n              rightEnd = medianGuess;\n            }\n          } else {\n            if (medianGuessCount === (numberOfElements - 1) / 2) {\n              result = medianGuess;\n              break;\n            } else if (medianGuessCount > (numberOfElements - 1) / 2) {\n              leftEnd = medianGuess;\n            } else {\n              rightEnd = medianGuess;\n            }\n          }\n        }\n        return result;\n      }, outputSize)(matrix.rawNumbers(), windowSize, stride);\n      return SimpleRangeValue.onlyNumbers(result);\n    });\n  }\n  maxpoolArraySize(ast, state) {\n    if (ast.args.length < 2 || ast.args.length > 3) {\n      return ArraySize.error();\n    }\n    const metadata = this.metadata('MAXPOOL');\n    const subChecks = ast.args.map(arg => {\n      var _a;\n      return this.arraySizeForAst(arg, new InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));\n    });\n    const array = subChecks[0];\n    const windowArg = ast.args[1];\n    let window;\n    if (windowArg.type === AstNodeType.NUMBER) {\n      window = windowArg.value;\n    } else {\n      window = 1;\n    }\n    let stride = window;\n    if (ast.args.length === 3) {\n      const strideArg = ast.args[2];\n      if (strideArg.type === AstNodeType.NUMBER) {\n        stride = strideArg.value;\n      } else {\n        stride = 1; // codecov: unreachable - strideArg is always type AstNodeType.NUMBER due to FunctionPlugin argument checking+coersion\n      }\n    }\n    if (window > array.width || window > array.height || stride > window || (array.width - window) % stride !== 0 || (array.height - window) % stride !== 0) {\n      return ArraySize.error();\n    }\n    return arraySizeForPoolFunction(array, window, stride);\n  }\n  medianpoolArraySize(ast, state) {\n    return this.maxpoolArraySize(ast, state);\n  }\n  transpose(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('TRANSPOSE'), matrix => {\n      const input = matrix.rawData();\n      const inputSize = matrix.size;\n      const result = [];\n      for (let i = 0; i < inputSize.width; ++i) {\n        result[i] = [];\n        for (let j = 0; j < inputSize.height; ++j) {\n          result[i][j] = input[j][i];\n        }\n      }\n      return SimpleRangeValue.onlyValues(result);\n    });\n  }\n  transposeArraySize(ast, state) {\n    if (ast.args.length !== 1) {\n      return ArraySize.error();\n    }\n    const metadata = this.metadata('TRANSPOSE');\n    const subChecks = ast.args.map(arg => {\n      var _a;\n      return this.arraySizeForAst(arg, new InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));\n    });\n    const [size] = subChecks;\n    return new ArraySize(size.height, size.width);\n  }\n  createKernel(kernel, outputSize) {\n    return function (...args) {\n      const result = [];\n      for (let y = 0; y < outputSize.height; ++y) {\n        result.push([]);\n        for (let x = 0; x < outputSize.width; ++x) {\n          result[y][x] = kernel.apply({\n            thread: {\n              x,\n              y\n            }\n          }, args);\n        }\n      }\n      return result;\n    };\n  }\n}\nMatrixPlugin.implementedFunctions = {\n  'MMULT': {\n    method: 'mmult',\n    arraySizeMethod: 'mmultArraySize',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.RANGE\n    }],\n    vectorizationForbidden: true\n  },\n  'TRANSPOSE': {\n    method: 'transpose',\n    arraySizeMethod: 'transposeArraySize',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }],\n    vectorizationForbidden: true\n  },\n  'MAXPOOL': {\n    method: 'maxpool',\n    arraySizeMethod: 'maxpoolArraySize',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      optionalArg: true\n    }],\n    vectorizationForbidden: true\n  },\n  'MEDIANPOOL': {\n    method: 'medianpool',\n    arraySizeMethod: 'medianpoolArraySize',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      optionalArg: true\n    }],\n    vectorizationForbidden: true\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}