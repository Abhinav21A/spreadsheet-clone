{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { absoluteSheetReference, ErrorType } from \"../Cell.mjs\";\nimport { Transformer } from \"./Transformer.mjs\";\nexport class AddRowsTransformer extends Transformer {\n  constructor(rowsSpan) {\n    super();\n    this.rowsSpan = rowsSpan;\n  }\n  get sheet() {\n    return this.rowsSpan.sheet;\n  }\n  isIrreversible() {\n    return false;\n  }\n  transformColumnRangeAst(ast, _formulaAddress) {\n    return ast;\n  }\n  transformCellRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformRowRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformColumnRange(_start, _end, _formulaAddress) {\n    throw Error('Not implemented');\n  }\n  transformCellAddress(dependencyAddress, formulaAddress) {\n    const absoluteDependencySheet = absoluteSheetReference(dependencyAddress, formulaAddress);\n    // Case 4 and 5\n    if (absoluteDependencySheet !== this.rowsSpan.sheet && formulaAddress.sheet !== this.rowsSpan.sheet) {\n      return false;\n    }\n    const absolutizedDependencyAddress = dependencyAddress.toSimpleRowAddress(formulaAddress);\n    // Case 3\n    if (absoluteDependencySheet === this.rowsSpan.sheet && formulaAddress.sheet !== this.rowsSpan.sheet) {\n      if (this.rowsSpan.rowStart <= absolutizedDependencyAddress.row) {\n        return dependencyAddress.shiftedByRows(this.rowsSpan.numberOfRows);\n      } else {\n        return false;\n      }\n    }\n    // Case 2\n    if (formulaAddress.sheet === this.rowsSpan.sheet && absoluteDependencySheet !== this.rowsSpan.sheet) {\n      if (dependencyAddress.isRowAbsolute()) {\n        return false;\n      }\n      if (formulaAddress.row < this.rowsSpan.rowStart) {\n        return false;\n      }\n      return dependencyAddress.shiftedByRows(-this.rowsSpan.numberOfRows);\n    }\n    // Case 1\n    if (dependencyAddress.isRowAbsolute()) {\n      if (dependencyAddress.row < this.rowsSpan.rowStart) {\n        // Case Aa\n        return false;\n      } else {\n        // Case Ab\n        return dependencyAddress.shiftedByRows(this.rowsSpan.numberOfRows);\n      }\n    } else {\n      if (absolutizedDependencyAddress.row < this.rowsSpan.rowStart) {\n        if (formulaAddress.row < this.rowsSpan.rowStart) {\n          // Case Raa\n          return false;\n        } else {\n          // Case Rab\n          return dependencyAddress.shiftedByRows(-this.rowsSpan.numberOfRows);\n        }\n      } else {\n        if (formulaAddress.row < this.rowsSpan.rowStart) {\n          // Case Rba\n          return dependencyAddress.shiftedByRows(this.rowsSpan.numberOfRows);\n        } else {\n          // Case Rbb\n          return false;\n        }\n      }\n    }\n  }\n  fixNodeAddress(address) {\n    if (this.rowsSpan.sheet === address.sheet && this.rowsSpan.rowStart <= address.row) {\n      return Object.assign(Object.assign({}, address), {\n        row: address.row + this.rowsSpan.numberOfRows\n      });\n    } else {\n      return address;\n    }\n  }\n  transformRange(start, end, formulaAddress) {\n    const newStart = this.transformCellAddress(start, formulaAddress);\n    const newEnd = this.transformCellAddress(end, formulaAddress);\n    if (newStart === ErrorType.REF || newEnd === ErrorType.REF) {\n      return ErrorType.REF;\n    } else if (newStart || newEnd) {\n      return [newStart || start, newEnd || end];\n    } else {\n      return false;\n    }\n  }\n}","map":{"version":3,"names":["absoluteSheetReference","ErrorType","Transformer","AddRowsTransformer","constructor","rowsSpan","sheet","isIrreversible","transformColumnRangeAst","ast","_formulaAddress","transformCellRange","start","end","formulaAddress","transformRange","transformRowRange","transformColumnRange","_start","_end","Error","transformCellAddress","dependencyAddress","absoluteDependencySheet","absolutizedDependencyAddress","toSimpleRowAddress","rowStart","row","shiftedByRows","numberOfRows","isRowAbsolute","fixNodeAddress","address","Object","assign","newStart","newEnd","REF"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/dependencyTransformers/AddRowsTransformer.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { absoluteSheetReference, ErrorType } from \"../Cell.mjs\";\nimport { Transformer } from \"./Transformer.mjs\";\nexport class AddRowsTransformer extends Transformer {\n  constructor(rowsSpan) {\n    super();\n    this.rowsSpan = rowsSpan;\n  }\n  get sheet() {\n    return this.rowsSpan.sheet;\n  }\n  isIrreversible() {\n    return false;\n  }\n  transformColumnRangeAst(ast, _formulaAddress) {\n    return ast;\n  }\n  transformCellRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformRowRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformColumnRange(_start, _end, _formulaAddress) {\n    throw Error('Not implemented');\n  }\n  transformCellAddress(dependencyAddress, formulaAddress) {\n    const absoluteDependencySheet = absoluteSheetReference(dependencyAddress, formulaAddress);\n    // Case 4 and 5\n    if (absoluteDependencySheet !== this.rowsSpan.sheet && formulaAddress.sheet !== this.rowsSpan.sheet) {\n      return false;\n    }\n    const absolutizedDependencyAddress = dependencyAddress.toSimpleRowAddress(formulaAddress);\n    // Case 3\n    if (absoluteDependencySheet === this.rowsSpan.sheet && formulaAddress.sheet !== this.rowsSpan.sheet) {\n      if (this.rowsSpan.rowStart <= absolutizedDependencyAddress.row) {\n        return dependencyAddress.shiftedByRows(this.rowsSpan.numberOfRows);\n      } else {\n        return false;\n      }\n    }\n    // Case 2\n    if (formulaAddress.sheet === this.rowsSpan.sheet && absoluteDependencySheet !== this.rowsSpan.sheet) {\n      if (dependencyAddress.isRowAbsolute()) {\n        return false;\n      }\n      if (formulaAddress.row < this.rowsSpan.rowStart) {\n        return false;\n      }\n      return dependencyAddress.shiftedByRows(-this.rowsSpan.numberOfRows);\n    }\n    // Case 1\n    if (dependencyAddress.isRowAbsolute()) {\n      if (dependencyAddress.row < this.rowsSpan.rowStart) {\n        // Case Aa\n        return false;\n      } else {\n        // Case Ab\n        return dependencyAddress.shiftedByRows(this.rowsSpan.numberOfRows);\n      }\n    } else {\n      if (absolutizedDependencyAddress.row < this.rowsSpan.rowStart) {\n        if (formulaAddress.row < this.rowsSpan.rowStart) {\n          // Case Raa\n          return false;\n        } else {\n          // Case Rab\n          return dependencyAddress.shiftedByRows(-this.rowsSpan.numberOfRows);\n        }\n      } else {\n        if (formulaAddress.row < this.rowsSpan.rowStart) {\n          // Case Rba\n          return dependencyAddress.shiftedByRows(this.rowsSpan.numberOfRows);\n        } else {\n          // Case Rbb\n          return false;\n        }\n      }\n    }\n  }\n  fixNodeAddress(address) {\n    if (this.rowsSpan.sheet === address.sheet && this.rowsSpan.rowStart <= address.row) {\n      return Object.assign(Object.assign({}, address), {\n        row: address.row + this.rowsSpan.numberOfRows\n      });\n    } else {\n      return address;\n    }\n  }\n  transformRange(start, end, formulaAddress) {\n    const newStart = this.transformCellAddress(start, formulaAddress);\n    const newEnd = this.transformCellAddress(end, formulaAddress);\n    if (newStart === ErrorType.REF || newEnd === ErrorType.REF) {\n      return ErrorType.REF;\n    } else if (newStart || newEnd) {\n      return [newStart || start, newEnd || end];\n    } else {\n      return false;\n    }\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}