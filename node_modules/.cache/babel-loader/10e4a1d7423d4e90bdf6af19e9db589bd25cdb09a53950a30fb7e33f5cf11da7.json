{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nconst dateFormatRegex = /(\\\\.|dd|DD|d|D|mm|MM|m|M|YYYY|YY|yyyy|yy|HH|hh|H|h|ss(\\.(0+|s+))?|s|AM\\/PM|am\\/pm|A\\/P|a\\/p|\\[mm]|\\[MM]|\\[hh]|\\[HH])/g;\nconst numberFormatRegex = /(\\\\.|[#0]+(\\.[#0]*)?)/g;\nexport var TokenType;\n(function (TokenType) {\n  TokenType[\"FORMAT\"] = \"FORMAT\";\n  TokenType[\"FREE_TEXT\"] = \"FREE_TEXT\";\n})(TokenType || (TokenType = {}));\nexport function formatToken(type, value) {\n  return {\n    type,\n    value\n  };\n}\nexport var FormatExpressionType;\n(function (FormatExpressionType) {\n  FormatExpressionType[\"DATE\"] = \"DATE\";\n  FormatExpressionType[\"NUMBER\"] = \"NUMBER\";\n  FormatExpressionType[\"STRING\"] = \"STRING\";\n})(FormatExpressionType || (FormatExpressionType = {}));\nfunction matchDateFormat(str) {\n  dateFormatRegex.lastIndex = 0;\n  const tokens = [];\n  let m;\n  do {\n    m = dateFormatRegex.exec(str);\n    if (m !== null) {\n      tokens.push(m);\n    }\n  } while (m);\n  return tokens;\n}\nfunction matchNumberFormat(str) {\n  numberFormatRegex.lastIndex = 0;\n  const numberFormatToken = numberFormatRegex.exec(str);\n  if (numberFormatToken !== null) {\n    return [numberFormatToken];\n  } else {\n    return [];\n  }\n}\nfunction createTokens(regexTokens, str) {\n  const tokens = [];\n  let start = 0;\n  for (let i = 0; i < regexTokens.length; ++i) {\n    const token = regexTokens[i];\n    if (token.index !== start) {\n      const beforeToken = str.substr(start, token.index - start);\n      tokens.push(formatToken(TokenType.FREE_TEXT, beforeToken));\n    }\n    if (token[0].startsWith('\\\\')) {\n      tokens.push(formatToken(TokenType.FREE_TEXT, token[0]));\n    } else {\n      tokens.push(formatToken(TokenType.FORMAT, token[0]));\n    }\n    start = token.index + token[0].length;\n  }\n  const lastToken = regexTokens[regexTokens.length - 1];\n  if (lastToken.index + lastToken[0].length < str.length) {\n    const afterLastToken = str.substr(lastToken.index + lastToken[0].length, str.length);\n    tokens.push(formatToken(TokenType.FREE_TEXT, afterLastToken));\n  }\n  return tokens;\n}\nexport function parseForDateTimeFormat(str) {\n  const dateFormatTokens = matchDateFormat(str);\n  if (dateFormatTokens.every(elem => isEscapeToken(elem))) {\n    return undefined;\n  } else {\n    return {\n      type: FormatExpressionType.DATE,\n      tokens: createTokens(dateFormatTokens, str)\n    };\n  }\n}\nexport function parseForNumberFormat(str) {\n  const numberFormatTokens = matchNumberFormat(str);\n  if (numberFormatTokens.every(elem => isEscapeToken(elem))) {\n    return undefined;\n  } else {\n    return {\n      type: FormatExpressionType.NUMBER,\n      tokens: createTokens(numberFormatTokens, str)\n    };\n  }\n}\nexport function parse(str) {\n  var _a, _b;\n  return (_b = (_a = parseForDateTimeFormat(str)) !== null && _a !== void 0 ? _a : parseForNumberFormat(str)) !== null && _b !== void 0 ? _b : {\n    type: FormatExpressionType.STRING,\n    tokens: [{\n      type: TokenType.FREE_TEXT,\n      value: str\n    }]\n  };\n}\nexport function isEscapeToken(token) {\n  return token[0].startsWith('\\\\');\n}","map":{"version":3,"names":["dateFormatRegex","numberFormatRegex","TokenType","formatToken","type","value","FormatExpressionType","matchDateFormat","str","lastIndex","tokens","m","exec","push","matchNumberFormat","numberFormatToken","createTokens","regexTokens","start","i","length","token","index","beforeToken","substr","FREE_TEXT","startsWith","FORMAT","lastToken","afterLastToken","parseForDateTimeFormat","dateFormatTokens","every","elem","isEscapeToken","undefined","DATE","parseForNumberFormat","numberFormatTokens","NUMBER","parse","_a","_b","STRING"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/format/parser.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nconst dateFormatRegex = /(\\\\.|dd|DD|d|D|mm|MM|m|M|YYYY|YY|yyyy|yy|HH|hh|H|h|ss(\\.(0+|s+))?|s|AM\\/PM|am\\/pm|A\\/P|a\\/p|\\[mm]|\\[MM]|\\[hh]|\\[HH])/g;\nconst numberFormatRegex = /(\\\\.|[#0]+(\\.[#0]*)?)/g;\nexport var TokenType;\n(function (TokenType) {\n  TokenType[\"FORMAT\"] = \"FORMAT\";\n  TokenType[\"FREE_TEXT\"] = \"FREE_TEXT\";\n})(TokenType || (TokenType = {}));\nexport function formatToken(type, value) {\n  return {\n    type,\n    value\n  };\n}\nexport var FormatExpressionType;\n(function (FormatExpressionType) {\n  FormatExpressionType[\"DATE\"] = \"DATE\";\n  FormatExpressionType[\"NUMBER\"] = \"NUMBER\";\n  FormatExpressionType[\"STRING\"] = \"STRING\";\n})(FormatExpressionType || (FormatExpressionType = {}));\nfunction matchDateFormat(str) {\n  dateFormatRegex.lastIndex = 0;\n  const tokens = [];\n  let m;\n  do {\n    m = dateFormatRegex.exec(str);\n    if (m !== null) {\n      tokens.push(m);\n    }\n  } while (m);\n  return tokens;\n}\nfunction matchNumberFormat(str) {\n  numberFormatRegex.lastIndex = 0;\n  const numberFormatToken = numberFormatRegex.exec(str);\n  if (numberFormatToken !== null) {\n    return [numberFormatToken];\n  } else {\n    return [];\n  }\n}\nfunction createTokens(regexTokens, str) {\n  const tokens = [];\n  let start = 0;\n  for (let i = 0; i < regexTokens.length; ++i) {\n    const token = regexTokens[i];\n    if (token.index !== start) {\n      const beforeToken = str.substr(start, token.index - start);\n      tokens.push(formatToken(TokenType.FREE_TEXT, beforeToken));\n    }\n    if (token[0].startsWith('\\\\')) {\n      tokens.push(formatToken(TokenType.FREE_TEXT, token[0]));\n    } else {\n      tokens.push(formatToken(TokenType.FORMAT, token[0]));\n    }\n    start = token.index + token[0].length;\n  }\n  const lastToken = regexTokens[regexTokens.length - 1];\n  if (lastToken.index + lastToken[0].length < str.length) {\n    const afterLastToken = str.substr(lastToken.index + lastToken[0].length, str.length);\n    tokens.push(formatToken(TokenType.FREE_TEXT, afterLastToken));\n  }\n  return tokens;\n}\nexport function parseForDateTimeFormat(str) {\n  const dateFormatTokens = matchDateFormat(str);\n  if (dateFormatTokens.every(elem => isEscapeToken(elem))) {\n    return undefined;\n  } else {\n    return {\n      type: FormatExpressionType.DATE,\n      tokens: createTokens(dateFormatTokens, str)\n    };\n  }\n}\nexport function parseForNumberFormat(str) {\n  const numberFormatTokens = matchNumberFormat(str);\n  if (numberFormatTokens.every(elem => isEscapeToken(elem))) {\n    return undefined;\n  } else {\n    return {\n      type: FormatExpressionType.NUMBER,\n      tokens: createTokens(numberFormatTokens, str)\n    };\n  }\n}\nexport function parse(str) {\n  var _a, _b;\n  return (_b = (_a = parseForDateTimeFormat(str)) !== null && _a !== void 0 ? _a : parseForNumberFormat(str)) !== null && _b !== void 0 ? _b : {\n    type: FormatExpressionType.STRING,\n    tokens: [{\n      type: TokenType.FREE_TEXT,\n      value: str\n    }]\n  };\n}\nexport function isEscapeToken(token) {\n  return token[0].startsWith('\\\\');\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}