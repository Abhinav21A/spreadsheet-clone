{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from \"./AbsoluteCellRange.mjs\";\nimport { absolutizeDependencies, filterDependenciesOutOfScope } from \"./absolutizeDependencies.mjs\";\nimport { ArraySize } from \"./ArraySize.mjs\";\nimport { equalSimpleCellAddress, invalidSimpleCellAddress, simpleCellAddress } from \"./Cell.mjs\";\nimport { CellContent } from \"./CellContentParser.mjs\";\nimport { ClipboardCellType } from \"./ClipboardOperations.mjs\";\nimport { ContentChanges } from \"./ContentChanges.mjs\";\nimport { ArrayVertex, EmptyCellVertex, FormulaCellVertex, ParsingErrorVertex, SparseStrategy, ValueCellVertex } from \"./DependencyGraph/index.mjs\";\nimport { FormulaVertex } from \"./DependencyGraph/FormulaCellVertex.mjs\";\nimport { AddColumnsTransformer } from \"./dependencyTransformers/AddColumnsTransformer.mjs\";\nimport { AddRowsTransformer } from \"./dependencyTransformers/AddRowsTransformer.mjs\";\nimport { CleanOutOfScopeDependenciesTransformer } from \"./dependencyTransformers/CleanOutOfScopeDependenciesTransformer.mjs\";\nimport { MoveCellsTransformer } from \"./dependencyTransformers/MoveCellsTransformer.mjs\";\nimport { RemoveColumnsTransformer } from \"./dependencyTransformers/RemoveColumnsTransformer.mjs\";\nimport { RemoveRowsTransformer } from \"./dependencyTransformers/RemoveRowsTransformer.mjs\";\nimport { RemoveSheetTransformer } from \"./dependencyTransformers/RemoveSheetTransformer.mjs\";\nimport { InvalidArgumentsError, NamedExpressionDoesNotExistError, NoRelativeAddressesAllowedError, SheetSizeLimitExceededError, SourceLocationHasArrayError, TargetLocationHasArrayError } from \"./errors.mjs\";\nimport { EmptyValue, getRawValue } from \"./interpreter/InterpreterValue.mjs\";\nimport { doesContainRelativeReferences, NamedExpressions } from \"./NamedExpressions.mjs\";\nimport { NamedExpressionDependency, ParsingErrorType } from \"./parser/index.mjs\";\nimport { findBoundaries } from \"./Sheet.mjs\";\nimport { ColumnsSpan, RowsSpan } from \"./Span.mjs\";\nimport { StatType } from \"./statistics/index.mjs\";\nexport class RemoveRowsCommand {\n  constructor(sheet, indexes) {\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n  normalizedIndexes() {\n    return normalizeRemovedIndexes(this.indexes);\n  }\n  rowsSpans() {\n    return this.normalizedIndexes().map(normalizedIndex => RowsSpan.fromNumberOfRows(this.sheet, normalizedIndex[0], normalizedIndex[1]));\n  }\n}\nexport class AddRowsCommand {\n  constructor(sheet, indexes) {\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n  normalizedIndexes() {\n    return normalizeAddedIndexes(this.indexes);\n  }\n  rowsSpans() {\n    return this.normalizedIndexes().map(normalizedIndex => RowsSpan.fromNumberOfRows(this.sheet, normalizedIndex[0], normalizedIndex[1]));\n  }\n}\nexport class AddColumnsCommand {\n  constructor(sheet, indexes) {\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n  normalizedIndexes() {\n    return normalizeAddedIndexes(this.indexes);\n  }\n  columnsSpans() {\n    return this.normalizedIndexes().map(normalizedIndex => ColumnsSpan.fromNumberOfColumns(this.sheet, normalizedIndex[0], normalizedIndex[1]));\n  }\n}\nexport class RemoveColumnsCommand {\n  constructor(sheet, indexes) {\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n  normalizedIndexes() {\n    return normalizeRemovedIndexes(this.indexes);\n  }\n  columnsSpans() {\n    return this.normalizedIndexes().map(normalizedIndex => ColumnsSpan.fromNumberOfColumns(this.sheet, normalizedIndex[0], normalizedIndex[1]));\n  }\n}\nexport class Operations {\n  constructor(config, dependencyGraph, columnSearch, cellContentParser, parser, stats, lazilyTransformingAstService, namedExpressions, arraySizePredictor) {\n    this.dependencyGraph = dependencyGraph;\n    this.columnSearch = columnSearch;\n    this.cellContentParser = cellContentParser;\n    this.parser = parser;\n    this.stats = stats;\n    this.lazilyTransformingAstService = lazilyTransformingAstService;\n    this.namedExpressions = namedExpressions;\n    this.arraySizePredictor = arraySizePredictor;\n    this.changes = ContentChanges.empty();\n    this.allocateNamedExpressionAddressSpace();\n    this.maxColumns = config.maxColumns;\n    this.maxRows = config.maxRows;\n  }\n  get sheetMapping() {\n    return this.dependencyGraph.sheetMapping;\n  }\n  get addressMapping() {\n    return this.dependencyGraph.addressMapping;\n  }\n  removeRows(cmd) {\n    const rowsRemovals = [];\n    for (const rowsToRemove of cmd.rowsSpans()) {\n      const rowsRemoval = this.doRemoveRows(rowsToRemove);\n      if (rowsRemoval) {\n        rowsRemovals.push(rowsRemoval);\n      }\n    }\n    return rowsRemovals;\n  }\n  addRows(cmd) {\n    for (const addedRows of cmd.rowsSpans()) {\n      this.doAddRows(addedRows);\n    }\n  }\n  addColumns(cmd) {\n    for (const addedColumns of cmd.columnsSpans()) {\n      this.doAddColumns(addedColumns);\n    }\n  }\n  removeColumns(cmd) {\n    const columnsRemovals = [];\n    for (const columnsToRemove of cmd.columnsSpans()) {\n      const columnsRemoval = this.doRemoveColumns(columnsToRemove);\n      if (columnsRemoval) {\n        columnsRemovals.push(columnsRemoval);\n      }\n    }\n    return columnsRemovals;\n  }\n  removeSheet(sheetId) {\n    this.dependencyGraph.removeSheet(sheetId);\n    let version = 0;\n    this.stats.measure(StatType.TRANSFORM_ASTS, () => {\n      const transformation = new RemoveSheetTransformer(sheetId);\n      transformation.performEagerTransformations(this.dependencyGraph, this.parser);\n      version = this.lazilyTransformingAstService.addTransformation(transformation);\n    });\n    this.sheetMapping.removeSheet(sheetId);\n    this.columnSearch.removeSheet(sheetId);\n    const scopedNamedExpressions = this.namedExpressions.getAllNamedExpressionsForScope(sheetId).map(namedExpression => this.removeNamedExpression(namedExpression.normalizeExpressionName(), sheetId));\n    return {\n      version: version,\n      scopedNamedExpressions\n    };\n  }\n  removeSheetByName(sheetName) {\n    const sheetId = this.sheetMapping.fetch(sheetName);\n    return this.removeSheet(sheetId);\n  }\n  clearSheet(sheetId) {\n    this.dependencyGraph.clearSheet(sheetId);\n    this.columnSearch.removeSheet(sheetId);\n  }\n  addSheet(name) {\n    const sheetId = this.sheetMapping.addSheet(name);\n    const sheet = [];\n    this.dependencyGraph.addressMapping.autoAddSheet(sheetId, findBoundaries(sheet));\n    return this.sheetMapping.fetchDisplayName(sheetId);\n  }\n  renameSheet(sheetId, newName) {\n    return this.sheetMapping.renameSheet(sheetId, newName);\n  }\n  moveRows(sheet, startRow, numberOfRows, targetRow) {\n    const rowsToAdd = RowsSpan.fromNumberOfRows(sheet, targetRow, numberOfRows);\n    this.lazilyTransformingAstService.beginCombinedMode(sheet);\n    this.doAddRows(rowsToAdd);\n    if (targetRow < startRow) {\n      startRow += numberOfRows;\n    }\n    const startAddress = simpleCellAddress(sheet, 0, startRow);\n    const targetAddress = simpleCellAddress(sheet, 0, targetRow);\n    this.moveCells(startAddress, Number.POSITIVE_INFINITY, numberOfRows, targetAddress);\n    const rowsToRemove = RowsSpan.fromNumberOfRows(sheet, startRow, numberOfRows);\n    this.doRemoveRows(rowsToRemove);\n    return this.lazilyTransformingAstService.commitCombinedMode();\n  }\n  moveColumns(sheet, startColumn, numberOfColumns, targetColumn) {\n    const columnsToAdd = ColumnsSpan.fromNumberOfColumns(sheet, targetColumn, numberOfColumns);\n    this.lazilyTransformingAstService.beginCombinedMode(sheet);\n    this.doAddColumns(columnsToAdd);\n    if (targetColumn < startColumn) {\n      startColumn += numberOfColumns;\n    }\n    const startAddress = simpleCellAddress(sheet, startColumn, 0);\n    const targetAddress = simpleCellAddress(sheet, targetColumn, 0);\n    this.moveCells(startAddress, numberOfColumns, Number.POSITIVE_INFINITY, targetAddress);\n    const columnsToRemove = ColumnsSpan.fromNumberOfColumns(sheet, startColumn, numberOfColumns);\n    this.doRemoveColumns(columnsToRemove);\n    return this.lazilyTransformingAstService.commitCombinedMode();\n  }\n  moveCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n    this.ensureItIsPossibleToMoveCells(sourceLeftCorner, width, height, destinationLeftCorner);\n    const sourceRange = AbsoluteCellRange.spanFrom(sourceLeftCorner, width, height);\n    const targetRange = AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);\n    const toRight = destinationLeftCorner.col - sourceLeftCorner.col;\n    const toBottom = destinationLeftCorner.row - sourceLeftCorner.row;\n    const toSheet = destinationLeftCorner.sheet;\n    const currentDataAtTarget = this.getRangeClipboardCells(targetRange);\n    const valuesToRemove = this.dependencyGraph.rawValuesFromRange(targetRange);\n    this.columnSearch.removeValues(valuesToRemove);\n    const valuesToMove = this.dependencyGraph.rawValuesFromRange(sourceRange);\n    this.columnSearch.moveValues(valuesToMove, toRight, toBottom, toSheet);\n    let version = 0;\n    this.stats.measure(StatType.TRANSFORM_ASTS, () => {\n      const transformation = new MoveCellsTransformer(sourceRange, toRight, toBottom, toSheet);\n      transformation.performEagerTransformations(this.dependencyGraph, this.parser);\n      version = this.lazilyTransformingAstService.addTransformation(transformation);\n    });\n    this.dependencyGraph.moveCells(sourceRange, toRight, toBottom, toSheet);\n    const addedGlobalNamedExpressions = this.updateNamedExpressionsForMovedCells(sourceLeftCorner, width, height, destinationLeftCorner);\n    return {\n      version: version,\n      overwrittenCellsData: currentDataAtTarget,\n      addedGlobalNamedExpressions: addedGlobalNamedExpressions\n    };\n  }\n  setRowOrder(sheetId, rowMapping) {\n    const buffer = [];\n    let oldContent = [];\n    for (const [source, target] of rowMapping) {\n      if (source !== target) {\n        const rowRange = AbsoluteCellRange.spanFrom({\n          sheet: sheetId,\n          col: 0,\n          row: source\n        }, Infinity, 1);\n        const row = this.getRangeClipboardCells(rowRange);\n        oldContent = oldContent.concat(row);\n        buffer.push(row.map(([{\n          sheet,\n          col\n        }, cell]) => [{\n          sheet,\n          col,\n          row: target\n        }, cell]));\n      }\n    }\n    buffer.forEach(row => this.restoreClipboardCells(sheetId, row.values()));\n    return oldContent;\n  }\n  setColumnOrder(sheetId, columnMapping) {\n    const buffer = [];\n    let oldContent = [];\n    for (const [source, target] of columnMapping) {\n      if (source !== target) {\n        const rowRange = AbsoluteCellRange.spanFrom({\n          sheet: sheetId,\n          col: source,\n          row: 0\n        }, 1, Infinity);\n        const column = this.getRangeClipboardCells(rowRange);\n        oldContent = oldContent.concat(column);\n        buffer.push(column.map(([{\n          sheet,\n          col: _col,\n          row\n        }, cell]) => [{\n          sheet,\n          col: target,\n          row\n        }, cell]));\n      }\n    }\n    buffer.forEach(column => this.restoreClipboardCells(sheetId, column.values()));\n    return oldContent;\n  }\n  addNamedExpression(expressionName, expression, sheetId, options) {\n    const namedExpression = this.namedExpressions.addNamedExpression(expressionName, sheetId, options);\n    this.storeNamedExpressionInCell(namedExpression.address, expression);\n    this.adjustNamedExpressionEdges(namedExpression, expressionName, sheetId);\n  }\n  restoreNamedExpression(namedExpression, content, sheetId) {\n    const expressionName = namedExpression.displayName;\n    this.restoreCell(namedExpression.address, content);\n    const restoredNamedExpression = this.namedExpressions.restoreNamedExpression(namedExpression, sheetId);\n    this.adjustNamedExpressionEdges(restoredNamedExpression, expressionName, sheetId);\n  }\n  changeNamedExpressionExpression(expressionName, newExpression, sheetId, options) {\n    const namedExpression = this.namedExpressions.namedExpressionForScope(expressionName, sheetId);\n    if (!namedExpression) {\n      throw new NamedExpressionDoesNotExistError(expressionName);\n    }\n    const oldNamedExpression = namedExpression.copy();\n    namedExpression.options = options;\n    const content = this.getClipboardCell(namedExpression.address);\n    this.storeNamedExpressionInCell(namedExpression.address, newExpression);\n    return [oldNamedExpression, content];\n  }\n  removeNamedExpression(expressionName, sheetId) {\n    const namedExpression = this.namedExpressions.namedExpressionForScope(expressionName, sheetId);\n    if (!namedExpression) {\n      throw new NamedExpressionDoesNotExistError(expressionName);\n    }\n    this.namedExpressions.remove(namedExpression.displayName, sheetId);\n    const content = this.getClipboardCell(namedExpression.address);\n    if (sheetId !== undefined) {\n      const globalNamedExpression = this.namedExpressions.workbookNamedExpressionOrPlaceholder(expressionName);\n      this.dependencyGraph.exchangeNode(namedExpression.address, globalNamedExpression.address);\n    } else {\n      this.dependencyGraph.setCellEmpty(namedExpression.address);\n    }\n    return [namedExpression, content];\n  }\n  ensureItIsPossibleToMoveCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n    if (invalidSimpleCellAddress(sourceLeftCorner) || !(isPositiveInteger(width) && isPositiveInteger(height) || isRowOrColumnRange(sourceLeftCorner, width, height)) || invalidSimpleCellAddress(destinationLeftCorner) || !this.sheetMapping.hasSheetWithId(sourceLeftCorner.sheet) || !this.sheetMapping.hasSheetWithId(destinationLeftCorner.sheet)) {\n      throw new InvalidArgumentsError('a valid range of cells to move.');\n    }\n    const sourceRange = AbsoluteCellRange.spanFrom(sourceLeftCorner, width, height);\n    const targetRange = AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);\n    if (targetRange.exceedsSheetSizeLimits(this.maxColumns, this.maxRows)) {\n      throw new SheetSizeLimitExceededError();\n    }\n    if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(sourceRange)) {\n      throw new SourceLocationHasArrayError();\n    }\n    if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(targetRange)) {\n      throw new TargetLocationHasArrayError();\n    }\n  }\n  restoreClipboardCells(sourceSheetId, cells) {\n    const addedNamedExpressions = [];\n    for (const [address, clipboardCell] of cells) {\n      this.restoreCell(address, clipboardCell);\n      if (clipboardCell.type === ClipboardCellType.FORMULA) {\n        const {\n          dependencies\n        } = this.parser.fetchCachedResult(clipboardCell.hash);\n        addedNamedExpressions.push(...this.updateNamedExpressionsForTargetAddress(sourceSheetId, address, dependencies));\n      }\n    }\n    return addedNamedExpressions;\n  }\n  /**\r\n   * Restores a single cell.\r\n   * @param {SimpleCellAddress} address\r\n   * @param {ClipboardCell} clipboardCell\r\n   */\n  restoreCell(address, clipboardCell) {\n    switch (clipboardCell.type) {\n      case ClipboardCellType.VALUE:\n        {\n          this.setValueToCell(clipboardCell, address);\n          break;\n        }\n      case ClipboardCellType.FORMULA:\n        {\n          this.setFormulaToCellFromCache(clipboardCell.hash, address);\n          break;\n        }\n      case ClipboardCellType.EMPTY:\n        {\n          this.setCellEmpty(address);\n          break;\n        }\n      case ClipboardCellType.PARSING_ERROR:\n        {\n          this.setParsingErrorToCell(clipboardCell.rawInput, clipboardCell.errors, address);\n          break;\n        }\n    }\n  }\n  getOldContent(address) {\n    const vertex = this.dependencyGraph.getCell(address);\n    if (vertex === undefined || vertex instanceof EmptyCellVertex) {\n      return [address, {\n        type: ClipboardCellType.EMPTY\n      }];\n    } else if (vertex instanceof ValueCellVertex) {\n      return [address, Object.assign({\n        type: ClipboardCellType.VALUE\n      }, vertex.getValues())];\n    } else if (vertex instanceof FormulaVertex) {\n      return [vertex.getAddress(this.lazilyTransformingAstService), {\n        type: ClipboardCellType.FORMULA,\n        hash: this.parser.computeHashFromAst(vertex.getFormula(this.lazilyTransformingAstService))\n      }];\n    } else if (vertex instanceof ParsingErrorVertex) {\n      return [address, {\n        type: ClipboardCellType.PARSING_ERROR,\n        rawInput: vertex.rawInput,\n        errors: vertex.errors\n      }];\n    }\n    throw Error('Trying to copy unsupported type');\n  }\n  getClipboardCell(address) {\n    const vertex = this.dependencyGraph.getCell(address);\n    if (vertex === undefined || vertex instanceof EmptyCellVertex) {\n      return {\n        type: ClipboardCellType.EMPTY\n      };\n    } else if (vertex instanceof ValueCellVertex) {\n      return Object.assign({\n        type: ClipboardCellType.VALUE\n      }, vertex.getValues());\n    } else if (vertex instanceof ArrayVertex) {\n      const val = vertex.getArrayCellValue(address);\n      if (val === EmptyValue) {\n        return {\n          type: ClipboardCellType.EMPTY\n        };\n      }\n      return {\n        type: ClipboardCellType.VALUE,\n        parsedValue: val,\n        rawValue: vertex.getArrayCellRawValue(address)\n      };\n    } else if (vertex instanceof FormulaCellVertex) {\n      return {\n        type: ClipboardCellType.FORMULA,\n        hash: this.parser.computeHashFromAst(vertex.getFormula(this.lazilyTransformingAstService))\n      };\n    } else if (vertex instanceof ParsingErrorVertex) {\n      return {\n        type: ClipboardCellType.PARSING_ERROR,\n        rawInput: vertex.rawInput,\n        errors: vertex.errors\n      };\n    }\n    throw Error('Trying to copy unsupported type');\n  }\n  getSheetClipboardCells(sheet) {\n    const sheetHeight = this.dependencyGraph.getSheetHeight(sheet);\n    const sheetWidth = this.dependencyGraph.getSheetWidth(sheet);\n    const arr = new Array(sheetHeight);\n    for (let i = 0; i < sheetHeight; i++) {\n      arr[i] = new Array(sheetWidth);\n      for (let j = 0; j < sheetWidth; j++) {\n        const address = simpleCellAddress(sheet, j, i);\n        arr[i][j] = this.getClipboardCell(address);\n      }\n    }\n    return arr;\n  }\n  getRangeClipboardCells(range) {\n    const result = [];\n    for (const address of range.addresses(this.dependencyGraph)) {\n      result.push([address, this.getClipboardCell(address)]);\n    }\n    return result;\n  }\n  setCellContent(address, newCellContent) {\n    const parsedCellContent = this.cellContentParser.parse(newCellContent);\n    const oldContent = this.getOldContent(address);\n    if (parsedCellContent instanceof CellContent.Formula) {\n      const parserResult = this.parser.parse(parsedCellContent.formula, address);\n      const {\n        ast,\n        errors\n      } = parserResult;\n      if (errors.length > 0) {\n        this.setParsingErrorToCell(parsedCellContent.formula, errors, address);\n      } else {\n        try {\n          const size = this.arraySizePredictor.checkArraySize(ast, address);\n          if (size.width <= 0 || size.height <= 0) {\n            throw Error('Incorrect array size');\n          }\n          this.setFormulaToCell(address, size, parserResult);\n        } catch (error) {\n          if (!error.message) {\n            throw error;\n          }\n          const parsingError = {\n            type: ParsingErrorType.InvalidRangeSize,\n            message: 'Invalid range size.'\n          };\n          this.setParsingErrorToCell(parsedCellContent.formula, [parsingError], address);\n        }\n      }\n    } else if (parsedCellContent instanceof CellContent.Empty) {\n      this.setCellEmpty(address);\n    } else {\n      this.setValueToCell({\n        parsedValue: parsedCellContent.value,\n        rawValue: newCellContent\n      }, address);\n    }\n    return oldContent;\n  }\n  setSheetContent(sheetId, newSheetContent) {\n    this.clearSheet(sheetId);\n    for (let i = 0; i < newSheetContent.length; i++) {\n      for (let j = 0; j < newSheetContent[i].length; j++) {\n        const address = simpleCellAddress(sheetId, j, i);\n        this.setCellContent(address, newSheetContent[i][j]);\n      }\n    }\n  }\n  setParsingErrorToCell(rawInput, errors, address) {\n    const oldValue = this.dependencyGraph.getCellValue(address);\n    const vertex = new ParsingErrorVertex(errors, rawInput);\n    const arrayChanges = this.dependencyGraph.setParsingErrorToCell(address, vertex);\n    this.columnSearch.remove(getRawValue(oldValue), address);\n    this.columnSearch.applyChanges(arrayChanges.getChanges());\n    this.changes.addAll(arrayChanges);\n    this.changes.addChange(vertex.getCellValue(), address);\n  }\n  setFormulaToCell(address, size, {\n    ast,\n    hasVolatileFunction,\n    hasStructuralChangeFunction,\n    dependencies\n  }) {\n    const oldValue = this.dependencyGraph.getCellValue(address);\n    const arrayChanges = this.dependencyGraph.setFormulaToCell(address, ast, absolutizeDependencies(dependencies, address), size, hasVolatileFunction, hasStructuralChangeFunction);\n    this.columnSearch.remove(getRawValue(oldValue), address);\n    this.columnSearch.applyChanges(arrayChanges.getChanges());\n    this.changes.addAll(arrayChanges);\n  }\n  setValueToCell(value, address) {\n    const oldValue = this.dependencyGraph.getCellValue(address);\n    const arrayChanges = this.dependencyGraph.setValueToCell(address, value);\n    this.columnSearch.change(getRawValue(oldValue), getRawValue(value.parsedValue), address);\n    this.columnSearch.applyChanges(arrayChanges.getChanges().filter(change => !equalSimpleCellAddress(change.address, address)));\n    this.changes.addAll(arrayChanges);\n    this.changes.addChange(value.parsedValue, address);\n  }\n  setCellEmpty(address) {\n    if (this.dependencyGraph.isArrayInternalCell(address)) {\n      return;\n    }\n    const oldValue = this.dependencyGraph.getCellValue(address);\n    const arrayChanges = this.dependencyGraph.setCellEmpty(address);\n    this.columnSearch.remove(getRawValue(oldValue), address);\n    this.columnSearch.applyChanges(arrayChanges.getChanges());\n    this.changes.addAll(arrayChanges);\n    this.changes.addChange(EmptyValue, address);\n  }\n  setFormulaToCellFromCache(formulaHash, address) {\n    const {\n      ast,\n      hasVolatileFunction,\n      hasStructuralChangeFunction,\n      dependencies\n    } = this.parser.fetchCachedResult(formulaHash);\n    const absoluteDependencies = absolutizeDependencies(dependencies, address);\n    const [cleanedAst] = new CleanOutOfScopeDependenciesTransformer(address.sheet).transformSingleAst(ast, address);\n    this.parser.rememberNewAst(cleanedAst);\n    const cleanedDependencies = filterDependenciesOutOfScope(absoluteDependencies);\n    const size = this.arraySizePredictor.checkArraySize(ast, address);\n    this.dependencyGraph.setFormulaToCell(address, cleanedAst, cleanedDependencies, size, hasVolatileFunction, hasStructuralChangeFunction);\n  }\n  /**\r\n   * Returns true if row number is outside of given sheet.\r\n   * @param {number} row - row number\r\n   * @param {number} sheet - sheet ID number\r\n   */\n  rowEffectivelyNotInSheet(row, sheet) {\n    const height = this.dependencyGraph.addressMapping.getHeight(sheet);\n    return row >= height;\n  }\n  getAndClearContentChanges() {\n    const changes = this.changes;\n    this.changes = ContentChanges.empty();\n    return changes;\n  }\n  forceApplyPostponedTransformations() {\n    this.dependencyGraph.forceApplyPostponedTransformations();\n  }\n  /**\r\n   * Removes multiple rows from sheet. </br>\r\n   * Does nothing if rows are outside of effective sheet size.\r\n   * @param {RowsSpan} rowsToRemove - rows to remove\r\n   */\n  doRemoveRows(rowsToRemove) {\n    if (this.rowEffectivelyNotInSheet(rowsToRemove.rowStart, rowsToRemove.sheet)) {\n      return;\n    }\n    const removedCells = [];\n    for (const [address] of this.dependencyGraph.entriesFromRowsSpan(rowsToRemove)) {\n      removedCells.push({\n        address,\n        cellType: this.getClipboardCell(address)\n      });\n    }\n    const {\n      affectedArrays,\n      contentChanges\n    } = this.dependencyGraph.removeRows(rowsToRemove);\n    this.columnSearch.applyChanges(contentChanges.getChanges());\n    let version = 0;\n    this.stats.measure(StatType.TRANSFORM_ASTS, () => {\n      const transformation = new RemoveRowsTransformer(rowsToRemove);\n      transformation.performEagerTransformations(this.dependencyGraph, this.parser);\n      version = this.lazilyTransformingAstService.addTransformation(transformation);\n    });\n    this.rewriteAffectedArrays(affectedArrays);\n    return {\n      version: version,\n      removedCells,\n      rowFrom: rowsToRemove.rowStart,\n      rowCount: rowsToRemove.numberOfRows\n    };\n  }\n  /**\r\n   * Removes multiple columns from sheet. </br>\r\n   * Does nothing if columns are outside of effective sheet size.\r\n   * @param {ColumnsSpan} columnsToRemove - columns to remove\r\n   */\n  doRemoveColumns(columnsToRemove) {\n    if (this.columnEffectivelyNotInSheet(columnsToRemove.columnStart, columnsToRemove.sheet)) {\n      return;\n    }\n    const removedCells = [];\n    for (const [address] of this.dependencyGraph.entriesFromColumnsSpan(columnsToRemove)) {\n      removedCells.push({\n        address,\n        cellType: this.getClipboardCell(address)\n      });\n    }\n    const {\n      affectedArrays,\n      contentChanges\n    } = this.dependencyGraph.removeColumns(columnsToRemove);\n    this.columnSearch.applyChanges(contentChanges.getChanges());\n    this.columnSearch.removeColumns(columnsToRemove);\n    let version = 0;\n    this.stats.measure(StatType.TRANSFORM_ASTS, () => {\n      const transformation = new RemoveColumnsTransformer(columnsToRemove);\n      transformation.performEagerTransformations(this.dependencyGraph, this.parser);\n      version = this.lazilyTransformingAstService.addTransformation(transformation);\n    });\n    this.rewriteAffectedArrays(affectedArrays);\n    return {\n      version: version,\n      removedCells,\n      columnFrom: columnsToRemove.columnStart,\n      columnCount: columnsToRemove.numberOfColumns\n    };\n  }\n  /**\r\n   * Add multiple rows to sheet. </br>\r\n   * Does nothing if rows are outside of effective sheet size.\r\n   * @param {RowsSpan} addedRows - rows to add\r\n   */\n  doAddRows(addedRows) {\n    if (this.rowEffectivelyNotInSheet(addedRows.rowStart, addedRows.sheet)) {\n      return;\n    }\n    const {\n      affectedArrays\n    } = this.dependencyGraph.addRows(addedRows);\n    this.stats.measure(StatType.TRANSFORM_ASTS, () => {\n      const transformation = new AddRowsTransformer(addedRows);\n      transformation.performEagerTransformations(this.dependencyGraph, this.parser);\n      this.lazilyTransformingAstService.addTransformation(transformation);\n    });\n    this.rewriteAffectedArrays(affectedArrays);\n  }\n  rewriteAffectedArrays(affectedArrays) {\n    for (const arrayVertex of affectedArrays.values()) {\n      if (arrayVertex.array.size.isRef) {\n        continue;\n      }\n      const ast = arrayVertex.getFormula(this.lazilyTransformingAstService);\n      const address = arrayVertex.getAddress(this.lazilyTransformingAstService);\n      const hash = this.parser.computeHashFromAst(ast);\n      this.setFormulaToCellFromCache(hash, address);\n    }\n  }\n  /**\r\n   * Add multiple columns to sheet </br>\r\n   * Does nothing if columns are outside of effective sheet size\r\n   * @param {ColumnsSpan} addedColumns - object containing information about columns to add\r\n   */\n  doAddColumns(addedColumns) {\n    if (this.columnEffectivelyNotInSheet(addedColumns.columnStart, addedColumns.sheet)) {\n      return;\n    }\n    const {\n      affectedArrays,\n      contentChanges\n    } = this.dependencyGraph.addColumns(addedColumns);\n    this.columnSearch.addColumns(addedColumns);\n    this.columnSearch.applyChanges(contentChanges.getChanges());\n    this.stats.measure(StatType.TRANSFORM_ASTS, () => {\n      const transformation = new AddColumnsTransformer(addedColumns);\n      transformation.performEagerTransformations(this.dependencyGraph, this.parser);\n      this.lazilyTransformingAstService.addTransformation(transformation);\n    });\n    this.rewriteAffectedArrays(affectedArrays);\n  }\n  /**\r\n   * Returns true if row number is outside of given sheet.\r\n   * @param {number} column - row number\r\n   * @param {number} sheet - sheet ID number\r\n   */\n  columnEffectivelyNotInSheet(column, sheet) {\n    const width = this.dependencyGraph.addressMapping.getWidth(sheet);\n    return column >= width;\n  }\n  adjustNamedExpressionEdges(namedExpression, expressionName, sheetId) {\n    if (sheetId === undefined) {\n      return;\n    }\n    const {\n      vertex: localVertex,\n      id: maybeLocalVertexId\n    } = this.dependencyGraph.fetchCellOrCreateEmpty(namedExpression.address);\n    const localVertexId = maybeLocalVertexId !== null && maybeLocalVertexId !== void 0 ? maybeLocalVertexId : this.dependencyGraph.graph.getNodeId(localVertex);\n    const globalNamedExpression = this.namedExpressions.workbookNamedExpressionOrPlaceholder(expressionName);\n    const {\n      vertex: globalVertex,\n      id: maybeGlobalVertexId\n    } = this.dependencyGraph.fetchCellOrCreateEmpty(globalNamedExpression.address);\n    const globalVertexId = maybeGlobalVertexId !== null && maybeGlobalVertexId !== void 0 ? maybeGlobalVertexId : this.dependencyGraph.graph.getNodeId(globalVertex);\n    for (const adjacentNode of this.dependencyGraph.graph.adjacentNodes(globalVertex)) {\n      if (adjacentNode instanceof FormulaCellVertex && adjacentNode.getAddress(this.lazilyTransformingAstService).sheet === sheetId) {\n        const ast = adjacentNode.getFormula(this.lazilyTransformingAstService);\n        const formulaAddress = adjacentNode.getAddress(this.lazilyTransformingAstService);\n        const {\n          dependencies\n        } = this.parser.fetchCachedResultForAst(ast);\n        for (const dependency of absolutizeDependencies(dependencies, formulaAddress)) {\n          if (dependency instanceof NamedExpressionDependency && dependency.name.toLowerCase() === namedExpression.displayName.toLowerCase()) {\n            this.dependencyGraph.graph.removeEdge(globalVertexId, adjacentNode);\n            this.dependencyGraph.graph.addEdge(localVertexId, adjacentNode);\n          }\n        }\n      }\n    }\n  }\n  storeNamedExpressionInCell(address, expression) {\n    const parsedCellContent = this.cellContentParser.parse(expression);\n    if (parsedCellContent instanceof CellContent.Formula) {\n      const parsingResult = this.parser.parse(parsedCellContent.formula, simpleCellAddress(-1, 0, 0));\n      if (doesContainRelativeReferences(parsingResult.ast)) {\n        throw new NoRelativeAddressesAllowedError();\n      }\n      const {\n        ast,\n        hasVolatileFunction,\n        hasStructuralChangeFunction,\n        dependencies\n      } = parsingResult;\n      this.dependencyGraph.setFormulaToCell(address, ast, absolutizeDependencies(dependencies, address), ArraySize.scalar(), hasVolatileFunction, hasStructuralChangeFunction);\n    } else if (parsedCellContent instanceof CellContent.Empty) {\n      this.setCellEmpty(address);\n    } else {\n      this.setValueToCell({\n        parsedValue: parsedCellContent.value,\n        rawValue: expression\n      }, address);\n    }\n  }\n  updateNamedExpressionsForMovedCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n    if (sourceLeftCorner.sheet === destinationLeftCorner.sheet) {\n      return [];\n    }\n    const addedGlobalNamedExpressions = [];\n    const targetRange = AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);\n    for (const formulaAddress of targetRange.addresses(this.dependencyGraph)) {\n      const vertex = this.addressMapping.fetchCell(formulaAddress);\n      if (vertex instanceof FormulaCellVertex && formulaAddress.sheet !== sourceLeftCorner.sheet) {\n        const ast = vertex.getFormula(this.lazilyTransformingAstService);\n        const {\n          dependencies\n        } = this.parser.fetchCachedResultForAst(ast);\n        addedGlobalNamedExpressions.push(...this.updateNamedExpressionsForTargetAddress(sourceLeftCorner.sheet, formulaAddress, dependencies));\n      }\n    }\n    return addedGlobalNamedExpressions;\n  }\n  updateNamedExpressionsForTargetAddress(sourceSheet, targetAddress, dependencies) {\n    if (sourceSheet === targetAddress.sheet) {\n      return [];\n    }\n    const addedGlobalNamedExpressions = [];\n    const vertex = this.addressMapping.fetchCell(targetAddress);\n    for (const namedExpressionDependency of absolutizeDependencies(dependencies, targetAddress)) {\n      if (!(namedExpressionDependency instanceof NamedExpressionDependency)) {\n        continue;\n      }\n      const expressionName = namedExpressionDependency.name;\n      const sourceVertex = this.dependencyGraph.fetchNamedExpressionVertex(expressionName, sourceSheet).vertex;\n      const namedExpressionInTargetScope = this.namedExpressions.isExpressionInScope(expressionName, targetAddress.sheet);\n      const targetScopeExpressionVertex = namedExpressionInTargetScope ? this.dependencyGraph.fetchNamedExpressionVertex(expressionName, targetAddress.sheet).vertex : this.copyOrFetchGlobalNamedExpressionVertex(expressionName, sourceVertex, addedGlobalNamedExpressions);\n      if (targetScopeExpressionVertex !== sourceVertex) {\n        this.dependencyGraph.graph.removeEdgeIfExists(sourceVertex, vertex);\n        this.dependencyGraph.graph.addEdge(targetScopeExpressionVertex, vertex);\n      }\n    }\n    return addedGlobalNamedExpressions;\n  }\n  allocateNamedExpressionAddressSpace() {\n    this.dependencyGraph.addressMapping.addSheet(NamedExpressions.SHEET_FOR_WORKBOOK_EXPRESSIONS, new SparseStrategy(0, 0));\n  }\n  copyOrFetchGlobalNamedExpressionVertex(expressionName, sourceVertex, addedNamedExpressions) {\n    let expression = this.namedExpressions.namedExpressionForScope(expressionName);\n    if (expression === undefined) {\n      expression = this.namedExpressions.addNamedExpression(expressionName);\n      addedNamedExpressions.push(expression.normalizeExpressionName());\n      if (sourceVertex instanceof FormulaCellVertex) {\n        const parsingResult = this.parser.fetchCachedResultForAst(sourceVertex.getFormula(this.lazilyTransformingAstService));\n        const {\n          ast,\n          hasVolatileFunction,\n          hasStructuralChangeFunction,\n          dependencies\n        } = parsingResult;\n        this.dependencyGraph.setFormulaToCell(expression.address, ast, absolutizeDependencies(dependencies, expression.address), ArraySize.scalar(), hasVolatileFunction, hasStructuralChangeFunction);\n      } else if (sourceVertex instanceof EmptyCellVertex) {\n        this.setCellEmpty(expression.address);\n      } else if (sourceVertex instanceof ValueCellVertex) {\n        this.setValueToCell(sourceVertex.getValues(), expression.address);\n      }\n    }\n    return this.dependencyGraph.fetchCellOrCreateEmpty(expression.address).vertex;\n  }\n}\nexport function normalizeRemovedIndexes(indexes) {\n  if (indexes.length <= 1) {\n    return indexes;\n  }\n  const sorted = [...indexes].sort(([a], [b]) => a - b);\n  /* merge overlapping and adjacent indexes */\n  const merged = sorted.reduce((acc, [startIndex, amount]) => {\n    const previous = acc[acc.length - 1];\n    const lastIndex = previous[0] + previous[1];\n    if (startIndex <= lastIndex) {\n      previous[1] += Math.max(0, amount - (lastIndex - startIndex));\n    } else {\n      acc.push([startIndex, amount]);\n    }\n    return acc;\n  }, [sorted[0]]);\n  /* shift further indexes */\n  let shift = 0;\n  for (let i = 0; i < merged.length; ++i) {\n    merged[i][0] -= shift;\n    shift += merged[i][1];\n  }\n  return merged;\n}\nexport function normalizeAddedIndexes(indexes) {\n  if (indexes.length <= 1) {\n    return indexes;\n  }\n  const sorted = [...indexes].sort(([a], [b]) => a - b);\n  /* merge indexes with same start */\n  const merged = sorted.reduce((acc, [startIndex, amount]) => {\n    const previous = acc[acc.length - 1];\n    if (startIndex === previous[0]) {\n      previous[1] = Math.max(previous[1], amount);\n    } else {\n      acc.push([startIndex, amount]);\n    }\n    return acc;\n  }, [sorted[0]]);\n  /* shift further indexes */\n  let shift = 0;\n  for (let i = 0; i < merged.length; ++i) {\n    merged[i][0] += shift;\n    shift += merged[i][1];\n  }\n  return merged;\n}\nfunction isPositiveInteger(n) {\n  return Number.isInteger(n) && n > 0;\n}\nfunction isRowOrColumnRange(leftCorner, width, height) {\n  return leftCorner.row === 0 && isPositiveInteger(width) && height === Number.POSITIVE_INFINITY || leftCorner.col === 0 && isPositiveInteger(height) && width === Number.POSITIVE_INFINITY;\n}","map":{"version":3,"names":["AbsoluteCellRange","absolutizeDependencies","filterDependenciesOutOfScope","ArraySize","equalSimpleCellAddress","invalidSimpleCellAddress","simpleCellAddress","CellContent","ClipboardCellType","ContentChanges","ArrayVertex","EmptyCellVertex","FormulaCellVertex","ParsingErrorVertex","SparseStrategy","ValueCellVertex","FormulaVertex","AddColumnsTransformer","AddRowsTransformer","CleanOutOfScopeDependenciesTransformer","MoveCellsTransformer","RemoveColumnsTransformer","RemoveRowsTransformer","RemoveSheetTransformer","InvalidArgumentsError","NamedExpressionDoesNotExistError","NoRelativeAddressesAllowedError","SheetSizeLimitExceededError","SourceLocationHasArrayError","TargetLocationHasArrayError","EmptyValue","getRawValue","doesContainRelativeReferences","NamedExpressions","NamedExpressionDependency","ParsingErrorType","findBoundaries","ColumnsSpan","RowsSpan","StatType","RemoveRowsCommand","constructor","sheet","indexes","normalizedIndexes","normalizeRemovedIndexes","rowsSpans","map","normalizedIndex","fromNumberOfRows","AddRowsCommand","normalizeAddedIndexes","AddColumnsCommand","columnsSpans","fromNumberOfColumns","RemoveColumnsCommand","Operations","config","dependencyGraph","columnSearch","cellContentParser","parser","stats","lazilyTransformingAstService","namedExpressions","arraySizePredictor","changes","empty","allocateNamedExpressionAddressSpace","maxColumns","maxRows","sheetMapping","addressMapping","removeRows","cmd","rowsRemovals","rowsToRemove","rowsRemoval","doRemoveRows","push","addRows","addedRows","doAddRows","addColumns","addedColumns","doAddColumns","removeColumns","columnsRemovals","columnsToRemove","columnsRemoval","doRemoveColumns","removeSheet","sheetId","version","measure","TRANSFORM_ASTS","transformation","performEagerTransformations","addTransformation","scopedNamedExpressions","getAllNamedExpressionsForScope","namedExpression","removeNamedExpression","normalizeExpressionName","removeSheetByName","sheetName","fetch","clearSheet","addSheet","name","autoAddSheet","fetchDisplayName","renameSheet","newName","moveRows","startRow","numberOfRows","targetRow","rowsToAdd","beginCombinedMode","startAddress","targetAddress","moveCells","Number","POSITIVE_INFINITY","commitCombinedMode","moveColumns","startColumn","numberOfColumns","targetColumn","columnsToAdd","sourceLeftCorner","width","height","destinationLeftCorner","ensureItIsPossibleToMoveCells","sourceRange","spanFrom","targetRange","toRight","col","toBottom","row","toSheet","currentDataAtTarget","getRangeClipboardCells","valuesToRemove","rawValuesFromRange","removeValues","valuesToMove","moveValues","addedGlobalNamedExpressions","updateNamedExpressionsForMovedCells","overwrittenCellsData","setRowOrder","rowMapping","buffer","oldContent","source","target","rowRange","Infinity","concat","cell","forEach","restoreClipboardCells","values","setColumnOrder","columnMapping","column","_col","addNamedExpression","expressionName","expression","options","storeNamedExpressionInCell","address","adjustNamedExpressionEdges","restoreNamedExpression","content","displayName","restoreCell","restoredNamedExpression","changeNamedExpressionExpression","newExpression","namedExpressionForScope","oldNamedExpression","copy","getClipboardCell","remove","undefined","globalNamedExpression","workbookNamedExpressionOrPlaceholder","exchangeNode","setCellEmpty","isPositiveInteger","isRowOrColumnRange","hasSheetWithId","exceedsSheetSizeLimits","arrayMapping","isFormulaArrayInRange","sourceSheetId","cells","addedNamedExpressions","clipboardCell","type","FORMULA","dependencies","fetchCachedResult","hash","updateNamedExpressionsForTargetAddress","VALUE","setValueToCell","setFormulaToCellFromCache","EMPTY","PARSING_ERROR","setParsingErrorToCell","rawInput","errors","getOldContent","vertex","getCell","Object","assign","getValues","getAddress","computeHashFromAst","getFormula","Error","val","getArrayCellValue","parsedValue","rawValue","getArrayCellRawValue","getSheetClipboardCells","sheetHeight","getSheetHeight","sheetWidth","getSheetWidth","arr","Array","i","j","range","result","addresses","setCellContent","newCellContent","parsedCellContent","parse","Formula","parserResult","formula","ast","length","size","checkArraySize","setFormulaToCell","error","message","parsingError","InvalidRangeSize","Empty","value","setSheetContent","newSheetContent","oldValue","getCellValue","arrayChanges","applyChanges","getChanges","addAll","addChange","hasVolatileFunction","hasStructuralChangeFunction","change","filter","isArrayInternalCell","formulaHash","absoluteDependencies","cleanedAst","transformSingleAst","rememberNewAst","cleanedDependencies","rowEffectivelyNotInSheet","getHeight","getAndClearContentChanges","forceApplyPostponedTransformations","rowStart","removedCells","entriesFromRowsSpan","cellType","affectedArrays","contentChanges","rewriteAffectedArrays","rowFrom","rowCount","columnEffectivelyNotInSheet","columnStart","entriesFromColumnsSpan","columnFrom","columnCount","arrayVertex","array","isRef","getWidth","localVertex","id","maybeLocalVertexId","fetchCellOrCreateEmpty","localVertexId","graph","getNodeId","globalVertex","maybeGlobalVertexId","globalVertexId","adjacentNode","adjacentNodes","formulaAddress","fetchCachedResultForAst","dependency","toLowerCase","removeEdge","addEdge","parsingResult","scalar","fetchCell","sourceSheet","namedExpressionDependency","sourceVertex","fetchNamedExpressionVertex","namedExpressionInTargetScope","isExpressionInScope","targetScopeExpressionVertex","copyOrFetchGlobalNamedExpressionVertex","removeEdgeIfExists","SHEET_FOR_WORKBOOK_EXPRESSIONS","sorted","sort","a","b","merged","reduce","acc","startIndex","amount","previous","lastIndex","Math","max","shift","n","isInteger","leftCorner"],"sources":["C:/spreadsheet-clone/node_modules/hyperformula/es/Operations.mjs"],"sourcesContent":["/**\r\n * @license\r\n * Copyright (c) 2025 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from \"./AbsoluteCellRange.mjs\";\nimport { absolutizeDependencies, filterDependenciesOutOfScope } from \"./absolutizeDependencies.mjs\";\nimport { ArraySize } from \"./ArraySize.mjs\";\nimport { equalSimpleCellAddress, invalidSimpleCellAddress, simpleCellAddress } from \"./Cell.mjs\";\nimport { CellContent } from \"./CellContentParser.mjs\";\nimport { ClipboardCellType } from \"./ClipboardOperations.mjs\";\nimport { ContentChanges } from \"./ContentChanges.mjs\";\nimport { ArrayVertex, EmptyCellVertex, FormulaCellVertex, ParsingErrorVertex, SparseStrategy, ValueCellVertex } from \"./DependencyGraph/index.mjs\";\nimport { FormulaVertex } from \"./DependencyGraph/FormulaCellVertex.mjs\";\nimport { AddColumnsTransformer } from \"./dependencyTransformers/AddColumnsTransformer.mjs\";\nimport { AddRowsTransformer } from \"./dependencyTransformers/AddRowsTransformer.mjs\";\nimport { CleanOutOfScopeDependenciesTransformer } from \"./dependencyTransformers/CleanOutOfScopeDependenciesTransformer.mjs\";\nimport { MoveCellsTransformer } from \"./dependencyTransformers/MoveCellsTransformer.mjs\";\nimport { RemoveColumnsTransformer } from \"./dependencyTransformers/RemoveColumnsTransformer.mjs\";\nimport { RemoveRowsTransformer } from \"./dependencyTransformers/RemoveRowsTransformer.mjs\";\nimport { RemoveSheetTransformer } from \"./dependencyTransformers/RemoveSheetTransformer.mjs\";\nimport { InvalidArgumentsError, NamedExpressionDoesNotExistError, NoRelativeAddressesAllowedError, SheetSizeLimitExceededError, SourceLocationHasArrayError, TargetLocationHasArrayError } from \"./errors.mjs\";\nimport { EmptyValue, getRawValue } from \"./interpreter/InterpreterValue.mjs\";\nimport { doesContainRelativeReferences, NamedExpressions } from \"./NamedExpressions.mjs\";\nimport { NamedExpressionDependency, ParsingErrorType } from \"./parser/index.mjs\";\nimport { findBoundaries } from \"./Sheet.mjs\";\nimport { ColumnsSpan, RowsSpan } from \"./Span.mjs\";\nimport { StatType } from \"./statistics/index.mjs\";\nexport class RemoveRowsCommand {\n  constructor(sheet, indexes) {\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n  normalizedIndexes() {\n    return normalizeRemovedIndexes(this.indexes);\n  }\n  rowsSpans() {\n    return this.normalizedIndexes().map(normalizedIndex => RowsSpan.fromNumberOfRows(this.sheet, normalizedIndex[0], normalizedIndex[1]));\n  }\n}\nexport class AddRowsCommand {\n  constructor(sheet, indexes) {\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n  normalizedIndexes() {\n    return normalizeAddedIndexes(this.indexes);\n  }\n  rowsSpans() {\n    return this.normalizedIndexes().map(normalizedIndex => RowsSpan.fromNumberOfRows(this.sheet, normalizedIndex[0], normalizedIndex[1]));\n  }\n}\nexport class AddColumnsCommand {\n  constructor(sheet, indexes) {\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n  normalizedIndexes() {\n    return normalizeAddedIndexes(this.indexes);\n  }\n  columnsSpans() {\n    return this.normalizedIndexes().map(normalizedIndex => ColumnsSpan.fromNumberOfColumns(this.sheet, normalizedIndex[0], normalizedIndex[1]));\n  }\n}\nexport class RemoveColumnsCommand {\n  constructor(sheet, indexes) {\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n  normalizedIndexes() {\n    return normalizeRemovedIndexes(this.indexes);\n  }\n  columnsSpans() {\n    return this.normalizedIndexes().map(normalizedIndex => ColumnsSpan.fromNumberOfColumns(this.sheet, normalizedIndex[0], normalizedIndex[1]));\n  }\n}\nexport class Operations {\n  constructor(config, dependencyGraph, columnSearch, cellContentParser, parser, stats, lazilyTransformingAstService, namedExpressions, arraySizePredictor) {\n    this.dependencyGraph = dependencyGraph;\n    this.columnSearch = columnSearch;\n    this.cellContentParser = cellContentParser;\n    this.parser = parser;\n    this.stats = stats;\n    this.lazilyTransformingAstService = lazilyTransformingAstService;\n    this.namedExpressions = namedExpressions;\n    this.arraySizePredictor = arraySizePredictor;\n    this.changes = ContentChanges.empty();\n    this.allocateNamedExpressionAddressSpace();\n    this.maxColumns = config.maxColumns;\n    this.maxRows = config.maxRows;\n  }\n  get sheetMapping() {\n    return this.dependencyGraph.sheetMapping;\n  }\n  get addressMapping() {\n    return this.dependencyGraph.addressMapping;\n  }\n  removeRows(cmd) {\n    const rowsRemovals = [];\n    for (const rowsToRemove of cmd.rowsSpans()) {\n      const rowsRemoval = this.doRemoveRows(rowsToRemove);\n      if (rowsRemoval) {\n        rowsRemovals.push(rowsRemoval);\n      }\n    }\n    return rowsRemovals;\n  }\n  addRows(cmd) {\n    for (const addedRows of cmd.rowsSpans()) {\n      this.doAddRows(addedRows);\n    }\n  }\n  addColumns(cmd) {\n    for (const addedColumns of cmd.columnsSpans()) {\n      this.doAddColumns(addedColumns);\n    }\n  }\n  removeColumns(cmd) {\n    const columnsRemovals = [];\n    for (const columnsToRemove of cmd.columnsSpans()) {\n      const columnsRemoval = this.doRemoveColumns(columnsToRemove);\n      if (columnsRemoval) {\n        columnsRemovals.push(columnsRemoval);\n      }\n    }\n    return columnsRemovals;\n  }\n  removeSheet(sheetId) {\n    this.dependencyGraph.removeSheet(sheetId);\n    let version = 0;\n    this.stats.measure(StatType.TRANSFORM_ASTS, () => {\n      const transformation = new RemoveSheetTransformer(sheetId);\n      transformation.performEagerTransformations(this.dependencyGraph, this.parser);\n      version = this.lazilyTransformingAstService.addTransformation(transformation);\n    });\n    this.sheetMapping.removeSheet(sheetId);\n    this.columnSearch.removeSheet(sheetId);\n    const scopedNamedExpressions = this.namedExpressions.getAllNamedExpressionsForScope(sheetId).map(namedExpression => this.removeNamedExpression(namedExpression.normalizeExpressionName(), sheetId));\n    return {\n      version: version,\n      scopedNamedExpressions\n    };\n  }\n  removeSheetByName(sheetName) {\n    const sheetId = this.sheetMapping.fetch(sheetName);\n    return this.removeSheet(sheetId);\n  }\n  clearSheet(sheetId) {\n    this.dependencyGraph.clearSheet(sheetId);\n    this.columnSearch.removeSheet(sheetId);\n  }\n  addSheet(name) {\n    const sheetId = this.sheetMapping.addSheet(name);\n    const sheet = [];\n    this.dependencyGraph.addressMapping.autoAddSheet(sheetId, findBoundaries(sheet));\n    return this.sheetMapping.fetchDisplayName(sheetId);\n  }\n  renameSheet(sheetId, newName) {\n    return this.sheetMapping.renameSheet(sheetId, newName);\n  }\n  moveRows(sheet, startRow, numberOfRows, targetRow) {\n    const rowsToAdd = RowsSpan.fromNumberOfRows(sheet, targetRow, numberOfRows);\n    this.lazilyTransformingAstService.beginCombinedMode(sheet);\n    this.doAddRows(rowsToAdd);\n    if (targetRow < startRow) {\n      startRow += numberOfRows;\n    }\n    const startAddress = simpleCellAddress(sheet, 0, startRow);\n    const targetAddress = simpleCellAddress(sheet, 0, targetRow);\n    this.moveCells(startAddress, Number.POSITIVE_INFINITY, numberOfRows, targetAddress);\n    const rowsToRemove = RowsSpan.fromNumberOfRows(sheet, startRow, numberOfRows);\n    this.doRemoveRows(rowsToRemove);\n    return this.lazilyTransformingAstService.commitCombinedMode();\n  }\n  moveColumns(sheet, startColumn, numberOfColumns, targetColumn) {\n    const columnsToAdd = ColumnsSpan.fromNumberOfColumns(sheet, targetColumn, numberOfColumns);\n    this.lazilyTransformingAstService.beginCombinedMode(sheet);\n    this.doAddColumns(columnsToAdd);\n    if (targetColumn < startColumn) {\n      startColumn += numberOfColumns;\n    }\n    const startAddress = simpleCellAddress(sheet, startColumn, 0);\n    const targetAddress = simpleCellAddress(sheet, targetColumn, 0);\n    this.moveCells(startAddress, numberOfColumns, Number.POSITIVE_INFINITY, targetAddress);\n    const columnsToRemove = ColumnsSpan.fromNumberOfColumns(sheet, startColumn, numberOfColumns);\n    this.doRemoveColumns(columnsToRemove);\n    return this.lazilyTransformingAstService.commitCombinedMode();\n  }\n  moveCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n    this.ensureItIsPossibleToMoveCells(sourceLeftCorner, width, height, destinationLeftCorner);\n    const sourceRange = AbsoluteCellRange.spanFrom(sourceLeftCorner, width, height);\n    const targetRange = AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);\n    const toRight = destinationLeftCorner.col - sourceLeftCorner.col;\n    const toBottom = destinationLeftCorner.row - sourceLeftCorner.row;\n    const toSheet = destinationLeftCorner.sheet;\n    const currentDataAtTarget = this.getRangeClipboardCells(targetRange);\n    const valuesToRemove = this.dependencyGraph.rawValuesFromRange(targetRange);\n    this.columnSearch.removeValues(valuesToRemove);\n    const valuesToMove = this.dependencyGraph.rawValuesFromRange(sourceRange);\n    this.columnSearch.moveValues(valuesToMove, toRight, toBottom, toSheet);\n    let version = 0;\n    this.stats.measure(StatType.TRANSFORM_ASTS, () => {\n      const transformation = new MoveCellsTransformer(sourceRange, toRight, toBottom, toSheet);\n      transformation.performEagerTransformations(this.dependencyGraph, this.parser);\n      version = this.lazilyTransformingAstService.addTransformation(transformation);\n    });\n    this.dependencyGraph.moveCells(sourceRange, toRight, toBottom, toSheet);\n    const addedGlobalNamedExpressions = this.updateNamedExpressionsForMovedCells(sourceLeftCorner, width, height, destinationLeftCorner);\n    return {\n      version: version,\n      overwrittenCellsData: currentDataAtTarget,\n      addedGlobalNamedExpressions: addedGlobalNamedExpressions\n    };\n  }\n  setRowOrder(sheetId, rowMapping) {\n    const buffer = [];\n    let oldContent = [];\n    for (const [source, target] of rowMapping) {\n      if (source !== target) {\n        const rowRange = AbsoluteCellRange.spanFrom({\n          sheet: sheetId,\n          col: 0,\n          row: source\n        }, Infinity, 1);\n        const row = this.getRangeClipboardCells(rowRange);\n        oldContent = oldContent.concat(row);\n        buffer.push(row.map(([{\n          sheet,\n          col\n        }, cell]) => [{\n          sheet,\n          col,\n          row: target\n        }, cell]));\n      }\n    }\n    buffer.forEach(row => this.restoreClipboardCells(sheetId, row.values()));\n    return oldContent;\n  }\n  setColumnOrder(sheetId, columnMapping) {\n    const buffer = [];\n    let oldContent = [];\n    for (const [source, target] of columnMapping) {\n      if (source !== target) {\n        const rowRange = AbsoluteCellRange.spanFrom({\n          sheet: sheetId,\n          col: source,\n          row: 0\n        }, 1, Infinity);\n        const column = this.getRangeClipboardCells(rowRange);\n        oldContent = oldContent.concat(column);\n        buffer.push(column.map(([{\n          sheet,\n          col: _col,\n          row\n        }, cell]) => [{\n          sheet,\n          col: target,\n          row\n        }, cell]));\n      }\n    }\n    buffer.forEach(column => this.restoreClipboardCells(sheetId, column.values()));\n    return oldContent;\n  }\n  addNamedExpression(expressionName, expression, sheetId, options) {\n    const namedExpression = this.namedExpressions.addNamedExpression(expressionName, sheetId, options);\n    this.storeNamedExpressionInCell(namedExpression.address, expression);\n    this.adjustNamedExpressionEdges(namedExpression, expressionName, sheetId);\n  }\n  restoreNamedExpression(namedExpression, content, sheetId) {\n    const expressionName = namedExpression.displayName;\n    this.restoreCell(namedExpression.address, content);\n    const restoredNamedExpression = this.namedExpressions.restoreNamedExpression(namedExpression, sheetId);\n    this.adjustNamedExpressionEdges(restoredNamedExpression, expressionName, sheetId);\n  }\n  changeNamedExpressionExpression(expressionName, newExpression, sheetId, options) {\n    const namedExpression = this.namedExpressions.namedExpressionForScope(expressionName, sheetId);\n    if (!namedExpression) {\n      throw new NamedExpressionDoesNotExistError(expressionName);\n    }\n    const oldNamedExpression = namedExpression.copy();\n    namedExpression.options = options;\n    const content = this.getClipboardCell(namedExpression.address);\n    this.storeNamedExpressionInCell(namedExpression.address, newExpression);\n    return [oldNamedExpression, content];\n  }\n  removeNamedExpression(expressionName, sheetId) {\n    const namedExpression = this.namedExpressions.namedExpressionForScope(expressionName, sheetId);\n    if (!namedExpression) {\n      throw new NamedExpressionDoesNotExistError(expressionName);\n    }\n    this.namedExpressions.remove(namedExpression.displayName, sheetId);\n    const content = this.getClipboardCell(namedExpression.address);\n    if (sheetId !== undefined) {\n      const globalNamedExpression = this.namedExpressions.workbookNamedExpressionOrPlaceholder(expressionName);\n      this.dependencyGraph.exchangeNode(namedExpression.address, globalNamedExpression.address);\n    } else {\n      this.dependencyGraph.setCellEmpty(namedExpression.address);\n    }\n    return [namedExpression, content];\n  }\n  ensureItIsPossibleToMoveCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n    if (invalidSimpleCellAddress(sourceLeftCorner) || !(isPositiveInteger(width) && isPositiveInteger(height) || isRowOrColumnRange(sourceLeftCorner, width, height)) || invalidSimpleCellAddress(destinationLeftCorner) || !this.sheetMapping.hasSheetWithId(sourceLeftCorner.sheet) || !this.sheetMapping.hasSheetWithId(destinationLeftCorner.sheet)) {\n      throw new InvalidArgumentsError('a valid range of cells to move.');\n    }\n    const sourceRange = AbsoluteCellRange.spanFrom(sourceLeftCorner, width, height);\n    const targetRange = AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);\n    if (targetRange.exceedsSheetSizeLimits(this.maxColumns, this.maxRows)) {\n      throw new SheetSizeLimitExceededError();\n    }\n    if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(sourceRange)) {\n      throw new SourceLocationHasArrayError();\n    }\n    if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(targetRange)) {\n      throw new TargetLocationHasArrayError();\n    }\n  }\n  restoreClipboardCells(sourceSheetId, cells) {\n    const addedNamedExpressions = [];\n    for (const [address, clipboardCell] of cells) {\n      this.restoreCell(address, clipboardCell);\n      if (clipboardCell.type === ClipboardCellType.FORMULA) {\n        const {\n          dependencies\n        } = this.parser.fetchCachedResult(clipboardCell.hash);\n        addedNamedExpressions.push(...this.updateNamedExpressionsForTargetAddress(sourceSheetId, address, dependencies));\n      }\n    }\n    return addedNamedExpressions;\n  }\n  /**\r\n   * Restores a single cell.\r\n   * @param {SimpleCellAddress} address\r\n   * @param {ClipboardCell} clipboardCell\r\n   */\n  restoreCell(address, clipboardCell) {\n    switch (clipboardCell.type) {\n      case ClipboardCellType.VALUE:\n        {\n          this.setValueToCell(clipboardCell, address);\n          break;\n        }\n      case ClipboardCellType.FORMULA:\n        {\n          this.setFormulaToCellFromCache(clipboardCell.hash, address);\n          break;\n        }\n      case ClipboardCellType.EMPTY:\n        {\n          this.setCellEmpty(address);\n          break;\n        }\n      case ClipboardCellType.PARSING_ERROR:\n        {\n          this.setParsingErrorToCell(clipboardCell.rawInput, clipboardCell.errors, address);\n          break;\n        }\n    }\n  }\n  getOldContent(address) {\n    const vertex = this.dependencyGraph.getCell(address);\n    if (vertex === undefined || vertex instanceof EmptyCellVertex) {\n      return [address, {\n        type: ClipboardCellType.EMPTY\n      }];\n    } else if (vertex instanceof ValueCellVertex) {\n      return [address, Object.assign({\n        type: ClipboardCellType.VALUE\n      }, vertex.getValues())];\n    } else if (vertex instanceof FormulaVertex) {\n      return [vertex.getAddress(this.lazilyTransformingAstService), {\n        type: ClipboardCellType.FORMULA,\n        hash: this.parser.computeHashFromAst(vertex.getFormula(this.lazilyTransformingAstService))\n      }];\n    } else if (vertex instanceof ParsingErrorVertex) {\n      return [address, {\n        type: ClipboardCellType.PARSING_ERROR,\n        rawInput: vertex.rawInput,\n        errors: vertex.errors\n      }];\n    }\n    throw Error('Trying to copy unsupported type');\n  }\n  getClipboardCell(address) {\n    const vertex = this.dependencyGraph.getCell(address);\n    if (vertex === undefined || vertex instanceof EmptyCellVertex) {\n      return {\n        type: ClipboardCellType.EMPTY\n      };\n    } else if (vertex instanceof ValueCellVertex) {\n      return Object.assign({\n        type: ClipboardCellType.VALUE\n      }, vertex.getValues());\n    } else if (vertex instanceof ArrayVertex) {\n      const val = vertex.getArrayCellValue(address);\n      if (val === EmptyValue) {\n        return {\n          type: ClipboardCellType.EMPTY\n        };\n      }\n      return {\n        type: ClipboardCellType.VALUE,\n        parsedValue: val,\n        rawValue: vertex.getArrayCellRawValue(address)\n      };\n    } else if (vertex instanceof FormulaCellVertex) {\n      return {\n        type: ClipboardCellType.FORMULA,\n        hash: this.parser.computeHashFromAst(vertex.getFormula(this.lazilyTransformingAstService))\n      };\n    } else if (vertex instanceof ParsingErrorVertex) {\n      return {\n        type: ClipboardCellType.PARSING_ERROR,\n        rawInput: vertex.rawInput,\n        errors: vertex.errors\n      };\n    }\n    throw Error('Trying to copy unsupported type');\n  }\n  getSheetClipboardCells(sheet) {\n    const sheetHeight = this.dependencyGraph.getSheetHeight(sheet);\n    const sheetWidth = this.dependencyGraph.getSheetWidth(sheet);\n    const arr = new Array(sheetHeight);\n    for (let i = 0; i < sheetHeight; i++) {\n      arr[i] = new Array(sheetWidth);\n      for (let j = 0; j < sheetWidth; j++) {\n        const address = simpleCellAddress(sheet, j, i);\n        arr[i][j] = this.getClipboardCell(address);\n      }\n    }\n    return arr;\n  }\n  getRangeClipboardCells(range) {\n    const result = [];\n    for (const address of range.addresses(this.dependencyGraph)) {\n      result.push([address, this.getClipboardCell(address)]);\n    }\n    return result;\n  }\n  setCellContent(address, newCellContent) {\n    const parsedCellContent = this.cellContentParser.parse(newCellContent);\n    const oldContent = this.getOldContent(address);\n    if (parsedCellContent instanceof CellContent.Formula) {\n      const parserResult = this.parser.parse(parsedCellContent.formula, address);\n      const {\n        ast,\n        errors\n      } = parserResult;\n      if (errors.length > 0) {\n        this.setParsingErrorToCell(parsedCellContent.formula, errors, address);\n      } else {\n        try {\n          const size = this.arraySizePredictor.checkArraySize(ast, address);\n          if (size.width <= 0 || size.height <= 0) {\n            throw Error('Incorrect array size');\n          }\n          this.setFormulaToCell(address, size, parserResult);\n        } catch (error) {\n          if (!error.message) {\n            throw error;\n          }\n          const parsingError = {\n            type: ParsingErrorType.InvalidRangeSize,\n            message: 'Invalid range size.'\n          };\n          this.setParsingErrorToCell(parsedCellContent.formula, [parsingError], address);\n        }\n      }\n    } else if (parsedCellContent instanceof CellContent.Empty) {\n      this.setCellEmpty(address);\n    } else {\n      this.setValueToCell({\n        parsedValue: parsedCellContent.value,\n        rawValue: newCellContent\n      }, address);\n    }\n    return oldContent;\n  }\n  setSheetContent(sheetId, newSheetContent) {\n    this.clearSheet(sheetId);\n    for (let i = 0; i < newSheetContent.length; i++) {\n      for (let j = 0; j < newSheetContent[i].length; j++) {\n        const address = simpleCellAddress(sheetId, j, i);\n        this.setCellContent(address, newSheetContent[i][j]);\n      }\n    }\n  }\n  setParsingErrorToCell(rawInput, errors, address) {\n    const oldValue = this.dependencyGraph.getCellValue(address);\n    const vertex = new ParsingErrorVertex(errors, rawInput);\n    const arrayChanges = this.dependencyGraph.setParsingErrorToCell(address, vertex);\n    this.columnSearch.remove(getRawValue(oldValue), address);\n    this.columnSearch.applyChanges(arrayChanges.getChanges());\n    this.changes.addAll(arrayChanges);\n    this.changes.addChange(vertex.getCellValue(), address);\n  }\n  setFormulaToCell(address, size, {\n    ast,\n    hasVolatileFunction,\n    hasStructuralChangeFunction,\n    dependencies\n  }) {\n    const oldValue = this.dependencyGraph.getCellValue(address);\n    const arrayChanges = this.dependencyGraph.setFormulaToCell(address, ast, absolutizeDependencies(dependencies, address), size, hasVolatileFunction, hasStructuralChangeFunction);\n    this.columnSearch.remove(getRawValue(oldValue), address);\n    this.columnSearch.applyChanges(arrayChanges.getChanges());\n    this.changes.addAll(arrayChanges);\n  }\n  setValueToCell(value, address) {\n    const oldValue = this.dependencyGraph.getCellValue(address);\n    const arrayChanges = this.dependencyGraph.setValueToCell(address, value);\n    this.columnSearch.change(getRawValue(oldValue), getRawValue(value.parsedValue), address);\n    this.columnSearch.applyChanges(arrayChanges.getChanges().filter(change => !equalSimpleCellAddress(change.address, address)));\n    this.changes.addAll(arrayChanges);\n    this.changes.addChange(value.parsedValue, address);\n  }\n  setCellEmpty(address) {\n    if (this.dependencyGraph.isArrayInternalCell(address)) {\n      return;\n    }\n    const oldValue = this.dependencyGraph.getCellValue(address);\n    const arrayChanges = this.dependencyGraph.setCellEmpty(address);\n    this.columnSearch.remove(getRawValue(oldValue), address);\n    this.columnSearch.applyChanges(arrayChanges.getChanges());\n    this.changes.addAll(arrayChanges);\n    this.changes.addChange(EmptyValue, address);\n  }\n  setFormulaToCellFromCache(formulaHash, address) {\n    const {\n      ast,\n      hasVolatileFunction,\n      hasStructuralChangeFunction,\n      dependencies\n    } = this.parser.fetchCachedResult(formulaHash);\n    const absoluteDependencies = absolutizeDependencies(dependencies, address);\n    const [cleanedAst] = new CleanOutOfScopeDependenciesTransformer(address.sheet).transformSingleAst(ast, address);\n    this.parser.rememberNewAst(cleanedAst);\n    const cleanedDependencies = filterDependenciesOutOfScope(absoluteDependencies);\n    const size = this.arraySizePredictor.checkArraySize(ast, address);\n    this.dependencyGraph.setFormulaToCell(address, cleanedAst, cleanedDependencies, size, hasVolatileFunction, hasStructuralChangeFunction);\n  }\n  /**\r\n   * Returns true if row number is outside of given sheet.\r\n   * @param {number} row - row number\r\n   * @param {number} sheet - sheet ID number\r\n   */\n  rowEffectivelyNotInSheet(row, sheet) {\n    const height = this.dependencyGraph.addressMapping.getHeight(sheet);\n    return row >= height;\n  }\n  getAndClearContentChanges() {\n    const changes = this.changes;\n    this.changes = ContentChanges.empty();\n    return changes;\n  }\n  forceApplyPostponedTransformations() {\n    this.dependencyGraph.forceApplyPostponedTransformations();\n  }\n  /**\r\n   * Removes multiple rows from sheet. </br>\r\n   * Does nothing if rows are outside of effective sheet size.\r\n   * @param {RowsSpan} rowsToRemove - rows to remove\r\n   */\n  doRemoveRows(rowsToRemove) {\n    if (this.rowEffectivelyNotInSheet(rowsToRemove.rowStart, rowsToRemove.sheet)) {\n      return;\n    }\n    const removedCells = [];\n    for (const [address] of this.dependencyGraph.entriesFromRowsSpan(rowsToRemove)) {\n      removedCells.push({\n        address,\n        cellType: this.getClipboardCell(address)\n      });\n    }\n    const {\n      affectedArrays,\n      contentChanges\n    } = this.dependencyGraph.removeRows(rowsToRemove);\n    this.columnSearch.applyChanges(contentChanges.getChanges());\n    let version = 0;\n    this.stats.measure(StatType.TRANSFORM_ASTS, () => {\n      const transformation = new RemoveRowsTransformer(rowsToRemove);\n      transformation.performEagerTransformations(this.dependencyGraph, this.parser);\n      version = this.lazilyTransformingAstService.addTransformation(transformation);\n    });\n    this.rewriteAffectedArrays(affectedArrays);\n    return {\n      version: version,\n      removedCells,\n      rowFrom: rowsToRemove.rowStart,\n      rowCount: rowsToRemove.numberOfRows\n    };\n  }\n  /**\r\n   * Removes multiple columns from sheet. </br>\r\n   * Does nothing if columns are outside of effective sheet size.\r\n   * @param {ColumnsSpan} columnsToRemove - columns to remove\r\n   */\n  doRemoveColumns(columnsToRemove) {\n    if (this.columnEffectivelyNotInSheet(columnsToRemove.columnStart, columnsToRemove.sheet)) {\n      return;\n    }\n    const removedCells = [];\n    for (const [address] of this.dependencyGraph.entriesFromColumnsSpan(columnsToRemove)) {\n      removedCells.push({\n        address,\n        cellType: this.getClipboardCell(address)\n      });\n    }\n    const {\n      affectedArrays,\n      contentChanges\n    } = this.dependencyGraph.removeColumns(columnsToRemove);\n    this.columnSearch.applyChanges(contentChanges.getChanges());\n    this.columnSearch.removeColumns(columnsToRemove);\n    let version = 0;\n    this.stats.measure(StatType.TRANSFORM_ASTS, () => {\n      const transformation = new RemoveColumnsTransformer(columnsToRemove);\n      transformation.performEagerTransformations(this.dependencyGraph, this.parser);\n      version = this.lazilyTransformingAstService.addTransformation(transformation);\n    });\n    this.rewriteAffectedArrays(affectedArrays);\n    return {\n      version: version,\n      removedCells,\n      columnFrom: columnsToRemove.columnStart,\n      columnCount: columnsToRemove.numberOfColumns\n    };\n  }\n  /**\r\n   * Add multiple rows to sheet. </br>\r\n   * Does nothing if rows are outside of effective sheet size.\r\n   * @param {RowsSpan} addedRows - rows to add\r\n   */\n  doAddRows(addedRows) {\n    if (this.rowEffectivelyNotInSheet(addedRows.rowStart, addedRows.sheet)) {\n      return;\n    }\n    const {\n      affectedArrays\n    } = this.dependencyGraph.addRows(addedRows);\n    this.stats.measure(StatType.TRANSFORM_ASTS, () => {\n      const transformation = new AddRowsTransformer(addedRows);\n      transformation.performEagerTransformations(this.dependencyGraph, this.parser);\n      this.lazilyTransformingAstService.addTransformation(transformation);\n    });\n    this.rewriteAffectedArrays(affectedArrays);\n  }\n  rewriteAffectedArrays(affectedArrays) {\n    for (const arrayVertex of affectedArrays.values()) {\n      if (arrayVertex.array.size.isRef) {\n        continue;\n      }\n      const ast = arrayVertex.getFormula(this.lazilyTransformingAstService);\n      const address = arrayVertex.getAddress(this.lazilyTransformingAstService);\n      const hash = this.parser.computeHashFromAst(ast);\n      this.setFormulaToCellFromCache(hash, address);\n    }\n  }\n  /**\r\n   * Add multiple columns to sheet </br>\r\n   * Does nothing if columns are outside of effective sheet size\r\n   * @param {ColumnsSpan} addedColumns - object containing information about columns to add\r\n   */\n  doAddColumns(addedColumns) {\n    if (this.columnEffectivelyNotInSheet(addedColumns.columnStart, addedColumns.sheet)) {\n      return;\n    }\n    const {\n      affectedArrays,\n      contentChanges\n    } = this.dependencyGraph.addColumns(addedColumns);\n    this.columnSearch.addColumns(addedColumns);\n    this.columnSearch.applyChanges(contentChanges.getChanges());\n    this.stats.measure(StatType.TRANSFORM_ASTS, () => {\n      const transformation = new AddColumnsTransformer(addedColumns);\n      transformation.performEagerTransformations(this.dependencyGraph, this.parser);\n      this.lazilyTransformingAstService.addTransformation(transformation);\n    });\n    this.rewriteAffectedArrays(affectedArrays);\n  }\n  /**\r\n   * Returns true if row number is outside of given sheet.\r\n   * @param {number} column - row number\r\n   * @param {number} sheet - sheet ID number\r\n   */\n  columnEffectivelyNotInSheet(column, sheet) {\n    const width = this.dependencyGraph.addressMapping.getWidth(sheet);\n    return column >= width;\n  }\n  adjustNamedExpressionEdges(namedExpression, expressionName, sheetId) {\n    if (sheetId === undefined) {\n      return;\n    }\n    const {\n      vertex: localVertex,\n      id: maybeLocalVertexId\n    } = this.dependencyGraph.fetchCellOrCreateEmpty(namedExpression.address);\n    const localVertexId = maybeLocalVertexId !== null && maybeLocalVertexId !== void 0 ? maybeLocalVertexId : this.dependencyGraph.graph.getNodeId(localVertex);\n    const globalNamedExpression = this.namedExpressions.workbookNamedExpressionOrPlaceholder(expressionName);\n    const {\n      vertex: globalVertex,\n      id: maybeGlobalVertexId\n    } = this.dependencyGraph.fetchCellOrCreateEmpty(globalNamedExpression.address);\n    const globalVertexId = maybeGlobalVertexId !== null && maybeGlobalVertexId !== void 0 ? maybeGlobalVertexId : this.dependencyGraph.graph.getNodeId(globalVertex);\n    for (const adjacentNode of this.dependencyGraph.graph.adjacentNodes(globalVertex)) {\n      if (adjacentNode instanceof FormulaCellVertex && adjacentNode.getAddress(this.lazilyTransformingAstService).sheet === sheetId) {\n        const ast = adjacentNode.getFormula(this.lazilyTransformingAstService);\n        const formulaAddress = adjacentNode.getAddress(this.lazilyTransformingAstService);\n        const {\n          dependencies\n        } = this.parser.fetchCachedResultForAst(ast);\n        for (const dependency of absolutizeDependencies(dependencies, formulaAddress)) {\n          if (dependency instanceof NamedExpressionDependency && dependency.name.toLowerCase() === namedExpression.displayName.toLowerCase()) {\n            this.dependencyGraph.graph.removeEdge(globalVertexId, adjacentNode);\n            this.dependencyGraph.graph.addEdge(localVertexId, adjacentNode);\n          }\n        }\n      }\n    }\n  }\n  storeNamedExpressionInCell(address, expression) {\n    const parsedCellContent = this.cellContentParser.parse(expression);\n    if (parsedCellContent instanceof CellContent.Formula) {\n      const parsingResult = this.parser.parse(parsedCellContent.formula, simpleCellAddress(-1, 0, 0));\n      if (doesContainRelativeReferences(parsingResult.ast)) {\n        throw new NoRelativeAddressesAllowedError();\n      }\n      const {\n        ast,\n        hasVolatileFunction,\n        hasStructuralChangeFunction,\n        dependencies\n      } = parsingResult;\n      this.dependencyGraph.setFormulaToCell(address, ast, absolutizeDependencies(dependencies, address), ArraySize.scalar(), hasVolatileFunction, hasStructuralChangeFunction);\n    } else if (parsedCellContent instanceof CellContent.Empty) {\n      this.setCellEmpty(address);\n    } else {\n      this.setValueToCell({\n        parsedValue: parsedCellContent.value,\n        rawValue: expression\n      }, address);\n    }\n  }\n  updateNamedExpressionsForMovedCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n    if (sourceLeftCorner.sheet === destinationLeftCorner.sheet) {\n      return [];\n    }\n    const addedGlobalNamedExpressions = [];\n    const targetRange = AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);\n    for (const formulaAddress of targetRange.addresses(this.dependencyGraph)) {\n      const vertex = this.addressMapping.fetchCell(formulaAddress);\n      if (vertex instanceof FormulaCellVertex && formulaAddress.sheet !== sourceLeftCorner.sheet) {\n        const ast = vertex.getFormula(this.lazilyTransformingAstService);\n        const {\n          dependencies\n        } = this.parser.fetchCachedResultForAst(ast);\n        addedGlobalNamedExpressions.push(...this.updateNamedExpressionsForTargetAddress(sourceLeftCorner.sheet, formulaAddress, dependencies));\n      }\n    }\n    return addedGlobalNamedExpressions;\n  }\n  updateNamedExpressionsForTargetAddress(sourceSheet, targetAddress, dependencies) {\n    if (sourceSheet === targetAddress.sheet) {\n      return [];\n    }\n    const addedGlobalNamedExpressions = [];\n    const vertex = this.addressMapping.fetchCell(targetAddress);\n    for (const namedExpressionDependency of absolutizeDependencies(dependencies, targetAddress)) {\n      if (!(namedExpressionDependency instanceof NamedExpressionDependency)) {\n        continue;\n      }\n      const expressionName = namedExpressionDependency.name;\n      const sourceVertex = this.dependencyGraph.fetchNamedExpressionVertex(expressionName, sourceSheet).vertex;\n      const namedExpressionInTargetScope = this.namedExpressions.isExpressionInScope(expressionName, targetAddress.sheet);\n      const targetScopeExpressionVertex = namedExpressionInTargetScope ? this.dependencyGraph.fetchNamedExpressionVertex(expressionName, targetAddress.sheet).vertex : this.copyOrFetchGlobalNamedExpressionVertex(expressionName, sourceVertex, addedGlobalNamedExpressions);\n      if (targetScopeExpressionVertex !== sourceVertex) {\n        this.dependencyGraph.graph.removeEdgeIfExists(sourceVertex, vertex);\n        this.dependencyGraph.graph.addEdge(targetScopeExpressionVertex, vertex);\n      }\n    }\n    return addedGlobalNamedExpressions;\n  }\n  allocateNamedExpressionAddressSpace() {\n    this.dependencyGraph.addressMapping.addSheet(NamedExpressions.SHEET_FOR_WORKBOOK_EXPRESSIONS, new SparseStrategy(0, 0));\n  }\n  copyOrFetchGlobalNamedExpressionVertex(expressionName, sourceVertex, addedNamedExpressions) {\n    let expression = this.namedExpressions.namedExpressionForScope(expressionName);\n    if (expression === undefined) {\n      expression = this.namedExpressions.addNamedExpression(expressionName);\n      addedNamedExpressions.push(expression.normalizeExpressionName());\n      if (sourceVertex instanceof FormulaCellVertex) {\n        const parsingResult = this.parser.fetchCachedResultForAst(sourceVertex.getFormula(this.lazilyTransformingAstService));\n        const {\n          ast,\n          hasVolatileFunction,\n          hasStructuralChangeFunction,\n          dependencies\n        } = parsingResult;\n        this.dependencyGraph.setFormulaToCell(expression.address, ast, absolutizeDependencies(dependencies, expression.address), ArraySize.scalar(), hasVolatileFunction, hasStructuralChangeFunction);\n      } else if (sourceVertex instanceof EmptyCellVertex) {\n        this.setCellEmpty(expression.address);\n      } else if (sourceVertex instanceof ValueCellVertex) {\n        this.setValueToCell(sourceVertex.getValues(), expression.address);\n      }\n    }\n    return this.dependencyGraph.fetchCellOrCreateEmpty(expression.address).vertex;\n  }\n}\nexport function normalizeRemovedIndexes(indexes) {\n  if (indexes.length <= 1) {\n    return indexes;\n  }\n  const sorted = [...indexes].sort(([a], [b]) => a - b);\n  /* merge overlapping and adjacent indexes */\n  const merged = sorted.reduce((acc, [startIndex, amount]) => {\n    const previous = acc[acc.length - 1];\n    const lastIndex = previous[0] + previous[1];\n    if (startIndex <= lastIndex) {\n      previous[1] += Math.max(0, amount - (lastIndex - startIndex));\n    } else {\n      acc.push([startIndex, amount]);\n    }\n    return acc;\n  }, [sorted[0]]);\n  /* shift further indexes */\n  let shift = 0;\n  for (let i = 0; i < merged.length; ++i) {\n    merged[i][0] -= shift;\n    shift += merged[i][1];\n  }\n  return merged;\n}\nexport function normalizeAddedIndexes(indexes) {\n  if (indexes.length <= 1) {\n    return indexes;\n  }\n  const sorted = [...indexes].sort(([a], [b]) => a - b);\n  /* merge indexes with same start */\n  const merged = sorted.reduce((acc, [startIndex, amount]) => {\n    const previous = acc[acc.length - 1];\n    if (startIndex === previous[0]) {\n      previous[1] = Math.max(previous[1], amount);\n    } else {\n      acc.push([startIndex, amount]);\n    }\n    return acc;\n  }, [sorted[0]]);\n  /* shift further indexes */\n  let shift = 0;\n  for (let i = 0; i < merged.length; ++i) {\n    merged[i][0] += shift;\n    shift += merged[i][1];\n  }\n  return merged;\n}\nfunction isPositiveInteger(n) {\n  return Number.isInteger(n) && n > 0;\n}\nfunction isRowOrColumnRange(leftCorner, width, height) {\n  return leftCorner.row === 0 && isPositiveInteger(width) && height === Number.POSITIVE_INFINITY || leftCorner.col === 0 && isPositiveInteger(height) && width === Number.POSITIVE_INFINITY;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}